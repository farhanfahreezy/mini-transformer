Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
 
Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]

 
Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.

 
Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

To solve this problem efficiently, we can use a hash map (dictionary in Python) to store the numbers we have seen so far and their indices. This allows us to check in constant time whether the complement of the current number (i.e., `target - current_number`) has already been encountered. This approach reduces the time complexity from O(n^2) to O(n).

Here's the implementation:

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # Create a dictionary to store the numbers and their indices
        num_to_index = {}
        
        # Iterate over the list of numbers
        for index, num in enumerate(nums):
            # Calculate the complement
            complement = target - num
            
            # Check if the complement is already in the dictionary
            if complement in num_to_index:
                # If found, return the indices of the complement and the current number
                return [num_to_index[complement], index]
            
            # Otherwise, add the current number and its index to the dictionary
            num_to_index[num] = index
```

### Explanation:
1. We initialize an empty dictionary `num_to_index` to store numbers and their indices as we iterate through the list.
2. For each number in the list, we calculate its complement with respect to the target.
3. We check if this complement is already in the dictionary:
   - If it is, we have found the two numbers that add up to the target, and we return their indices.
   - If it is not, we add the current number and its index to the dictionary.
4. This approach ensures that we only pass through the list once, achieving a time complexity of O(n).

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
 
Example 1:


Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.

Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]

Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]

 
Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy_head = ListNode(0)
        current = dummy_head
        carry = 0
        
        while l1 is not None or l2 is not None or carry != 0:
            val1 = l1.val if l1 is not None else 0
            val2 = l2.val if l2 is not None else 0
            carry, out = divmod(val1 + val2 + carry, 10)
            
            current.next = ListNode(out)
            current = current.next
            
            if l1 is not None:
                l1 = l1.next
            if l2 is not None:
                l2 = l2.next
        
        return dummy_head.next
```

This solution correctly implements the addition of two numbers represented by linked lists. It handles the carry-over for sums greater than 9 and continues processing until all digits and the final carry are processed. The `dummy_head` is used to simplify the code by avoiding special cases for the head of the result list.

Given a string s, find the length of the longest substring without repeating characters.
 
Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.

Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

 
Constraints:

0 <= s.length <= 5 * 104
s consists of English letters, digits, symbols and spaces.



```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        char_index_map = {}
        longest = 0
        start = 0
        
        for i, char in enumerate(s):
            if char in char_index_map and char_index_map[char] >= start:
                start = char_index_map[char] + 1
            char_index_map[char] = i
            longest = max(longest, i - start + 1)
        
        return longest
```

This solution uses a sliding window approach with a hash map to keep track of the last seen index of each character. It iterates through the string, updating the start of the window when a repeated character is found, and calculates the length of the current substring without repeating characters. The longest length found during the iteration is returned as the result.

Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).
 
Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.

Example 2:

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.

 
Constraints:

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106



```python
from typing import List

class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        # Ensure nums1 is the smaller array
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        
        x, y = len(nums1), len(nums2)
        low, high = 0, x
        
        while low <= high:
            partitionX = (low + high) // 2
            partitionY = (x + y + 1) // 2 - partitionX
            
            # If partitionX is 0 it means nothing is there on left side. Use -inf for maxLeftX
            # If partitionX is length of input then there is nothing on right side. Use +inf for minRightX
            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]
            minRightX = float('inf') if partitionX == x else nums1[partitionX]
            
            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]
            minRightY = float('inf') if partitionY == y else nums2[partitionY]
            
            if maxLeftX <= minRightY and maxLeftY <= minRightX:
                # We have partitioned array at correct place
                if (x + y) % 2 == 0:
                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
                else:
                    return max(maxLeftX, maxLeftY)
            elif maxLeftX > minRightY:
                # We are too far on right side for partitionX. Go on left side.
                high = partitionX - 1
            else:
                # We are too far on left side for partitionX. Go on right side.
                low = partitionX + 1
```

This solution uses a binary search approach to find the median in O(log(min(m, n))) time, which meets the problem's complexity requirement. The idea is to partition both arrays such that all elements on the left side are less than or equal to all elements on the right side.

Given a string s, return the longest palindromic substring in s.
 
Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

Example 2:

Input: s = "cbbd"
Output: "bb"

 
Constraints:

1 <= s.length <= 1000
s consist of only digits and English letters.



```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        f = [[True] * n for _ in range(n)]
        k, mx = 0, 1
        for i in range(n - 2, -1, -1):
            for j in range(i + 1, n):
                f[i][j] = False
                if s[i] == s[j]:
                    f[i][j] = f[i + 1][j - 1]
                    if f[i][j] and mx < j - i + 1:
                        k, mx = i, j - i + 1
        return s[k : k + mx]
```

This solution uses dynamic programming to find the longest palindromic substring. The 2D list `f` is used to store whether the substring `s[i:j+1]` is a palindrome. The algorithm iterates over all possible substrings, updating the `f` table and keeping track of the longest palindrome found.

The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R

And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);

 
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"

Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I

Example 3:

Input: s = "A", numRows = 1
Output: "A"

 
Constraints:

1 <= s.length <= 1000
s consists of English letters (lower-case and upper-case), ',' and '.'.
1 <= numRows <= 1000



```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        
        # Create a list of strings for each row
        rows = [''] * numRows
        current_row = 0
        going_down = False
        
        for char in s:
            rows[current_row] += char
            if current_row == 0 or current_row == numRows - 1:
                going_down = not going_down
            current_row += 1 if going_down else -1
        
        # Join all rows to get the final string
        return ''.join(rows)
```

This solution handles the zigzag conversion by iterating through each character in the string `s` and appending it to the appropriate row in the `rows` list. The `current_row` variable keeps track of the current row, and the `going_down` boolean flag determines the direction of traversal (down or up). After processing all characters, the rows are concatenated to produce the final result.

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
 
Example 1:

Input: x = 123
Output: 321

Example 2:

Input: x = -123
Output: -321

Example 3:

Input: x = 120
Output: 21

 
Constraints:

-231 <= x <= 231 - 1



```python
class Solution:
    def reverse(self, x: int) -> int:
        # Determine the sign of the number
        sign = -1 if x < 0 else 1
        
        # Reverse the digits of the absolute value of the number
        reversed_digits = int(str(abs(x))[::-1])
        
        # Restore the sign
        reversed_number = sign * reversed_digits
        
        # Check if the reversed number is within the 32-bit signed integer range
        if reversed_number < -2**31 or reversed_number > 2**31 - 1:
            return 0
        
        return reversed_number
```

Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.
The algorithm for myAtoi(string s) is as follows:

Whitespace: Ignore any leading whitespace (" ").
Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.
Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.
Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.

Return the integer as the final result.
 
Example 1:

Input: s = "42"
Output: 42
Explanation:

The underlined characters are what is read in and the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "42" ("42" is read in)
           ^


Example 2:

Input: s = " -042"
Output: -42
Explanation:

Step 1: "   -042" (leading whitespace is read and ignored)
            ^
Step 2: "   -042" ('-' is read, so the result should be negative)
             ^
Step 3: "   -042" ("042" is read in, leading zeros ignored in the result)
               ^


Example 3:

Input: s = "1337c0d3"
Output: 1337
Explanation:

Step 1: "1337c0d3" (no characters read because there is no leading whitespace)
         ^
Step 2: "1337c0d3" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "1337c0d3" ("1337" is read in; reading stops because the next character is a non-digit)
             ^


Example 4:

Input: s = "0-1"
Output: 0
Explanation:

Step 1: "0-1" (no characters read because there is no leading whitespace)
         ^
Step 2: "0-1" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "0-1" ("0" is read in; reading stops because the next character is a non-digit)
          ^


Example 5:

Input: s = "words and 987"
Output: 0
Explanation:
Reading stops at the first non-digit character 'w'.

 
Constraints:

0 <= s.length <= 200
s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.



```python
class Solution:
    def myAtoi(self, s: str) -> int:
        # Step 1: Ignore leading whitespace
        s = s.lstrip()
        
        # Step 2: Check if the string is empty after stripping whitespace
        if not s:
            return 0
        
        # Step 3: Determine the sign
        sign = 1
        if s[0] == '-':
            sign = -1
            s = s[1:]
        elif s[0] == '+':
            s = s[1:]
        
        # Step 4: Read in the digits until a non-digit is encountered
        result = 0
        for char in s:
            if char.isdigit():
                result = result * 10 + int(char)
            else:
                break
        
        # Step 5: Apply the sign
        result *= sign
        
        # Step 6: Clamp the result to the 32-bit signed integer range
        INT_MIN = -2**31
        INT_MAX = 2**31 - 1
        if result < INT_MIN:
            return INT_MIN
        elif result > INT_MAX:
            return INT_MAX
        else:
            return result
```

This implementation follows the problem's specification and handles all the given examples and constraints. It first removes leading whitespace, checks for a sign, reads digits, applies the sign, and finally clamps the result to the 32-bit signed integer range.

Given an integer x, return true if x is a palindrome, and false otherwise.
 
Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.

Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

 
Constraints:

-231 <= x <= 231 - 1

 
Follow up: Could you solve it without converting the integer to a string?

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # Negative numbers are not palindromes
        if x < 0:
            return False
        
        # Initialize variables to store the original and reversed numbers
        original = x
        reversed_num = 0
        
        # Reverse the number
        while x > 0:
            digit = x % 10
            reversed_num = reversed_num * 10 + digit
            x //= 10
        
        # Check if the original number is equal to the reversed number
        return original == reversed_num
```

Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:

'.' Matches any single character.​​​​
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).
 
Example 1:

Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".

Example 2:

Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".

Example 3:

Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".

 
Constraints:

1 <= s.length <= 20
1 <= p.length <= 20
s contains only lowercase English letters.
p contains only lowercase English letters, '.', and '*'.
It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.



```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # Dynamic programming table
        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
        
        # Empty pattern matches empty string
        dp[-1][-1] = True
        
        # Fill the table from bottom-right to top-left
        for i in range(len(s), -1, -1):
            for j in range(len(p) - 1, -1, -1):
                first_match = (i < len(s)) and p[j] in {s[i], '.'}
                
                if j+1 < len(p) and p[j+1] == '*':
                    dp[i][j] = dp[i][j+2] or (first_match and dp[i+1][j])
                else:
                    dp[i][j] = first_match and dp[i+1][j+1]
        
        return dp[0][0]
```

This solution uses dynamic programming to solve the problem of regular expression matching. The `dp` table is used to store whether the substring `s[i:]` matches the pattern `p[j:]`. The table is filled in a bottom-up manner, starting from the base case where an empty pattern matches an empty string. The solution handles the special characters `.` and `*` as specified in the problem statement.

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.
Notice that you may not slant the container.
 
Example 1:


Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

Example 2:

Input: height = [1,1]
Output: 1

 
Constraints:

n == height.length
2 <= n <= 105
0 <= height[i] <= 104



```python
from typing import List

class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        max_area = 0
        
        while left < right:
            # Calculate the area with the current left and right pointers
            current_area = min(height[left], height[right]) * (right - left)
            max_area = max(max_area, current_area)
            
            # Move the pointer pointing to the shorter line inward
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        
        return max_area
```

This solution uses the two-pointer technique to efficiently find the maximum area. It starts with two pointers at the beginning and end of the list and moves the pointer pointing to the shorter line inward, always calculating the area and updating the maximum area found. This ensures that all possible pairs of lines are considered without unnecessary calculations.

Seven different symbols represent Roman numerals with the following values:



Symbol
Value




I
1


V
5


X
10


L
50


C
100


D
500


M
1000



Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:

If the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.
If the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).
Only powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.

Given an integer, convert it to a Roman numeral.
 
Example 1:

Input: num = 3749
Output: "MMMDCCXLIX"
Explanation:

3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)
 700 = DCC as 500 (D) + 100 (C) + 100 (C)
  40 = XL as 10 (X) less of 50 (L)
   9 = IX as 1 (I) less of 10 (X)
Note: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places


Example 2:

Input: num = 58
Output: "LVIII"
Explanation:

50 = L
 8 = VIII


Example 3:

Input: num = 1994
Output: "MCMXCIV"
Explanation:

1000 = M
 900 = CM
  90 = XC
   4 = IV


 
Constraints:

1 <= num <= 3999



```python
class Solution:
    def intToRoman(self, num: int) -> str:
        # Define a list of tuples that map integers to their corresponding Roman numeral strings
        val = [
            (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),
            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),
            (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')
        ]
        
        # Initialize an empty string to build the Roman numeral
        roman_numeral = ""
        
        # Iterate over the value-symbol pairs
        for (integer, symbol) in val:
            # Determine how many times the symbol can fit into the remaining number
            count = num // integer
            # Append the symbol 'count' times to the result
            roman_numeral += symbol * count
            # Reduce the number by the equivalent integer value
            num -= integer * count
        
        return roman_numeral
```

This solution efficiently converts an integer to a Roman numeral by iterating over a predefined list of value-symbol pairs, appending the appropriate symbols to the result string, and reducing the number accordingly.

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.

Given a roman numeral, convert it to an integer.
 
Example 1:

Input: s = "III"
Output: 3
Explanation: III = 3.

Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.

Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

 
Constraints:

1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].



```python
class Solution:
    def romanToInt(self, s: str) -> int:
        # Create a dictionary to map Roman numeral characters to their integer values
        roman_values = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
        
        # Initialize the total to 0
        total = 0
        # Get the length of the input string
        n = len(s)
        
        # Iterate through each character in the string
        for i in range(n):
            # If the current value is less than the next value, subtract it
            if i < n - 1 and roman_values[s[i]] < roman_values[s[i + 1]]:
                total -= roman_values[s[i]]
            else:
                # Otherwise, add the current value
                total += roman_values[s[i]]
        
        return total
```

This solution iterates through the Roman numeral string and uses a dictionary to convert each character to its integer value. It checks if the current numeral is less than the next numeral to handle the subtraction cases (like IV for 4 or IX for 9). If it is, it subtracts the current value from the total; otherwise, it adds the current value. This approach ensures that the Roman numeral is correctly converted to an integer.

Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string "".
 
Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"

Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

 
Constraints:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lowercase English letters if it is non-empty.



```python
from typing import List

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        # Start by assuming the whole first string is the common prefix
        prefix = strs[0]
        
        # Compare the prefix with each string in the list
        for string in strs[1:]:
            # Reduce the prefix length until it matches the start of the string
            while string[:len(prefix)] != prefix and prefix:
                prefix = prefix[:-1]
            # If at any point the prefix becomes empty, return immediately
            if not prefix:
                return ""
        
        return prefix
```

Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
 
Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.

Example 2:

Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.

Example 3:

Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.

 
Constraints:

3 <= nums.length <= 3000
-105 <= nums[i] <= 105



```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        result = []
        n = len(nums)
        
        for i in range(n):
            # Skip the same element to avoid duplicate triplets
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            
            left, right = i + 1, n - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total == 0:
                    result.append([nums[i], nums[left], nums[right]])
                    # Move the left pointer to the right, skipping duplicates
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    # Move the right pointer to the left, skipping duplicates
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1
        
        return result
```

This solution sorts the input list and uses a two-pointer approach to find all unique triplets that sum to zero. It skips over duplicate elements to ensure the result contains only unique triplets.

Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.
 
Example 1:

Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

Example 2:

Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).

 
Constraints:

3 <= nums.length <= 500
-1000 <= nums[i] <= 1000
-104 <= target <= 104



```python
from typing import List

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()  # Sort the array to use the two-pointer technique
        closest_sum = float('inf')  # Initialize the closest sum to a large number
        
        for i in range(len(nums) - 2):
            left, right = i + 1, len(nums) - 1
            
            while left < right:
                current_sum = nums[i] + nums[left] + nums[right]
                
                # Check if the current sum is closer to the target than the closest sum found so far
                if abs(current_sum - target) < abs(closest_sum - target):
                    closest_sum = current_sum
                
                # Move the pointers based on the comparison with the target
                if current_sum < target:
                    left += 1
                elif current_sum > target:
                    right -= 1
                else:
                    # If the current sum is exactly equal to the target, return it immediately
                    return current_sum
        
        return closest_sum
```

This solution sorts the input list and uses a two-pointer approach to find the three numbers whose sum is closest to the target. The time complexity is O(n^2) due to the nested loops, which is efficient given the problem constraints.

Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

 
Example 1:

Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

Example 2:

Input: digits = ""
Output: []

Example 3:

Input: digits = "2"
Output: ["a","b","c"]

 
Constraints:

0 <= digits.length <= 4
digits[i] is a digit in the range ['2', '9'].



```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        d = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        ans = [""]
        for i in digits:
            s = d[int(i) - 2]
            ans = [a + b for a in ans for b in s]
        return ans
```

Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target

You may return the answer in any order.
 
Example 1:

Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

Example 2:

Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]

 
Constraints:

1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109



```python
from typing import List

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        result = []
        
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, n):
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                left, right = j + 1, n - 1
                while left < right:
                    total = nums[i] + nums[j] + nums[left] + nums[right]
                    if total == target:
                        result.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                    elif total < target:
                        left += 1
                    else:
                        right -= 1
        
        return result
```

This solution uses a sorting-based approach combined with the two-pointer technique to efficiently find all unique quadruplets that sum up to the target. The solution first sorts the array, then iterates through the array with two nested loops for the first two numbers of the quadruplet. For the last two numbers, it uses two pointers to find pairs that, along with the first two numbers, sum up to the target. The solution also includes checks to skip over duplicate values to ensure that the quadruplets are unique.

Given the head of a linked list, remove the nth node from the end of the list and return its head.
 
Example 1:


Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:

Input: head = [1], n = 1
Output: []

Example 3:

Input: head = [1,2], n = 1
Output: [1]

 
Constraints:

The number of nodes in the list is sz.
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz

 
Follow up: Could you do this in one pass?


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # Create a dummy node that points to the head of the list
        dummy = ListNode(0)
        dummy.next = head
        first = dummy
        second = dummy
        
        # Move first pointer n+1 steps ahead
        for _ in range(n + 1):
            first = first.next
        
        # Move both pointers until first reaches the end
        while first is not None:
            first = first.next
            second = second.next
        
        # Remove the nth node from the end
        second.next = second.next.next
        
        # Return the head of the modified list
        return dummy.next
```

This solution uses the two-pointer technique to remove the nth node from the end of the linked list in one pass. The `dummy` node is used to handle edge cases where the head node itself might be removed.

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

 
Example 1:

Input: s = "()"
Output: true

Example 2:

Input: s = "()[]{}"
Output: true

Example 3:

Input: s = "(]"
Output: false

Example 4:

Input: s = "([])"
Output: true

 
Constraints:

1 <= s.length <= 104
s consists of parentheses only '()[]{}'.



```python
class Solution:
    def isValid(self, s: str) -> bool:
        # Dictionary to hold the mapping of closing to opening brackets
        bracket_map = {')': '(', '}': '{', ']': '['}
        # Stack to keep track of opening brackets
        stack = []

        # Iterate through each character in the string
        for char in s:
            # If the character is a closing bracket
            if char in bracket_map:
                # Pop the top element from the stack if it's not empty, else use a dummy value
                top_element = stack.pop() if stack else '#'
                # Check if the popped element matches the corresponding opening bracket
                if bracket_map[char] != top_element:
                    return False
            else:
                # If it's an opening bracket, push it onto the stack
                stack.append(char)

        # If the stack is empty, all opening brackets were matched correctly
        return not stack
```

This solution uses a stack to ensure that each closing bracket matches the most recent unmatched opening bracket, and that all opening brackets are properly closed. The `bracket_map` dictionary provides a quick lookup for the corresponding opening bracket of each closing bracket. The function returns `True` if the string is valid and `False` otherwise.

You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
 
Example 1:


Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]

Example 2:

Input: list1 = [], list2 = []
Output: []

Example 3:

Input: list1 = [], list2 = [0]
Output: [0]

 
Constraints:

The number of nodes in both lists is in the range [0, 50].
-100 <= Node.val <= 100
Both list1 and list2 are sorted in non-decreasing order.



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if list1 is None or list2 is None:
            return list1 or list2
        if list1.val <= list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
 
Example 1:
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
Example 2:
Input: n = 1
Output: ["()"]

 
Constraints:

1 <= n <= 8



```python
from typing import List

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def backtrack(s='', left=0, right=0):
            if len(s) == 2 * n:
                result.append(s)
                return
            if left < n:
                backtrack(s + '(', left + 1, right)
            if right < left:
                backtrack(s + ')', left, right + 1)
        
        result = []
        backtrack()
        return result
```

This solution uses a backtracking approach to generate all combinations of well-formed parentheses. The `backtrack` function builds the string `s` by adding either an opening or a closing parenthesis, ensuring at all times that the number of closing parentheses does not exceed the number of opening ones. When the string reaches the required length of `2 * n`, it is added to the result list.

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
 
Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:

Input: lists = []
Output: []

Example 3:

Input: lists = [[]]
Output: []

 
Constraints:

k == lists.length
0 <= k <= 104
0 <= lists[i].length <= 500
-104 <= lists[i][j] <= 104
lists[i] is sorted in ascending order.
The sum of lists[i].length will not exceed 104.



To solve the problem of merging k sorted linked lists into one sorted linked list, we can use a min-heap (priority queue) to efficiently get the smallest element among the heads of the k lists. This approach ensures that we always pick the smallest available node and attach it to the result list, maintaining the sorted order.

Here's the complete solution using the provided starter code:

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
import heapq
from typing import List, Optional

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        # Initialize a min-heap
        min_heap = []
        
        # Push the head of each list into the heap
        for i, lst in enumerate(lists):
            if lst:
                heapq.heappush(min_heap, (lst.val, i, lst))
        
        # Dummy head to help easily return the merged list
        dummy = ListNode()
        current = dummy
        
        # While there are still nodes in the heap
        while min_heap:
            # Pop the smallest element from the heap
            val, i, node = heapq.heappop(min_heap)
            # Attach the smallest node to the merged list
            current.next = node
            current = current.next
            # If there is a next node in the same list, push it into the heap
            if node.next:
                heapq.heappush(min_heap, (node.next.val, i, node.next))
        
        # Return the merged list, which starts at dummy.next
        return dummy.next
```

### Explanation:
1. **Heap Initialization**: We use a min-heap to keep track of the smallest elements among the heads of the k lists. Each entry in the heap is a tuple containing the value of the node, the index of the list it belongs to, and the node itself.

2. **Push Initial Nodes**: We push the head node of each non-empty list into the heap.

3. **Merge Process**: We repeatedly pop the smallest node from the heap, attach it to the merged list, and then push the next node from the same list into the heap if it exists.

4. **Dummy Node**: We use a dummy node to simplify the merging process and easily return the head of the merged list.

5. **Return the Result**: Finally, we return `dummy.next`, which points to the head of the merged sorted linked list.

This solution is efficient with a time complexity of \(O(N \log k)\), where \(N\) is the total number of nodes across all lists, and \(k\) is the number of lists. The space complexity is \(O(k)\) for the heap.

Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
 
Example 1:

Input: head = [1,2,3,4]
Output: [2,1,4,3]
Explanation:


Example 2:

Input: head = []
Output: []

Example 3:

Input: head = [1]
Output: [1]

Example 4:

Input: head = [1,2,3]
Output: [2,1,3]

 
Constraints:

The number of nodes in the list is in the range [0, 100].
0 <= Node.val <= 100



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Create a dummy node to simplify edge cases
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        
        while head and head.next:
            # Nodes to be swapped
            first = head
            second = head.next
            
            # Swapping
            prev.next = second
            first.next = second.next
            second.next = first
            
            # Move prev and head pointers
            prev = first
            head = first.next
        
        return dummy.next
```

Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.
You may not alter the values in the list's nodes, only nodes themselves may be changed.
 
Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:


Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]

 
Constraints:

The number of nodes in the list is n.
1 <= k <= n <= 5000
0 <= Node.val <= 1000

 
Follow-up: Can you solve the problem in O(1) extra memory space?


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        def reverseLinkedList(start, end):
            prev, curr = None, start
            while curr != end:
                next_node = curr.next
                curr.next = prev
                prev = curr
                curr = next_node
            return prev
        
        # Create a dummy node to handle edge cases more easily
        dummy = ListNode(0)
        dummy.next = head
        before = dummy
        after = head
        
        while after:
            count = 0
            # Check if there are at least k nodes left in the list
            while after and count < k:
                after = after.next
                count += 1
            
            # If there are less than k nodes, we are done
            if count < k:
                break
            
            # Reverse the k nodes
            last_in_reversed = before.next
            new_end = after
            new_start = reverseLinkedList(before.next, after)
            
            # Connect the reversed segment with the rest of the list
            before.next = new_start
            last_in_reversed.next = new_end
            
            # Move the pointers for the next iteration
            before = last_in_reversed
        
        return dummy.next
```

This solution works by iterating through the linked list in segments of size `k`. For each segment, it reverses the nodes and then re-links the reversed segment back into the list. The process continues until there are fewer than `k` nodes left, at which point the remaining nodes are left as is. The use of a dummy node simplifies edge cases, such as when the head of the list is part of the first segment to be reversed.

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.
Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

Custom Judge:
The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}

If all assertions pass, then your solution will be accepted.
 
Example 1:

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Example 2:

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

 
Constraints:

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
nums is sorted in non-decreasing order.



```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        # Initialize the slow pointer
        k = 0
        
        # Iterate with the fast pointer
        for i in range(1, len(nums)):
            if nums[i] != nums[k]:
                k += 1
                nums[k] = nums[i]
        
        # k is the index of the last unique element, so we return k + 1
        return k + 1
```

This solution uses a two-pointer technique to efficiently remove duplicates in-place. The `slow` pointer (`k`) tracks the position of the last unique element found, while the `fast` pointer (`i`) iterates through the list. When a new unique element is found, it is placed next to the last unique element found. The function finally returns the number of unique elements, which is `k + 1`.

Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.
Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
Return k.

Custom Judge:
The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}

If all assertions pass, then your solution will be accepted.
 
Example 1:

Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).

Example 2:

Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).

 
Constraints:

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100



```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k = 0  # This will be the count of elements not equal to val
        for i in range(len(nums)):
            if nums[i] != val:
                nums[k] = nums[i]
                k += 1
        return k
```

This solution works as follows:

1. We initialize a variable `k` to keep track of the number of elements that are not equal to `val`.

2. We iterate through the list `nums` using a for loop.

3. For each element, we check if it is not equal to `val`. If it is not equal, we place it at the `k`-th index of the list and then increment `k`.

4. After the loop, `k` will represent the number of elements in `nums` that are not equal to `val`, and the first `k` elements of `nums` will be the elements that are not equal to `val`.

5. We return `k` as the result.

Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
 
Example 1:

Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.

Example 2:

Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.

 
Constraints:

1 <= haystack.length, needle.length <= 104
haystack and needle consist of only lowercase English characters.



```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if not needle:
            return 0
        if needle not in haystack:
            return -1
        return haystack.index(needle)
```

This solution uses Python's built-in string methods to find the first occurrence of `needle` in `haystack`. It handles the edge case where `needle` is an empty string by returning 0, as specified in the problem statement. If `needle` is not found in `haystack`, it returns -1. Otherwise, it returns the index of the first occurrence of `needle` in `haystack`.

Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.
 
Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = 3.33333.. which is truncated to 3.

Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = -2.33333.. which is truncated to -2.

 
Constraints:

-231 <= dividend, divisor <= 231 - 1
divisor != 0



```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        # Handle overflow case
        if dividend == -2**31 and divisor == -1:
            return 2**31 - 1
        
        # Determine the sign of the result
        negative = (dividend < 0) != (divisor < 0)
        
        # Work with positive values for simplicity
        dividend, divisor = abs(dividend), abs(divisor)
        
        # Initialize the quotient
        quotient = 0
        
        # Bit manipulation to find the largest multiple
        while dividend >= divisor:
            temp_divisor, multiple = divisor, 1
            while dividend >= (temp_divisor << 1):
                temp_divisor <<= 1
                multiple <<= 1
            dividend -= temp_divisor
            quotient += multiple
        
        # Apply the sign to the quotient
        if negative:
            quotient = -quotient
        
        return quotient
```

This solution uses bit manipulation to perform the division without using multiplication, division, or mod operators. It handles the overflow case separately and determines the sign of the result before working with positive values. The algorithm repeatedly subtracts the largest possible multiple of the divisor from the dividend, effectively performing division through bit shifts.

You are given a string s and an array of strings words. All the strings of words are of the same length.
A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.

For example, if words = ["ab","cd","ef"], then "abcdef", "abefcd", "cdabef", "cdefab", "efabcd", and "efcdab" are all concatenated strings. "acdbef" is not a concatenated string because it is not the concatenation of any permutation of words.

Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.
 
Example 1:

Input: s = "barfoothefoobarman", words = ["foo","bar"]
Output: [0,9]
Explanation:
The substring starting at 0 is "barfoo". It is the concatenation of ["bar","foo"] which is a permutation of words.
The substring starting at 9 is "foobar". It is the concatenation of ["foo","bar"] which is a permutation of words.

Example 2:

Input: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
Output: []
Explanation:
There is no concatenated substring.

Example 3:

Input: s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
Output: [6,9,12]
Explanation:
The substring starting at 6 is "foobarthe". It is the concatenation of ["foo","bar","the"].
The substring starting at 9 is "barthefoo". It is the concatenation of ["bar","the","foo"].
The substring starting at 12 is "thefoobar". It is the concatenation of ["the","foo","bar"].

 
Constraints:

1 <= s.length <= 104
1 <= words.length <= 5000
1 <= words[i].length <= 30
s and words[i] consist of lowercase English letters.



```python
from collections import Counter
from typing import List

class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if not s or not words or not words[0]:
            return []
        
        word_length = len(words[0])
        num_words = len(words)
        total_length = word_length * num_words
        word_count = Counter(words)
        result = []
        
        # Iterate over each possible starting point
        for i in range(word_length):
            left = i
            right = i
            current_count = Counter()
            
            while right + word_length <= len(s):
                word = s[right:right + word_length]
                right += word_length
                
                if word in word_count:
                    current_count[word] += 1
                    
                    while current_count[word] > word_count[word]:
                        current_count[s[left:left + word_length]] -= 1
                        left += word_length
                    
                    if right - left == total_length:
                        result.append(left)
                
                else:
                    current_count.clear()
                    left = right
        
        return result
```

This solution uses a sliding window approach combined with a hash map (Counter) to efficiently find all starting indices of concatenated substrings in `s` that match any permutation of `words`. The algorithm works by iterating over each possible starting point within the first `word_length` characters of `s` and then expanding a window to the right, checking if the current window contains a valid permutation of `words`. If it does, the starting index is added to the result list. If an invalid word is encountered, the window is reset from the left.

A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].

The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

For example, the next permutation of arr = [1,2,3] is [1,3,2].
Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.

Given an array of integers nums, find the next permutation of nums.
The replacement must be in place and use only constant extra memory.
 
Example 1:

Input: nums = [1,2,3]
Output: [1,3,2]

Example 2:

Input: nums = [3,2,1]
Output: [1,2,3]

Example 3:

Input: nums = [1,1,5]
Output: [1,5,1]

 
Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 100



```python
from typing import List

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # Find the first decreasing element from the end
        i = len(nums) - 2
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        
        # If the entire array is decreasing, reverse it to get the smallest permutation
        if i == -1:
            nums.reverse()
            return
        
        # Find the element just larger than nums[i] to the right of i
        j = len(nums) - 1
        while nums[j] <= nums[i]:
            j -= 1
        
        # Swap the found elements
        nums[i], nums[j] = nums[j], nums[i]
        
        # Reverse the elements to the right of i to get the next permutation
        nums[i + 1:] = reversed(nums[i + 1:])
```

This solution implements the algorithm to find the next permutation in lexicographical order in-place with constant extra memory. It follows these steps:

1. Traverse the array from the end to find the first element that is not in non-increasing order (i.e., find the first `i` such that `nums[i] < nums[i + 1]`).
2. If no such element is found, the array is in descending order, and the next permutation is the ascending order (reverse the array).
3. If such an element is found, traverse the array from the end to find the first element that is larger than `nums[i]` (i.e., find the first `j` such that `nums[j] > nums[i]`).
4. Swap the elements at indices `i` and `j`.
5. Reverse the subarray to the right of index `i` to get the next permutation in lexicographical order.

Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.
 
Example 1:

Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".

Example 2:

Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".

Example 3:

Input: s = ""
Output: 0

 
Constraints:

0 <= s.length <= 3 * 104
s[i] is '(', or ')'.



```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]  # Initialize stack with -1 to handle edge cases
        max_length = 0
        
        for i, char in enumerate(s):
            if char == '(':
                stack.append(i)  # Push the index of '(' onto the stack
            else:
                stack.pop()  # Pop the last index from the stack for ')'
                if not stack:
                    stack.append(i)  # If stack is empty, push current index as base
                else:
                    max_length = max(max_length, i - stack[-1])  # Calculate the length of the current valid substring
        
        return max_length
```

This solution uses a stack to keep track of the indices of the parentheses. The key idea is to use the stack to find the longest valid substring by matching each closing parenthesis with its corresponding opening parenthesis. The stack is initialized with -1 to handle the case where the entire string is a valid substring. The algorithm iterates through the string, updating the stack and calculating the maximum length of valid substrings found.

There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.
You must write an algorithm with O(log n) runtime complexity.
 
Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
Example 3:
Input: nums = [1], target = 0
Output: -1

 
Constraints:

1 <= nums.length <= 5000
-104 <= nums[i] <= 104
All values of nums are unique.
nums is an ascending array that is possibly rotated.
-104 <= target <= 104



```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        n = len(nums)
        left, right = 0, n - 1
        while left < right:
            mid = (left + right) >> 1
            if nums[0] <= nums[mid]:
                if nums[0] <= target <= nums[mid]:
                    right = mid
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[n - 1]:
                    left = mid + 1
                else:
                    right = mid
        return left if nums[left] == target else -1
```

This solution implements a modified binary search algorithm to find the target in a rotated sorted array. The key idea is to determine which part of the array is sorted and then decide which part to search next based on the target value. This approach ensures an O(log n) runtime complexity.

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
 
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:
Input: nums = [], target = 0
Output: [-1,-1]

 
Constraints:

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums is a non-decreasing array.
-109 <= target <= 109



```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def find_left(nums, target):
            left, right = 0, len(nums) - 1
            while left <= right:
                mid = (left + right) // 2
                if nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return left

        def find_right(nums, target):
            left, right = 0, len(nums) - 1
            while left <= right:
                mid = (left + right) // 2
                if nums[mid] <= target:
                    left = mid + 1
                else:
                    right = mid - 1
            return right

        left_index = find_left(nums, target)
        right_index = find_right(nums, target)

        if left_index <= right_index and 0 <= right_index < len(nums) and nums[left_index] == target:
            return [left_index, right_index]
        else:
            return [-1, -1]
```

This solution uses binary search to find the leftmost and rightmost positions of the target in the sorted array, achieving the required O(log n) runtime complexity. The `find_left` function locates the starting index of the target, while the `find_right` function locates the ending index. If the target is not found, it returns [-1, -1].

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
 
Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1

Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4

 
Constraints:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums contains distinct values sorted in ascending order.
-104 <= target <= 104



```python
from typing import List

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = left + (right - left) // 2
            
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return left
```

This solution uses binary search to achieve the required O(log n) runtime complexity. It iteratively narrows down the possible positions of the target value by comparing it with the middle element of the current search range. If the target is found, it returns the index. If not, it returns the index where the target should be inserted to maintain the sorted order.

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.

 
Example 1:


Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true

Example 2:

Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.

 
Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit 1-9 or '.'.



```python
from typing import List

class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        def is_valid_block(block):
            block = [num for num in block if num != '.']
            return len(block) == len(set(block))
        
        # Check rows
        for row in board:
            if not is_valid_block(row):
                return False
        
        # Check columns
        for col in range(9):
            if not is_valid_block([board[row][col] for row in range(9)]):
                return False
        
        # Check 3x3 sub-boxes
        for box_row in range(0, 9, 3):
            for box_col in range(0, 9, 3):
                block = [
                    board[r][c]
                    for r in range(box_row, box_row + 3)
                    for c in range(box_col, box_col + 3)
                ]
                if not is_valid_block(block):
                    return False
        
        return True
```

This solution checks the validity of a Sudoku board by ensuring that each row, column, and 3x3 sub-box contains unique digits (ignoring '.' which represents empty cells). The `is_valid_block` function is used to verify that each block meets the Sudoku rules.

Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.

The '.' character indicates empty cells.
 
Example 1:


Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
Explanation: The input board is shown above and the only valid solution is shown below:



 
Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit or '.'.
It is guaranteed that the input board has only one solution.



```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def dfs(k):
            nonlocal ok
            if k == len(t):
                ok = True
                return
            i, j = t[k]
            for v in range(9):
                if row[i][v] == col[j][v] == block[i // 3][j // 3][v] == False:
                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = True
                    board[i][j] = str(v + 1)
                    dfs(k + 1)
                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = False
                if ok:
                    return

        row = [[False] * 9 for _ in range(9)]
        col = [[False] * 9 for _ in range(9)]
        block = [[[False] * 9 for _ in range(3)] for _ in range(3)]
        t = []
        ok = False
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    t.append((i, j))
                else:
                    v = int(board[i][j]) - 1
                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = True
        dfs(0)
```

This solution uses a backtracking algorithm with depth-first search (DFS) to solve the Sudoku puzzle. The `dfs` function attempts to fill the board by trying each possible number (1-9) in each empty cell, while ensuring that the number does not violate Sudoku rules. The `row`, `col`, and `block` arrays keep track of which numbers have already been used in each row, column, and 3x3 sub-box, respectively. The `t` list contains the coordinates of all empty cells that need to be filled. The `ok` flag is used to terminate the search once a valid solution is found.

The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

countAndSay(1) = "1"
countAndSay(n) is the run-length encoding of countAndSay(n - 1).

Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".
Given a positive integer n, return the nth element of the count-and-say sequence.
 
Example 1:

Input: n = 4
Output: "1211"
Explanation:

countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"


Example 2:

Input: n = 1
Output: "1"
Explanation:
This is the base case.

 
Constraints:

1 <= n <= 30

 
Follow up: Could you solve it iteratively?

```python
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return "1"
        
        # Start with the first element of the sequence
        current_sequence = "1"
        
        # Generate the sequence iteratively from 2 to n
        for _ in range(2, n + 1):
            next_sequence = ""
            i = 0
            while i < len(current_sequence):
                count = 1
                # Count the number of times the current character repeats
                while i + 1 < len(current_sequence) and current_sequence[i] == current_sequence[i + 1]:
                    count += 1
                    i += 1
                # Append the count and the character to the next sequence
                next_sequence += str(count) + current_sequence[i]
                i += 1
            # Update the current sequence to the next sequence
            current_sequence = next_sequence
        
        return current_sequence
```

This solution generates the count-and-say sequence iteratively by building each sequence from the previous one. It uses a while loop to count consecutive characters and constructs the next sequence by appending the count followed by the character.

Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.
The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.
 
Example 1:

Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

Example 2:

Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Example 3:

Input: candidates = [2], target = 1
Output: []

 
Constraints:

1 <= candidates.length <= 30
2 <= candidates[i] <= 40
All elements of candidates are distinct.
1 <= target <= 40



```python
from typing import List

class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtrack(remaining, start, path, result):
            if remaining == 0:
                result.append(list(path))
                return
            elif remaining < 0:
                return
            
            for i in range(start, len(candidates)):
                path.append(candidates[i])
                backtrack(remaining - candidates[i], i, path, result)
                path.pop()
        
        result = []
        candidates.sort()  # Optional: sort to optimize and break early if remaining < 0
        backtrack(target, 0, [], result)
        return result
```

This solution uses a backtracking approach to find all unique combinations of numbers from the `candidates` list that sum up to the `target`. The `backtrack` function is a recursive helper that tries to build combinations by adding each candidate (starting from a certain point to avoid duplicates) and checking if the remaining target is met. If the remaining target becomes negative, it backtracks by removing the last added candidate. If the remaining target is zero, it adds the current path to the result list.

Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.
Each number in candidates may only be used once in the combination.
Note: The solution set must not contain duplicate combinations.
 
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

Example 2:

Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]

 
Constraints:

1 <= candidates.length <= 100
1 <= candidates[i] <= 50
1 <= target <= 30



```python
from typing import List

class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtrack(start, path, target):
            if target == 0:
                result.append(path)
                return
            if target < 0:
                return
            for i in range(start, len(candidates)):
                # Skip duplicates
                if i > start and candidates[i] == candidates[i - 1]:
                    continue
                # Include candidates[i] in the combination
                backtrack(i + 1, path + [candidates[i]], target - candidates[i])
        
        candidates.sort()  # Sort to handle duplicates and make it easier to skip them
        result = []
        backtrack(0, [], target)
        return result
```

This solution uses backtracking to explore all possible combinations of the candidate numbers that sum up to the target. The candidates are first sorted to make it easier to skip over duplicates. The `backtrack` function is a recursive helper function that builds combinations and checks if they meet the target sum. If a valid combination is found, it is added to the result list. If the current combination's sum exceeds the target, the function returns early to prune the search space. Duplicates are skipped by checking if the current candidate is the same as the previous one in the sorted list.

Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.
You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.
 
Example 1:

Input: nums = [1,2,0]
Output: 3
Explanation: The numbers in the range [1,2] are all in the array.

Example 2:

Input: nums = [3,4,-1,1]
Output: 2
Explanation: 1 is in the array but 2 is missing.

Example 3:

Input: nums = [7,8,9,11,12]
Output: 1
Explanation: The smallest positive integer 1 is missing.

 
Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1



```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        
        # Step 1: Place each number in its right place if possible
        for i in range(n):
            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
                # Swap nums[i] with nums[nums[i] - 1]
                correct_index = nums[i] - 1
                nums[i], nums[correct_index] = nums[correct_index], nums[i]
        
        # Step 2: Find the first index where the number is not i + 1
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        
        # Step 3: If all numbers are in the correct place, return n + 1
        return n + 1
```

This solution works as follows:

1. **Placement Loop**: We iterate through the array and try to place each number in its "correct" position if it is within the range [1, n]. This is done by swapping the number with the number at its target position. We continue swapping until the current number is either out of the range [1, n] or already in the correct position.

2. **Identification Loop**: After the placement loop, we iterate through the array again to find the first position `i` where `nums[i]` is not `i + 1`. This `i + 1` is the smallest missing positive integer.

3. **Return n + 1**: If all positions from 1 to n are filled correctly, it means all numbers from 1 to n are present in the array, so the smallest missing positive integer is `n + 1`.

This approach ensures an O(n) time complexity and O(1) space complexity, as required by the problem constraints.

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
 
Example 1:


Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.

Example 2:

Input: height = [4,2,0,3,2,5]
Output: 9

 
Constraints:

n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105



```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0

        n = len(height)
        left_max = [0] * n
        right_max = [0] * n

        # Fill left_max array
        left_max[0] = height[0]
        for i in range(1, n):
            left_max[i] = max(left_max[i - 1], height[i])

        # Fill right_max array
        right_max[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            right_max[i] = max(right_max[i + 1], height[i])

        # Calculate trapped water using the min of left_max and right_max
        water_trapped = 0
        for i in range(n):
            water_trapped += min(left_max[i], right_max[i]) - height[i]

        return water_trapped
```

This solution uses dynamic programming to precompute the maximum heights to the left and right of each bar in the elevation map. It then calculates the trapped water at each position by taking the difference between the minimum of the left and right maximum heights and the current bar's height. This approach ensures that the solution runs in O(n) time complexity, which is efficient given the problem constraints.

Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.
 
Example 1:
Input: num1 = "2", num2 = "3"
Output: "6"
Example 2:
Input: num1 = "123", num2 = "456"
Output: "56088"

 
Constraints:

1 <= num1.length, num2.length <= 200
num1 and num2 consist of digits only.
Both num1 and num2 do not contain any leading zero, except the number 0 itself.



```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"
        
        # Initialize an array to store the multiplication results
        result = [0] * (len(num1) + len(num2))
        
        # Reverse both strings to facilitate multiplication from least significant digit
        num1 = num1[::-1]
        num2 = num2[::-1]
        
        # Perform multiplication digit by digit
        for i in range(len(num1)):
            for j in range(len(num2)):
                digit1 = ord(num1[i]) - ord('0')
                digit2 = ord(num2[j]) - ord('0')
                product = digit1 * digit2
                # Add the product to the corresponding position in the result array
                result[i + j] += product
                # Handle carry over
                result[i + j + 1] += result[i + j] // 10
                result[i + j] %= 10
        
        # Remove leading zeros and convert the result array back to a string
        while len(result) > 1 and result[-1] == 0:
            result.pop()
        
        # Convert the result array to a string
        return ''.join(map(str, result[::-1]))
```

Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).
 
Example 1:

Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".

Example 2:

Input: s = "aa", p = "*"
Output: true
Explanation: '*' matches any sequence.

Example 3:

Input: s = "cb", p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.

 
Constraints:

0 <= s.length, p.length <= 2000
s contains only lowercase English letters.
p contains only lowercase English letters, '?' or '*'.



```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # Initialize a DP table
        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
        
        # Empty pattern matches empty string
        dp[0][0] = True
        
        # Handle patterns with leading '*'
        for j in range(1, len(p) + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 1]
        
        # Fill the DP table
        for i in range(1, len(s) + 1):
            for j in range(1, len(p) + 1):
                if p[j - 1] == '*':
                    # '*' can match zero or more of the preceding element
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:
                    # '?' matches any single character or characters match
                    dp[i][j] = dp[i - 1][j - 1]
        
        return dp[len(s)][len(p)]
```

This solution uses dynamic programming to solve the wildcard matching problem. The `dp` table is used to store whether the substring `s[0:i]` matches the pattern `p[0:j]`. The table is filled based on the rules for `*`, `?`, and exact character matches. The final answer is found in `dp[len(s)][len(p)]`, which indicates whether the entire string `s` matches the entire pattern `p`.

You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].
Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:

0 <= j <= nums[i] and
i + j < n

Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].
 
Example 1:

Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:

Input: nums = [2,3,0,1,4]
Output: 2

 
Constraints:

1 <= nums.length <= 104
0 <= nums[i] <= 1000
It's guaranteed that you can reach nums[n - 1].



```python
from typing import List

class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return 0
        
        jumps = 0
        current_end = 0
        farthest = 0
        
        for i in range(len(nums) - 1):
            farthest = max(farthest, i + nums[i])
            
            if i == current_end:
                jumps += 1
                current_end = farthest
                
                if current_end >= len(nums) - 1:
                    break
        
        return jumps
```

This solution uses a greedy algorithm to find the minimum number of jumps. It maintains two pointers: `current_end` which represents the end of the current jump range, and `farthest` which represents the farthest point that can be reached from the current range. The algorithm iterates through the list, updating these pointers, and increments the jump count whenever the end of the current range is reached.

Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
 
Example 1:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
Example 2:
Input: nums = [0,1]
Output: [[0,1],[1,0]]
Example 3:
Input: nums = [1]
Output: [[1]]

 
Constraints:

1 <= nums.length <= 6
-10 <= nums[i] <= 10
All the integers of nums are unique.



```python
from itertools import permutations
from typing import List

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        return [list(p) for p in permutations(nums)]
```

This solution leverages Python's `itertools.permutations` to generate all possible permutations of the input list `nums`. Each permutation is converted from a tuple to a list and collected into a list of lists, which is then returned. This approach is efficient and concise given the constraints.

Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.
 
Example 1:

Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]

Example 2:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

 
Constraints:

1 <= nums.length <= 8
-10 <= nums[i] <= 10



```python
from typing import List

class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def backtrack(path, used, res):
            if len(path) == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if used[i]:
                    continue
                # If the current number is the same as the one before and the one before hasn't been used, skip
                if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                    continue
                used[i] = True
                path.append(nums[i])
                backtrack(path, used, res)
                used[i] = False
                path.pop()
        
        nums.sort()  # Sort the numbers to handle duplicates
        res = []
        used = [False] * len(nums)
        backtrack([], used, res)
        return res
```

This solution uses a backtracking approach to generate all unique permutations of the input list `nums`. The `used` list keeps track of which elements have been included in the current permutation path. The `backtrack` function is a recursive helper that builds permutations by adding one element at a time, ensuring duplicates are handled correctly by skipping over repeated elements unless the previous identical element has already been used in the current permutation.

You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
 
Example 1:


Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]

Example 2:


Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

 
Constraints:

n == matrix.length == matrix[i].length
1 <= n <= 20
-1000 <= matrix[i][j] <= 1000



```python
from typing import List

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        # Transpose the matrix
        for i in range(n):
            for j in range(i, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        
        # Reverse each row
        for i in range(n):
            matrix[i].reverse()
```

This solution first transposes the matrix, which means it swaps the element at position (i, j) with the element at position (j, i). After transposing, it reverses each row to achieve the 90-degree clockwise rotation. This approach modifies the matrix in-place without using any additional space for another matrix.

Given an array of strings strs, group the anagrams together. You can return the answer in any order.
 
Example 1:

Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
Explanation:

There is no string in strs that can be rearranged to form "bat".
The strings "nat" and "tan" are anagrams as they can be rearranged to form each other.
The strings "ate", "eat", and "tea" are anagrams as they can be rearranged to form each other.


Example 2:

Input: strs = [""]
Output: [[""]]

Example 3:

Input: strs = ["a"]
Output: [["a"]]

 
Constraints:

1 <= strs.length <= 104
0 <= strs[i].length <= 100
strs[i] consists of lowercase English letters.



```python
from collections import defaultdict
from typing import List

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # Create a dictionary to hold the groups of anagrams
        anagrams = defaultdict(list)
        
        # Iterate over each string in the input list
        for s in strs:
            # Sort the string and use the sorted tuple as a key
            sorted_str = tuple(sorted(s))
            # Append the original string to the list of its anagram group
            anagrams[sorted_str].append(s)
        
        # Return the values of the dictionary as a list of lists
        return list(anagrams.values())
```

This solution works by using a dictionary to group strings that are anagrams of each other. The key for each group is a tuple of the sorted characters of the string, which ensures that all anagrams have the same key. The function then returns the values of the dictionary, which are lists of anagrams.

Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
 
Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000

Example 2:

Input: x = 2.10000, n = 3
Output: 9.26100

Example 3:

Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25

 
Constraints:

-100.0 < x < 100.0
-231 <= n <= 231-1
n is an integer.
Either x is not zero or n > 0.
-104 <= xn <= 104



```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def qpow(a: float, n: int) -> float:
            ans = 1
            while n:
                if n & 1:
                    ans *= a
                a *= a
                n >>= 1
            return ans

        return qpow(x, n) if n >= 0 else 1 / qpow(x, -n)
```

The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.
Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.
 
Example 1:


Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above

Example 2:

Input: n = 1
Output: [["Q"]]

 
Constraints:

1 <= n <= 9



```python
from typing import List

class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def is_not_under_attack(row, col):
            return not (cols[col] + hills[row - col] + dales[row + col])
        
        def place_queen(row, col):
            queens.add((row, col))
            cols[col] = 1
            hills[row - col] = 1
            dales[row + col] = 1
        
        def remove_queen(row, col):
            queens.remove((row, col))
            cols[col] = 0
            hills[row - col] = 0
            dales[row + col] = 0
        
        def add_solution():
            solution = []
            for _, col in sorted(queens):
                solution.append('.' * col + 'Q' + '.' * (n - col - 1))
            output.append(solution)
        
        def backtrack(row = 0):
            for col in range(n):
                if is_not_under_attack(row, col):
                    place_queen(row, col)
                    if row + 1 == n:
                        add_solution()
                    else:
                        backtrack(row + 1)
                    remove_queen(row, col)
        
        cols = [0] * n
        hills = [0] * (2 * n - 1)  # "hill" diagonals
        dales = [0] * (2 * n - 1)  # "dale" diagonals
        queens = set()  # list of the queens positions
        output = []
        backtrack()
        return output
```

This code implements a backtracking algorithm to solve the n-queens problem. It uses sets and lists to keep track of columns and diagonals where queens cannot be placed. The `backtrack` function tries to place a queen in each column of the current row and recursively attempts to solve the rest of the board. If a solution is found, it is added to the output list. The `is_not_under_attack` function checks if a position is safe for a queen, while `place_queen` and `remove_queen` modify the board state accordingly.

The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.
Given an integer n, return the number of distinct solutions to the n-queens puzzle.
 
Example 1:


Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.

Example 2:

Input: n = 1
Output: 1

 
Constraints:

1 <= n <= 9



```python
class Solution:
    def totalNQueens(self, n: int) -> int:
        def is_not_under_attack(row, col):
            return not (cols[col] + hills[row - col] + dales[row + col])
        
        def place_queen(row, col):
            cols[col] = 1
            hills[row - col] = 1
            dales[row + col] = 1
        
        def remove_queen(row, col):
            cols[col] = 0
            hills[row - col] = 0
            dales[row + col] = 0
        
        def backtrack(row = 0, count = 0):
            for col in range(n):
                if is_not_under_attack(row, col):
                    place_queen(row, col)
                    if row + 1 == n:
                        count += 1
                    else:
                        count = backtrack(row + 1, count)
                    remove_queen(row, col)
            return count
        
        cols = [0] * n
        hills = [0] * (2 * n - 1)  # "hill" diagonals
        dales = [0] * (2 * n - 1)  # "dale" diagonals
        
        return backtrack()
```

This solution uses backtracking to explore all possible placements of queens on the board while ensuring no two queens threaten each other. The `cols`, `hills`, and `dales` arrays keep track of columns and diagonals that are under attack. The `backtrack` function attempts to place a queen in each column of the current row and recursively attempts to place queens in subsequent rows. If a solution is found (when all queens are placed), the count is incremented.

Given an integer array nums, find the subarray with the largest sum, and return its sum.
 
Example 1:

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Example 2:

Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.

Example 3:

Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

 
Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104

 
Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.


```python
from typing import List

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # Initialize variables to store the maximum sum and the current sum
        max_sum = current_sum = nums[0]
        
        # Iterate through the array starting from the second element
        for num in nums[1:]:
            # Update the current sum to be the maximum of the current number or the current sum plus the current number
            current_sum = max(num, current_sum + num)
            # Update the maximum sum if the current sum is greater
            max_sum = max(max_sum, current_sum)
        
        return max_sum
```

This solution uses Kadane's Algorithm to find the maximum sum subarray in O(n) time complexity. It iterates through the list, maintaining a running sum of the current subarray and updating the maximum sum found so far.

Given an m x n matrix, return all elements of the matrix in spiral order.
 
Example 1:


Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]

Example 2:


Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]

 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 10
-100 <= matrix[i][j] <= 100



```python
from typing import List

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return []
        
        result = []
        top, bottom = 0, len(matrix) - 1
        left, right = 0, len(matrix[0]) - 1
        
        while top <= bottom and left <= right:
            # Traverse from left to right along the top row
            for i in range(left, right + 1):
                result.append(matrix[top][i])
            top += 1
            
            # Traverse from top to bottom along the right column
            for i in range(top, bottom + 1):
                result.append(matrix[i][right])
            right -= 1
            
            if top <= bottom:
                # Traverse from right to left along the bottom row
                for i in range(right, left - 1, -1):
                    result.append(matrix[bottom][i])
                bottom -= 1
            
            if left <= right:
                # Traverse from bottom to top along the left column
                for i in range(bottom, top - 1, -1):
                    result.append(matrix[i][left])
                left += 1
        
        return result
```

This solution correctly implements the logic to traverse a matrix in spiral order. It handles the constraints and examples provided in the question. The solution uses four boundaries (`top`, `bottom`, `left`, `right`) to keep track of the current layer of the spiral and adjusts these boundaries as it moves inward.

You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
 
Example 1:

Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:

Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.

 
Constraints:

1 <= nums.length <= 104
0 <= nums[i] <= 105



```python
from typing import List

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        # Initialize the farthest index we can reach
        farthest = 0
        
        # Iterate through the array
        for i in range(len(nums)):
            # If the current index is greater than the farthest we can reach, return False
            if i > farthest:
                return False
            # Update the farthest index we can reach
            farthest = max(farthest, i + nums[i])
            # If the farthest index is or exceeds the last index, return True
            if farthest >= len(nums) - 1:
                return True
        
        # If we finish the loop without reaching the last index, return False
        return False
```

This solution iterates through the list, updating the farthest index that can be reached. If at any point the current index is greater than the farthest reachable index, it returns `False`. If the farthest reachable index is greater than or equal to the last index, it returns `True`. This approach ensures that we efficiently determine whether the last index can be reached.

Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
 
Example 1:

Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

Example 2:

Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.

 
Constraints:

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104



```python
from typing import List

class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # Sort the intervals based on the starting point
        intervals.sort(key=lambda x: x[0])
        
        merged = []
        for interval in intervals:
            # If merged list is empty or current interval does not overlap with the last merged interval
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                # There is an overlap, so merge the current interval with the last merged interval
                merged[-1][1] = max(merged[-1][1], interval[1])
        
        return merged
```

This solution first sorts the intervals by their starting points. Then, it iterates through the sorted intervals, merging them if they overlap. If the current interval does not overlap with the last interval in the `merged` list, it is added to the `merged` list. If there is an overlap, the end of the last interval in the `merged` list is updated to be the maximum of its current end and the end of the current interval. This ensures that all overlapping intervals are merged into a single interval.

You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.
Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).
Return intervals after the insertion.
Note that you don't need to modify intervals in-place. You can make a new array and return it.
 
Example 1:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Example 2:

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].

 
Constraints:

0 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 105
intervals is sorted by starti in ascending order.
newInterval.length == 2
0 <= start <= end <= 105



```python
from typing import List

class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals:
            return [newInterval]
        
        merged = []
        i = 0
        n = len(intervals)
        
        # Add all intervals before the newInterval starts
        while i < n and intervals[i][1] < newInterval[0]:
            merged.append(intervals[i])
            i += 1
        
        # Merge all overlapping intervals
        while i < n and intervals[i][0] <= newInterval[1]:
            newInterval[0] = min(newInterval[0], intervals[i][0])
            newInterval[1] = max(newInterval[1], intervals[i][1])
            i += 1
        
        # Add the merged newInterval
        merged.append(newInterval)
        
        # Add all remaining intervals
        while i < n:
            merged.append(intervals[i])
            i += 1
        
        return merged
```

This solution correctly inserts and merges the new interval into the list of intervals while maintaining the sorted order and non-overlapping property. It iterates through the list of intervals once, making it efficient with a time complexity of O(n).

Given a string s consisting of words and spaces, return the length of the last word in the string.
A word is a maximal substring consisting of non-space characters only.
 
Example 1:

Input: s = "Hello World"
Output: 5
Explanation: The last word is "World" with length 5.

Example 2:

Input: s = "   fly me   to   the moon  "
Output: 4
Explanation: The last word is "moon" with length 4.

Example 3:

Input: s = "luffy is still joyboy"
Output: 6
Explanation: The last word is "joyboy" with length 6.

 
Constraints:

1 <= s.length <= 104
s consists of only English letters and spaces ' '.
There will be at least one word in s.



```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        # Strip any leading or trailing spaces from the string
        s = s.strip()
        # Split the string into words
        words = s.split(' ')
        # Return the length of the last word
        return len(words[-1])
```

This solution first removes any leading or trailing spaces from the input string `s` using `strip()`. It then splits the string into a list of words using `split(' ')`. Finally, it returns the length of the last word in the list, which is accessed using `words[-1]`.

Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
 
Example 1:


Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]

Example 2:

Input: n = 1
Output: [[1]]

 
Constraints:

1 <= n <= 20



```python
from typing import List

class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        # Initialize an n x n matrix with zeros
        matrix = [[0] * n for _ in range(n)]
        
        # Define the initial boundaries of the spiral
        top, bottom = 0, n - 1
        left, right = 0, n - 1
        
        # Start filling the matrix with numbers from 1 to n^2
        num = 1
        while top <= bottom and left <= right:
            # Fill the top row
            for i in range(left, right + 1):
                matrix[top][i] = num
                num += 1
            top += 1
            
            # Fill the right column
            for i in range(top, bottom + 1):
                matrix[i][right] = num
                num += 1
            right -= 1
            
            # Fill the bottom row
            for i in range(right, left - 1, -1):
                matrix[bottom][i] = num
                num += 1
            bottom -= 1
            
            # Fill the left column
            for i in range(bottom, top - 1, -1):
                matrix[i][left] = num
                num += 1
            left += 1
        
        return matrix
```

This solution initializes an `n x n` matrix with zeros and then fills it in a spiral order using four loops to handle the top row, right column, bottom row, and left column respectively. The boundaries (`top`, `bottom`, `left`, `right`) are adjusted after each loop to move inward in the spiral pattern. The process continues until all cells are filled with numbers from 1 to `n^2`.

The set [1, 2, 3, ..., n] contains a total of n! unique permutations.
By listing and labeling all of the permutations in order, we get the following sequence for n = 3:

"123"
"132"
"213"
"231"
"312"
"321"

Given n and k, return the kth permutation sequence.
 
Example 1:
Input: n = 3, k = 3
Output: "213"
Example 2:
Input: n = 4, k = 9
Output: "2314"
Example 3:
Input: n = 3, k = 1
Output: "123"

 
Constraints:

1 <= n <= 9
1 <= k <= n!



```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        ans = []
        vis = [False] * (n + 1)
        for i in range(n):
            fact = 1
            for j in range(1, n - i):
                fact *= j
            for j in range(1, n + 1):
                if not vis[j]:
                    if k > fact:
                        k -= fact
                    else:
                        ans.append(str(j))
                        vis[j] = True
                        break
        return ''.join(ans)
```

Given the head of a linked list, rotate the list to the right by k places.
 
Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]

Example 2:


Input: head = [0,1,2], k = 4
Output: [2,0,1]

 
Constraints:

The number of nodes in the list is in the range [0, 500].
-100 <= Node.val <= 100
0 <= k <= 2 * 109



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head or not head.next or k == 0:
            return head
        
        # Find the length of the list
        length = 1
        current = head
        while current.next:
            current = current.next
            length += 1
        
        # Connect the tail with head to make it a circular list
        current.next = head
        
        # Find the new tail: (length - k % length) - 1
        k = k % length
        steps_to_new_tail = length - k - 1
        new_tail = head
        for _ in range(steps_to_new_tail):
            new_tail = new_tail.next
        
        # Break the circular list and set the new head
        new_head = new_tail.next
        new_tail.next = None
        
        return new_head
```

This code first checks for edge cases where the list is empty, has only one node, or `k` is zero. It then calculates the length of the list and makes it circular by connecting the tail to the head. The new tail is found by moving `length - k % length - 1` steps from the head. Finally, the list is broken at the new tail, and the new head is set.

There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 109.
 
Example 1:


Input: m = 3, n = 7
Output: 28

Example 2:

Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down

 
Constraints:

1 <= m, n <= 100



```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # Create a 2D array to store the number of ways to reach each cell
        dp = [[0] * n for _ in range(m)]
        
        # Initialize the first row and first column to 1
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        
        # Fill the dp array
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        
        # The bottom-right corner will have the number of unique paths
        return dp[m - 1][n - 1]
```

This solution uses dynamic programming to solve the problem. We create a 2D list `dp` where `dp[i][j]` represents the number of unique paths to reach cell `(i, j)`. We initialize the first row and first column to 1 because there is only one way to reach any cell in the first row (by moving right) and any cell in the first column (by moving down). Then, for each cell `(i, j)`, the number of ways to reach it is the sum of the number of ways to reach the cell directly above it `(i-1, j)` and the cell directly to the left of it `(i, j-1)`. Finally, the value at `dp[m-1][n-1]` gives the number of unique paths to reach the bottom-right corner of the grid.

You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.
Return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The testcases are generated so that the answer will be less than or equal to 2 * 109.
 
Example 1:


Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right

Example 2:


Input: obstacleGrid = [[0,1],[0,0]]
Output: 1

 
Constraints:

m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] is 0 or 1.



```python
from typing import List

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or obstacleGrid[0][0] == 1:
            return 0
        
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0] * n for _ in range(m)]
        
        # Starting point
        dp[0][0] = 1
        
        # Fill the first row
        for j in range(1, n):
            if obstacleGrid[0][j] == 0:
                dp[0][j] = dp[0][j - 1]
        
        # Fill the first column
        for i in range(1, m):
            if obstacleGrid[i][0] == 0:
                dp[i][0] = dp[i - 1][0]
        
        # Fill the rest of the dp table
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        
        return dp[m - 1][n - 1]
```

This solution uses dynamic programming to count the number of unique paths from the top-left to the bottom-right corner of the grid, avoiding obstacles. The `dp` table is used to store the number of ways to reach each cell. The first row and first column are initialized separately to handle the boundary conditions. For each cell, if it is not an obstacle, the number of ways to reach it is the sum of the ways to reach the cell directly above it and the cell directly to the left of it.

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
 
Example 1:


Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.

Example 2:

Input: grid = [[1,2,3],[4,5,6]]
Output: 12

 
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= grid[i][j] <= 200



```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        
        # Initialize the first cell
        for i in range(1, m):
            grid[i][0] += grid[i - 1][0]
        
        for j in range(1, n):
            grid[0][j] += grid[0][j - 1]
        
        # Fill up the rest of the grid
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
        
        return grid[m - 1][n - 1]
```

This solution uses dynamic programming to solve the problem. It iterates through the grid and updates each cell with the minimum path sum to reach that cell from the top-left corner, considering only moves to the right or down. The final answer is found in the bottom-right cell of the grid.

Given a string s, return whether s is a valid number.

For example, all the following are valid numbers: "2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789", while the following are not valid numbers: "abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53".
Formally, a valid number is defined using one of the following definitions:

An integer number followed by an optional exponent.
A decimal number followed by an optional exponent.

An integer number is defined with an optional sign '-' or '+' followed by digits.
A decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions:

Digits followed by a dot '.'.
Digits followed by a dot '.' followed by digits.
A dot '.' followed by digits.

An exponent is defined with an exponent notation 'e' or 'E' followed by an integer number.
The digits are defined as one or more digits.
 
Example 1:

Input: s = "0"
Output: true

Example 2:

Input: s = "e"
Output: false

Example 3:

Input: s = "."
Output: false

 
Constraints:

1 <= s.length <= 20
s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.



```python
class Solution:
    def isNumber(self, s: str) -> bool:
        def scan_integer(s, idx):
            if idx < len(s) and (s[idx] == '+' or s[idx] == '-'):
                idx += 1
            return scan_unsigned_integer(s, idx)
        
        def scan_unsigned_integer(s, idx):
            before = idx
            while idx < len(s) and '0' <= s[idx] <= '9':
                idx += 1
            return idx > before, idx
        
        if not s:
            return False
        
        idx = 0
        is_numeric, idx = scan_integer(s, idx)
        
        if idx < len(s) and s[idx] == '.':
            idx += 1
            has_fraction, idx = scan_unsigned_integer(s, idx)
            is_numeric = is_numeric or has_fraction
        
        if idx < len(s) and (s[idx] == 'e' or s[idx] == 'E'):
            idx += 1
            has_exponent, idx = scan_integer(s, idx)
            is_numeric = is_numeric and has_exponent
        
        return is_numeric and idx == len(s)
```

This solution implements a state machine to determine if the given string is a valid number according to the specified rules. It checks for optional leading signs, digits, an optional decimal point, optional fractional digits, and an optional exponent part. The function returns `True` if the entire string is parsed as a valid number and `False` otherwise.

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.
Increment the large integer by one and return the resulting array of digits.
 
Example 1:

Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].

Example 2:

Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].

Example 3:

Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].

 
Constraints:

1 <= digits.length <= 100
0 <= digits[i] <= 9
digits does not contain any leading 0's.



```python
from typing import List

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        # Start from the last digit
        for i in range(len(digits) - 1, -1, -1):
            # If the digit is less than 9, simply add one and return the list
            if digits[i] < 9:
                digits[i] += 1
                return digits
            # If the digit is 9, set it to 0 and continue to the next digit
            digits[i] = 0
        
        # If all digits were 9, we need to add a leading 1
        return [1] + digits
```

This solution iterates through the list of digits from the last to the first. If it finds a digit that is less than 9, it increments that digit and returns the list. If a digit is 9, it sets it to 0 and continues to the next digit. If all digits are 9, it adds a leading 1 to the list. This approach handles the carry-over correctly and efficiently.

Given two binary strings a and b, return their sum as a binary string.
 
Example 1:
Input: a = "11", b = "1"
Output: "100"
Example 2:
Input: a = "1010", b = "1011"
Output: "10101"

 
Constraints:

1 <= a.length, b.length <= 104
a and b consist only of '0' or '1' characters.
Each string does not contain leading zeros except for the zero itself.



```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        # Convert binary strings to integers, add them, and then convert the result back to a binary string
        return bin(int(a, 2) + int(b, 2))[2:]
```

This solution leverages Python's built-in functions to convert the binary strings to integers, perform the addition, and then convert the result back to a binary string. The `bin()` function returns a binary string prefixed with '0b', so we slice off the first two characters to get the final result.

Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.
You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.
Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.
For the last line of text, it should be left-justified, and no extra space is inserted between words.
Note:

A word is defined as a character sequence consisting of non-space characters only.
Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
The input array words contains at least one word.

 
Example 1:

Input: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
Example 2:

Input: words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
Explanation: Note that the last line is "shall be    " instead of "shall     be", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified because it contains only one word.
Example 3:

Input: words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20
Output:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
 
Constraints:

1 <= words.length <= 300
1 <= words[i].length <= 20
words[i] consists of only English letters and symbols.
1 <= maxWidth <= 100
words[i].length <= maxWidth



```python
class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        ans = []
        i, n = 0, len(words)
        while i < n:
            t = []
            cnt = len(words[i])
            t.append(words[i])
            i += 1
            while i < n and cnt + 1 + len(words[i]) <= maxWidth:
                cnt += 1 + len(words[i])
                t.append(words[i])
                i += 1
            if i == n or len(t) == 1:
                left = ' '.join(t)
                right = ' ' * (maxWidth - len(left))
                ans.append(left + right)
                continue
            space_width = maxWidth - (cnt - len(t) + 1)
            w, m = divmod(space_width, len(t) - 1)
            row = []
            for j, s in enumerate(t[:-1]):
                row.append(s)
                row.append(' ' * (w + (1 if j < m else 0)))
            row.append(t[-1])
            ans.append(''.join(row))
        return ans
```

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

 
Example 1:

Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.

Example 2:

Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.

 
Constraints:

0 <= x <= 231 - 1



```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        
        left, right = 1, x
        while left <= right:
            mid = (left + right) // 2
            mid_squared = mid * mid
            
            if mid_squared == x:
                return mid
            elif mid_squared < x:
                left = mid + 1
            else:
                right = mid - 1
        
        return right
```

This solution uses a binary search approach to find the square root of a non-negative integer `x` rounded down to the nearest integer. The binary search narrows down the possible values for the square root by comparing the square of the midpoint of the current search range to `x`. If the square of the midpoint is equal to `x`, the midpoint is the square root. If it is less than `x`, the search continues in the upper half of the range; otherwise, it continues in the lower half. The loop terminates when the search range is invalid, and the last valid midpoint (which is the greatest integer whose square is less than or equal to `x`) is returned.

You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 
Example 1:

Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Example 2:

Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

 
Constraints:

1 <= n <= 45



```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        
        # Initialize the base cases
        a, b = 1, 2
        
        # Compute the number of ways for each step from 3 to n
        for i in range(3, n + 1):
            a, b = b, a + b
        
        return b
```

This solution uses dynamic programming to solve the problem efficiently. It initializes the base cases for 1 and 2 steps, then iteratively calculates the number of ways to climb each subsequent step up to `n` using the relation that the number of ways to reach step `i` is the sum of the ways to reach step `i-1` and step `i-2`. This approach ensures that the solution is computed in linear time, O(n), and uses constant space, O(1).

You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.
The rules of a Unix-style file system are as follows:

A single period '.' represents the current directory.
A double period '..' represents the previous/parent directory.
Multiple consecutive slashes such as '//' and '///' are treated as a single slash '/'.
Any sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, '...' and '....' are valid directory or file names.

The simplified canonical path should follow these rules:

The path must start with a single slash '/'.
Directories within the path must be separated by exactly one slash '/'.
The path must not end with a slash '/', unless it is the root directory.
The path must not have any single or double periods ('.' and '..') used to denote current or parent directories.

Return the simplified canonical path.
 
Example 1:

Input: path = "/home/"
Output: "/home"
Explanation:
The trailing slash should be removed.

Example 2:

Input: path = "/home//foo/"
Output: "/home/foo"
Explanation:
Multiple consecutive slashes are replaced by a single one.

Example 3:

Input: path = "/home/user/Documents/../Pictures"
Output: "/home/user/Pictures"
Explanation:
A double period ".." refers to the directory up a level (the parent directory).

Example 4:

Input: path = "/../"
Output: "/"
Explanation:
Going one level up from the root directory is not possible.

Example 5:

Input: path = "/.../a/../b/c/../d/./"
Output: "/.../b/d"
Explanation:
"..." is a valid name for a directory in this problem.

 
Constraints:

1 <= path.length <= 3000
path consists of English letters, digits, period '.', slash '/' or '_'.
path is a valid absolute Unix path.



```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        # Split the path by '/'
        components = path.split('/')
        stack = []
        
        for component in components:
            if component == '' or component == '.':
                # Ignore empty components and current directory marker '.'
                continue
            elif component == '..':
                # Pop the last directory if possible for parent directory marker '..'
                if stack:
                    stack.pop()
            else:
                # Add valid directory or file name to the stack
                stack.append(component)
        
        # Join the stack to form the simplified path
        simplified_path = '/' + '/'.join(stack)
        return simplified_path
```

This solution processes the path by splitting it into components, ignoring unnecessary parts like `.` and `//`, and properly handling `..` to navigate up a directory level. The result is a stack of valid path components which are then joined to form the simplified canonical path.

Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.
You have the following three operations permitted on a word:

Insert a character
Delete a character
Replace a character

 
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

 
Constraints:

0 <= word1.length, word2.length <= 500
word1 and word2 consist of lowercase English letters.



```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        
        # Create a 2D array to store the minimum edit distances
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Initialize the dp array
        for i in range(m + 1):
            dp[i][0] = i  # Deleting all characters from word1 to match empty word2
        for j in range(n + 1):
            dp[0][j] = j  # Inserting all characters from word2 to match empty word1
        
        # Fill the dp array
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]  # No operation needed if characters match
                else:
                    dp[i][j] = 1 + min(dp[i - 1][j],    # Delete from word1
                                       dp[i][j - 1],    # Insert into word1
                                       dp[i - 1][j - 1]) # Replace in word1
        
        return dp[m][n]
```

This solution uses dynamic programming to compute the minimum edit distance between two strings, `word1` and `word2`. The `dp` array is used to store the minimum edit distances for substrings of `word1` and `word2`. The final answer is found in `dp[m][n]`, which represents the minimum edit distance between the full strings `word1` and `word2`.

Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
You must do it in place.
 
Example 1:


Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]

Example 2:


Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]

 
Constraints:

m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-231 <= matrix[i][j] <= 231 - 1

 
Follow up:

A straightforward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?



To solve this problem with constant space complexity, we can use the first row and the first column of the matrix as markers to indicate which rows and columns need to be set to zero. Here's the step-by-step approach:

1. Use two boolean variables to track if the first row and the first column need to be set to zero.
2. Iterate through the matrix starting from the second row and the second column. If an element is zero, set the corresponding element in the first row and the first column to zero.
3. Iterate through the matrix again starting from the second row and the second column. If the corresponding element in the first row or the first column is zero, set the element to zero.
4. Use the boolean variables to set the first row and the first column to zero if needed.

Here's the implementation:

```python
from typing import List

class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        if not matrix or not matrix[0]:
            return
        
        m, n = len(matrix), len(matrix[0])
        first_row_has_zero = any(matrix[0][j] == 0 for j in range(n))
        first_col_has_zero = any(matrix[i][0] == 0 for i in range(m))
        
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] == 0:
                    matrix[i][0] = 0
                    matrix[0][j] = 0
        
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0
        
        if first_row_has_zero:
            for j in range(n):
                matrix[0][j] = 0
        
        if first_col_has_zero:
            for i in range(m):
                matrix[i][0] = 0
```

This solution ensures that the matrix is modified in-place with a space complexity of O(1).

You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.

Given an integer target, return true if target is in matrix or false otherwise.
You must write a solution in O(log(m * n)) time complexity.
 
Example 1:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true

Example 2:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false

 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104



```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        left, right = 0, m * n - 1
        while left < right:
            mid = (left + right) >> 1
            x, y = divmod(mid, n)
            if matrix[x][y] >= target:
                right = mid
            else:
                left = mid + 1
        return matrix[left // n][left % n] == target
```

This solution treats the 2D matrix as a 1D sorted array and performs a binary search to find the target, achieving the required O(log(m * n)) time complexity.

Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library's sort function.
 
Example 1:

Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

Example 2:

Input: nums = [2,0,1]
Output: [0,1,2]

 
Constraints:

n == nums.length
1 <= n <= 300
nums[i] is either 0, 1, or 2.

 
Follow up: Could you come up with a one-pass algorithm using only constant extra space?


```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # Initialize pointers for the current element, the boundary of 0s, and the boundary of 2s
        low, mid, high = 0, 0, len(nums) - 1
        
        # One-pass algorithm to sort the array in-place
        while mid <= high:
            if nums[mid] == 0:
                # Swap the current element with the element at the low boundary
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                # Move to the next element
                mid += 1
            else:
                # Swap the current element with the element at the high boundary
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1
```

This solution implements the Dutch National Flag problem algorithm, which sorts the array in a single pass with constant extra space. The `low` pointer keeps track of the boundary for 0s, the `mid` pointer is the current element being examined, and the `high` pointer keeps track of the boundary for 2s.

Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".
The testcases will be generated such that the answer is unique.
 
Example 1:

Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.

Example 2:

Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.

Example 3:

Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.

 
Constraints:

m == s.length
n == t.length
1 <= m, n <= 105
s and t consist of uppercase and lowercase English letters.

 
Follow up: Could you find an algorithm that runs in O(m + n) time?


```python
from collections import Counter

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not s or not t:
            return ""
        
        # Count the frequency of each character in t
        dict_t = Counter(t)
        
        # Number of unique characters in t that need to be in the window
        required = len(dict_t)
        
        # Left and right pointer
        l, r = 0, 0
        
        # Form a dictionary to keep a count of all the unique characters in the current window
        formed = 0
        
        # Dictionary which keeps a count of all the unique characters in the current window
        window_counts = {}
        
        # To store the result
        ans = float("inf"), None, None
        
        while r < len(s):
            # Add one character from the right to the window
            character = s[r]
            window_counts[character] = window_counts.get(character, 0) + 1
            
            # If the frequency of the current character added equals to the desired count in t then increment the formed count by 1.
            if character in dict_t and window_counts[character] == dict_t[character]:
                formed += 1
            
            # Try and contract the window until it ceases to be 'desirable'
            while l <= r and formed == required:
                character = s[l]
                
                # Save the smallest window until now
                if r - l + 1 < ans[0]:
                    ans = (r - l + 1, l, r)
                
                # The character at the position pointed by the `left` pointer is no longer a part of the window
                window_counts[character] -= 1
                if character in dict_t and window_counts[character] < dict_t[character]:
                    formed -= 1
                
                # Move the left pointer ahead
                l += 1    
            
            # Keep expanding the window    
            r += 1    
        
        return "" if ans[0] == float("inf") else s[ans[1] : ans[2] + 1]
```

This solution implements the sliding window technique to find the minimum window substring in O(m + n) time complexity, where m is the length of string `s` and n is the length of string `t`. The solution uses two pointers (`l` and `r`), a hash map to count characters, and maintains a window that contains all characters of `t` with required frequency.

Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].
You may return the answer in any order.
 
Example 1:

Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.

Example 2:

Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.

 
Constraints:

1 <= n <= 20
1 <= k <= n



```python
from typing import List

class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(start, path):
            # If the current combination is of length k, add it to the result
            if len(path) == k:
                result.append(path[:])
                return
            # Iterate from the current start to n
            for i in range(start, n + 1):
                # Include i in the current combination
                path.append(i)
                # Move on to the next element
                backtrack(i + 1, path)
                # Backtrack, remove i from the current combination
                path.pop()
        
        result = []
        backtrack(1, [])
        return result
```

This solution uses a backtracking approach to generate all possible combinations of `k` numbers chosen from the range `[1, n]`. The `backtrack` function is a recursive helper function that builds combinations by including each number in the range and then exploring further combinations from the next number. The function uses a `path` list to store the current combination and adds it to the `result` list when its length reaches `k`. Backtracking is achieved by removing the last added number from the `path` before exploring other possibilities.

Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
 
Example 1:

Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

Example 2:

Input: nums = [0]
Output: [[],[0]]

 
Constraints:

1 <= nums.length <= 10
-10 <= nums[i] <= 10
All the numbers of nums are unique.



```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        # Base case: the power set of an empty set is a set containing the empty set
        if not nums:
            return [[]]
        
        # Recursive case: get the subsets of the rest of the numbers
        rest_subsets = self.subsets(nums[1:])
        
        # For each subset, add the current number to create new subsets
        with_current = [[nums[0]] + subset for subset in rest_subsets]
        
        # Return the combination of subsets with and without the current number
        return rest_subsets + with_current
```

Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
 
Example 1:


Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true

Example 2:


Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true

Example 3:


Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false

 
Constraints:

m == board.length
n = board[i].length
1 <= m, n <= 6
1 <= word.length <= 15
board and word consists of only lowercase and uppercase English letters.

 
Follow up: Could you use search pruning to make your solution faster with a larger board?


```python
from typing import List

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        if not board or not board[0]:
            return False
        
        m, n = len(board), len(board[0])
        
        def dfs(x, y, index):
            if index == len(word):
                return True
            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != word[index]:
                return False
            
            # Mark the cell as visited
            temp, board[x][y] = board[x][y], '#'
            
            # Explore neighbors
            found = (dfs(x + 1, y, index + 1) or
                     dfs(x - 1, y, index + 1) or
                     dfs(x, y + 1, index + 1) or
                     dfs(x, y - 1, index + 1))
            
            # Unmark the cell
            board[x][y] = temp
            
            return found
        
        for i in range(m):
            for j in range(n):
                if dfs(i, j, 0):
                    return True
        
        return False
```

This solution uses a depth-first search (DFS) approach to explore all possible paths in the grid that could form the given word. The function `dfs` is a recursive helper that checks if the word can be constructed starting from a given cell `(x, y)` in the grid. The cell is marked as visited by temporarily setting it to `#` to avoid revisiting it in the same path. After exploring all possible paths from a cell, it is unmarked to allow other paths to use it. The main function iterates over all cells in the grid and starts a DFS from each cell to check if the word can be formed.

Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.
Return k after placing the final result in the first k slots of nums.
Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.
Custom Judge:
The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}

If all assertions pass, then your solution will be accepted.
 
Example 1:

Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Example 2:

Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

 
Constraints:

1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums is sorted in non-decreasing order.



```python
from typing import List

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        
        k = 2  # Initialize the position to place the next valid element
        for i in range(2, len(nums)):
            if nums[i] != nums[k - 2]:
                nums[k] = nums[i]
                k += 1
        
        return k
```

This solution uses a two-pointer approach to keep track of the position where the next valid element should be placed. It iterates through the list starting from the third element, and only places an element at the `k`-th position if it is different from the element at `k-2`. This ensures that no more than two duplicates of any element are kept in the list. The function returns `k`, which is the length of the list with duplicates removed according to the problem's requirements.

There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).
Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].
Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.
You must decrease the overall operation steps as much as possible.
 
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false

 
Constraints:

1 <= nums.length <= 5000
-104 <= nums[i] <= 104
nums is guaranteed to be rotated at some pivot.
-104 <= target <= 104

 
Follow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?


```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        n = len(nums)
        l, r = 0, n - 1
        while l < r:
            mid = (l + r) >> 1
            if nums[mid] > nums[r]:
                if nums[l] <= target <= nums[mid]:
                    r = mid
                else:
                    l = mid + 1
            elif nums[mid] < nums[r]:
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid
            else:
                r -= 1
        return nums[l] == target
```

This solution implements a modified binary search algorithm to handle the rotated sorted array with possible duplicates. The key challenge is to handle the case where `nums[mid] == nums[r]` by reducing the search space from the right side. This ensures that the algorithm maintains a logarithmic time complexity in the average case, though it may degrade to O(n) in the worst case due to duplicates.

Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.
 
Example 1:


Input: head = [1,2,3,3,4,4,5]
Output: [1,2,5]

Example 2:


Input: head = [1,1,1,2,3]
Output: [2,3]

 
Constraints:

The number of nodes in the list is in the range [0, 300].
-100 <= Node.val <= 100
The list is guaranteed to be sorted in ascending order.



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Create a dummy node that points to the head of the list
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        
        while current.next and current.next.next:
            # If the next node and the node after that have the same value
            if current.next.val == current.next.next.val:
                # Find the last node that has the same value as the current duplicate
                duplicate_val = current.next.val
                while current.next and current.next.val == duplicate_val:
                    current.next = current.next.next
            else:
                # Move to the next node if no duplicate is found
                current = current.next
        
        # Return the list starting from the node after the dummy
        return dummy.next
```

Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.
 
Example 1:


Input: head = [1,1,2]
Output: [1,2]

Example 2:


Input: head = [1,1,2,3,3]
Output: [1,2,3]

 
Constraints:

The number of nodes in the list is in the range [0, 300].
-100 <= Node.val <= 100
The list is guaranteed to be sorted in ascending order.



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        current = head
        while current and current.next:
            if current.val == current.next.val:
                current.next = current.next.next
            else:
                current = current.next
        return head
```

This solution iterates through the linked list, and whenever it finds two consecutive nodes with the same value, it skips the next node by adjusting the `next` pointer of the current node. This effectively removes duplicates while maintaining the sorted order of the list.

Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
 
Example 1:


Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.

Example 2:


Input: heights = [2,4]
Output: 4

 
Constraints:

1 <= heights.length <= 105
0 <= heights[i] <= 104



To solve the problem of finding the largest rectangle in a histogram, we can use a stack-based approach. This method efficiently calculates the largest rectangle area in O(n) time complexity, which is optimal given the constraints.

Here's the detailed plan:
1. Use a stack to keep track of the indices of the histogram bars.
2. Iterate through each bar of the histogram.
3. For each bar, if the stack is not empty and the current bar's height is less than the height of the bar at the index stored at the top of the stack, it means we have found the boundaries for the rectangle with the height of the bar at the top of the stack.
4. Pop the stack and calculate the area of the rectangle using the popped height and the width determined by the current index and the new top of the stack.
5. Continue this process until the stack is empty or the current bar's height is not less than the height of the bar at the index stored at the top of the stack.
6. Push the current index onto the stack.
7. After iterating through all the bars, handle any remaining bars in the stack by calculating the rectangle areas similarly.
8. Return the maximum area found.

Here is the implementation of the above plan:

```python
from typing import List

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0
        index = 0
        
        while index < len(heights):
            # If this bar is higher than the bar that was previous bar, push it to stack
            if not stack or heights[index] >= heights[stack[-1]]:
                stack.append(index)
                index += 1
            else:
                # Calculate area of all bars with height stack top. The bar at stack top is the smallest (or minimum height) bar. 'index' is 'right index' for the top and element before top in stack is 'left index'
                top_of_stack = stack.pop()
                # Calculate the area with heights[top_of_stack] stack as smallest (or minimum height) bar. 'index' is 'right index' for the top and element before top in stack is 'left index'
                area = (heights[top_of_stack] * 
                       ((index - stack[-1] - 1) if stack else index))
                # Update max area, if needed
                max_area = max(max_area, area)
        
        # Now pop the remaining bars from stack and calculate area with every popped bar as the smallest bar
        while stack:
            top_of_stack = stack.pop()
            area = (heights[top_of_stack] * 
                    ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
        
        return max_area
```

This code efficiently calculates the largest rectangle area in the histogram by leveraging a stack to keep track of the indices of the histogram bars and ensuring that each bar is processed only a couple of times.

Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
 
Example 1:


Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 6
Explanation: The maximal rectangle is shown in the above picture.

Example 2:

Input: matrix = [["0"]]
Output: 0

Example 3:

Input: matrix = [["1"]]
Output: 1

 
Constraints:

rows == matrix.length
cols == matrix[i].length
1 <= row, cols <= 200
matrix[i][j] is '0' or '1'.



To solve the problem of finding the largest rectangle containing only 1's in a binary matrix, we can use a dynamic programming approach combined with the concept of the largest rectangle in a histogram. Here's the step-by-step plan:

1. **Transform the matrix into a list of histograms**: For each row in the matrix, treat it as the base of a histogram where each column represents the height of the histogram. If the current cell in the matrix is '1', add 1 to the height of the histogram from the previous row. If it's '0', the height becomes 0.

2. **Calculate the largest rectangle area for each histogram**: For each row-transformed histogram, calculate the largest rectangle area using a stack-based approach. This approach is efficient and works in O(n) time for each row.

3. **Keep track of the maximum area found**: As we calculate the largest rectangle area for each row's histogram, keep track of the maximum area found.

Here's the implementation of the above plan:

```python
from typing import List

class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        
        rows, cols = len(matrix), len(matrix[0])
        heights = [0] * cols
        max_area = 0
        
        for row in range(rows):
            # Update the heights for the current row
            for col in range(cols):
                heights[col] = heights[col] + 1 if matrix[row][col] == '1' else 0
            
            # Calculate the maximum rectangle area in the histogram for the current row
            max_area = max(max_area, self.largestRectangleArea(heights))
        
        return max_area
    
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0
        index = 0
        
        while index < len(heights):
            if not stack or heights[index] >= heights[stack[-1]]:
                stack.append(index)
                index += 1
            else:
                top_of_stack = stack.pop()
                area = (heights[top_of_stack] * 
                        ((index - stack[-1] - 1) if stack else index))
                max_area = max(max_area, area)
        
        while stack:
            top_of_stack = stack.pop()
            area = (heights[top_of_stack] * 
                    ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
        
        return max_area
```

### Explanation:
- **heights array**: This array keeps track of the height of the histogram for each column up to the current row.
- **largestRectangleArea function**: This function calculates the largest rectangle area in a histogram using a stack. The stack helps to find the previous smaller element efficiently.
- **Main loop**: For each row, update the heights and calculate the maximum rectangle area for the histogram formed by the current row.

This solution efficiently computes the largest rectangle area with a time complexity of O(rows * cols), which is suitable given the constraints.

Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
You should preserve the original relative order of the nodes in each of the two partitions.
 
Example 1:


Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]

Example 2:

Input: head = [2,1], x = 2
Output: [1,2]

 
Constraints:

The number of nodes in the list is in the range [0, 200].
-100 <= Node.val <= 100
-200 <= x <= 200



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        # Create two dummy nodes to start the two partitions
        before = ListNode(0)
        after = ListNode(0)
        
        # Pointers to the current end of the two partitions
        before_curr = before
        after_curr = after
        
        # Traverse the original list and partition the nodes
        while head:
            if head.val < x:
                before_curr.next = head
                before_curr = before_curr.next
            else:
                after_curr.next = head
                after_curr = after_curr.next
            head = head.next
        
        # Connect the two partitions
        before_curr.next = after.next
        # Terminate the list after the last node in the 'after' partition
        after_curr.next = None
        
        # The new head of the list is the next node of the 'before' dummy node
        return before.next
```

We can scramble a string s to get a string t using the following algorithm:

If the length of the string is 1, stop.
If the length of the string is > 1, do the following:
	
Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.
Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.
Apply step 1 recursively on each of the two substrings x and y.



Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.
 
Example 1:

Input: s1 = "great", s2 = "rgeat"
Output: true
Explanation: One possible scenario applied on s1 is:
"great" --> "gr/eat" // divide at random index.
"gr/eat" --> "gr/eat" // random decision is not to swap the two substrings and keep them in order.
"gr/eat" --> "g/r / e/at" // apply the same algorithm recursively on both substrings. divide at random index each of them.
"g/r / e/at" --> "r/g / e/at" // random decision was to swap the first substring and to keep the second substring in the same order.
"r/g / e/at" --> "r/g / e/ a/t" // again apply the algorithm recursively, divide "at" to "a/t".
"r/g / e/ a/t" --> "r/g / e/ a/t" // random decision is to keep both substrings in the same order.
The algorithm stops now, and the result string is "rgeat" which is s2.
As one possible scenario led s1 to be scrambled to s2, we return true.

Example 2:

Input: s1 = "abcde", s2 = "caebd"
Output: false

Example 3:

Input: s1 = "a", s2 = "a"
Output: true

 
Constraints:

s1.length == s2.length
1 <= s1.length <= 30
s1 and s2 consist of lowercase English letters.



```python
from functools import cache

class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        @cache
        def dfs(i: int, j: int, k: int) -> bool:
            if k == 1:
                return s1[i] == s2[j]
            for h in range(1, k):
                if dfs(i, j, h) and dfs(i + h, j + h, k - h):
                    return True
                if dfs(i + h, j, k - h) and dfs(i, j + k - h, h):
                    return True
            return False

        return dfs(0, 0, len(s1))
```

This solution uses a depth-first search (DFS) approach with memoization to determine if `s2` is a scrambled version of `s1`. The `dfs` function checks all possible ways to split and potentially swap the substrings of `s1` to see if they can match `s2`. The `cache` decorator is used to memoize the results of subproblems to avoid redundant calculations, which significantly improves the efficiency of the solution.

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.
 
Example 1:

Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

Example 2:

Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].

Example 3:

Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.

 
Constraints:

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109

 
Follow up: Can you come up with an algorithm that runs in O(m + n) time?


```python
from typing import List

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # Start from the end of nums1 and nums2
        last = m + n - 1
        i, j = m - 1, n - 1
        
        # Merge in reverse order
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[last] = nums1[i]
                i -= 1
            else:
                nums1[last] = nums2[j]
                j -= 1
            last -= 1
        
        # If there are remaining elements in nums2
        while j >= 0:
            nums1[last] = nums2[j]
            j -= 1
            last -= 1
```

This solution merges the two sorted arrays in-place with a time complexity of O(m + n). It starts filling the `nums1` array from the end, comparing the largest elements of `nums1` and `nums2` and placing the larger one at the current position from the end. This ensures that the operation is done in-place without using extra space.

An n-bit gray code sequence is a sequence of 2n integers where:

Every integer is in the inclusive range [0, 2n - 1],
The first integer is 0,
An integer appears no more than once in the sequence,
The binary representation of every pair of adjacent integers differs by exactly one bit, and
The binary representation of the first and last integers differs by exactly one bit.

Given an integer n, return any valid n-bit gray code sequence.
 
Example 1:

Input: n = 2
Output: [0,1,3,2]
Explanation:
The binary representation of [0,1,3,2] is [00,01,11,10].
- 00 and 01 differ by one bit
- 01 and 11 differ by one bit
- 11 and 10 differ by one bit
- 10 and 00 differ by one bit
[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].
- 00 and 10 differ by one bit
- 10 and 11 differ by one bit
- 11 and 01 differ by one bit
- 01 and 00 differ by one bit

Example 2:

Input: n = 1
Output: [0,1]

 
Constraints:

1 <= n <= 16



```python
from typing import List

class Solution:
    def grayCode(self, n: int) -> List[int]:
        if n == 0:
            return [0]
        
        # Start with the base case for n = 1
        gray = [0, 1]
        
        # Generate the sequence iteratively for n > 1
        for i in range(1, n):
            # Reflect the current sequence and prefix with 1 (i.e., add 2^i)
            gray += [x + (1 << i) for x in reversed(gray)]
        
        return gray
```

### Explanation:
The function `grayCode` generates an n-bit Gray code sequence. The algorithm starts with the base case for `n = 1`, which is `[0, 1]`. For each subsequent bit position, it reflects the current sequence and adds a `1` to the most significant bit of the reflected sequence. This ensures that each new number differs by exactly one bit from the previous one, maintaining the properties of the Gray code. The process is repeated until the sequence for the desired `n` is generated.

Given an integer array nums that may contain duplicates, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
 
Example 1:
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
Example 2:
Input: nums = [0]
Output: [[],[0]]

 
Constraints:

1 <= nums.length <= 10
-10 <= nums[i] <= 10



```python
from typing import List

class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()  # Sort the numbers to handle duplicates easily
        result = []
        subset = []
        
        def dfs(i):
            if i >= len(nums):
                result.append(subset.copy())
                return
            
            # Include nums[i] in the subset
            subset.append(nums[i])
            dfs(i + 1)
            
            # Exclude nums[i] from the subset
            subset.pop()
            
            # Skip duplicates
            while i + 1 < len(nums) and nums[i] == nums[i + 1]:
                i += 1
            
            dfs(i + 1)
        
        dfs(0)
        return result
```

This solution uses a backtracking approach to generate all possible subsets while skipping duplicates to ensure the result set does not contain duplicate subsets. The `nums.sort()` step is crucial for easily identifying and skipping duplicates.

You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:
"1" -> 'A'
"2" -> 'B'
...
"25" -> 'Y'
"26" -> 'Z'
However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes ("2" and "5" vs "25").
For example, "11106" can be decoded into:

"AAJF" with the grouping (1, 1, 10, 6)
"KJF" with the grouping (11, 10, 6)
The grouping (1, 11, 06) is invalid because "06" is not a valid code (only "6" is valid).

Note: there may be strings that are impossible to decode.

Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.
The test cases are generated so that the answer fits in a 32-bit integer.
 
Example 1:

Input: s = "12"
Output: 2
Explanation:
"12" could be decoded as "AB" (1 2) or "L" (12).

Example 2:

Input: s = "226"
Output: 3
Explanation:
"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

Example 3:

Input: s = "06"
Output: 0
Explanation:
"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.

 
Constraints:

1 <= s.length <= 100
s contains only digits and may contain leading zero(s).



```python
class Solution:
    def numDecodings(self, s: str) -> int:
        if not s or s[0] == '0':
            return 0
        
        # dp[i] will store the number of ways to decode the substring s[:i]
        dp = [0] * (len(s) + 1)
        dp[0] = 1  # Base case: empty string has one way to be decoded
        dp[1] = 1  # Base case: single non-zero digit can be decoded in one way
        
        for i in range(2, len(s) + 1):
            # Check if the current digit can form a valid single digit number
            if s[i - 1] != '0':
                dp[i] += dp[i - 1]
            
            # Check if the previous two digits form a valid two digit number
            two_digit = int(s[i - 2:i])
            if 10 <= two_digit <= 26:
                dp[i] += dp[i - 2]
        
        return dp[-1]
```

This solution uses dynamic programming to solve the problem. The `dp` array is used to store the number of ways to decode the substring `s[:i]`. The base cases handle the empty string and a single non-zero digit. The loop iterates through the string, updating the `dp` array based on whether the current digit and the previous two digits form valid decodings.

Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.
 
Example 1:


Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]

Example 2:

Input: head = [5], left = 1, right = 1
Output: [5]

 
Constraints:

The number of nodes in the list is n.
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n

 
Follow up: Could you do it in one pass?

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        if not head or left == right:
            return head
        
        # Create a dummy node to handle edge cases where the head itself might be reversed
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        
        # Move prev to the node just before the left position
        for _ in range(left - 1):
            prev = prev.next
        
        # Start is the node at position left, which will become the last node in the reversed sub-list
        start = prev.next
        # Then will be used to reverse the nodes
        then = start.next
        
        # Perform the reversal
        for _ in range(right - left):
            start.next = then.next
            then.next = prev.next
            prev.next = then
            then = start.next
        
        return dummy.next
```

This solution works by first setting up a dummy node that points to the head of the list. This helps in handling cases where the head itself is part of the sublist to be reversed. The algorithm then moves to the node just before the `left` position and performs an in-place reversal of the sublist from `left` to `right` using a single pass through the list.

A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.

For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses, but "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.

Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.
 
Example 1:

Input: s = "25525511135"
Output: ["255.255.11.135","255.255.111.35"]

Example 2:

Input: s = "0000"
Output: ["0.0.0.0"]

Example 3:

Input: s = "101023"
Output: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

 
Constraints:

1 <= s.length <= 20
s consists of digits only.



```python
from typing import List

class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        def is_valid(segment):
            # Check if the segment is a valid IP segment
            return len(segment) == 1 or (segment[0] != '0' and int(segment) <= 255)
        
        def backtrack(start=0, path=[]):
            # If we have 4 segments and we reached the end of the string, we found a valid IP
            if len(path) == 4:
                if start == len(s):
                    result.append(".".join(path))
                return
            # Try to create segments of length 1, 2, and 3
            for length in range(1, 4):
                if start + length <= len(s):
                    segment = s[start:start + length]
                    if is_valid(segment):
                        backtrack(start + length, path + [segment])
        
        result = []
        backtrack()
        return result
```

This solution uses a backtracking approach to explore all possible ways to insert dots into the string `s` to form valid IP addresses. The `is_valid` function checks if a given segment is a valid part of an IP address. The `backtrack` function recursively tries to build valid IP addresses by considering segments of length 1, 2, and 3, ensuring that the segments are valid and that exactly four segments are formed.

Given the root of a binary tree, return the inorder traversal of its nodes' values.
 
Example 1:

Input: root = [1,null,2,3]
Output: [1,3,2]
Explanation:


Example 2:

Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]
Output: [4,2,6,5,7,1,3,9,8]
Explanation:


Example 3:

Input: root = []
Output: []

Example 4:

Input: root = [1]
Output: [1]

 
Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100

 
Follow up: Recursive solution is trivial, could you do it iteratively?

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        stack = []
        current = root
        
        while current or stack:
            while current:
                stack.append(current)
                current = current.left
            current = stack.pop()
            result.append(current.val)
            current = current.right
        
        return result
```

Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.
 
Example 1:


Input: n = 3
Output: 5

Example 2:

Input: n = 1
Output: 1

 
Constraints:

1 <= n <= 19



```python
class Solution:
    def numTrees(self, n: int) -> int:
        # This problem can be solved using dynamic programming.
        # The idea is to use the concept of Catalan numbers.
        # G(n) = sum(G(i-1) * G(n-i)) for i in range(1, n+1)
        # where G(n) is the number of unique BSTs with n nodes.
        
        # Base case: There is one unique BST with 0 nodes and one with 1 node
        G = [0] * (n + 1)
        G[0], G[1] = 1, 1
        
        # Calculate the number of unique BSTs for each number of nodes from 2 to n
        for i in range(2, n + 1):
            for j in range(1, i + 1):
                G[i] += G[j - 1] * G[i - j]
        
        return G[n]
```

This solution uses dynamic programming to calculate the number of unique BSTs with `n` nodes. The `G` array is used to store the number of unique BSTs for each number of nodes from 0 to `n`. The result is built up iteratively using the relation `G(n) = sum(G(i-1) * G(n-i))` for `i` in `range(1, n+1)`.

Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.
An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...

Note: a + b is the concatenation of strings a and b.
 
Example 1:


Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = "aa" + "bc" + "c", and s2 into s2 = "dbbc" + "a".
Interleaving the two splits, we get "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac".
Since s3 can be obtained by interleaving s1 and s2, we return true.

Example 2:

Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.

Example 3:

Input: s1 = "", s2 = "", s3 = ""
Output: true

 
Constraints:

0 <= s1.length, s2.length <= 100
0 <= s3.length <= 200
s1, s2, and s3 consist of lowercase English letters.

 
Follow up: Could you solve it using only O(s2.length) additional memory space?


```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        # If the lengths of s1 and s2 don't add up to the length of s3, return False
        if len(s1) + len(s2) != len(s3):
            return False

        # Use dynamic programming to solve this problem
        # dp[j] will be True if s3[0:j+i] can be formed by interleaving s1[0:i] and s2[0:j]
        dp = [False] * (len(s2) + 1)
        dp[0] = True  # Base case: both s1 and s2 are empty, s3 is empty

        # Fill the dp array for the case when s1 is empty
        for j in range(1, len(s2) + 1):
            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]

        # Fill the dp array for the rest of the cases
        for i in range(1, len(s1) + 1):
            # Update dp[0] for the case when s2 is empty
            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]
            for j in range(1, len(s2) + 1):
                # Update dp[j] by considering two possibilities:
                # 1. The last character of s3 is from s1
                # 2. The last character of s3 is from s2
                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])

        return dp[len(s2)]
```

This solution uses dynamic programming to determine if `s3` can be formed by interleaving `s1` and `s2`. The `dp` array is used to store intermediate results, and it is updated based on whether the current character of `s3` can be matched with the current character of `s1` or `s2`. The solution runs in O(s1.length * s2.length) time and uses O(s2.length) additional space, meeting the follow-up requirement.

Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

 
Example 1:


Input: root = [2,1,3]
Output: true

Example 2:


Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.

 
Constraints:

The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def validate(node, low=float('-inf'), high=float('inf')):
            if not node:
                return True
            if node.val <= low or node.val >= high:
                return False
            return (validate(node.left, low, node.val) and
                    validate(node.right, node.val, high))
        
        return validate(root)
```

This solution uses a helper function `validate` that checks if the current node's value is within a valid range defined by `low` and `high`. It recursively checks the left and right subtrees with updated range constraints. If any node violates the BST properties, it returns `False`. Otherwise, it returns `True`.

You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.
 
Example 1:


Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]
Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.

Example 2:


Input: root = [3,1,4,null,null,2]
Output: [2,1,4,null,null,3]
Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.

 
Constraints:

The number of nodes in the tree is in the range [2, 1000].
-231 <= Node.val <= 231 - 1

 
Follow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution?

To solve the problem of recovering a binary search tree (BST) where two nodes have been swapped by mistake, we can use an in-order traversal. The in-order traversal of a BST should yield nodes in ascending order. If two nodes are swapped, this order will be violated at two points. We need to identify these two nodes and swap their values to restore the BST.

Here's the step-by-step approach:

1. Perform an in-order traversal of the tree while keeping track of the previous node.
2. Identify the two nodes where the order is violated.
3. Swap the values of these two nodes.

To achieve O(1) space complexity, we can use the Morris Traversal technique, which allows us to traverse the tree without using additional space for a stack or recursion.

Here's the implementation:

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        # Initialize pointers to track the two swapped nodes
        first = second = prev = None
        
        # Morris Traversal for in-order traversal
        current = root
        while current:
            if current.left is None:
                # Check if the current node is out of order
                if prev and prev.val > current.val:
                    if not first:
                        first = prev
                    second = current
                prev = current
                current = current.right
            else:
                # Find the predecessor of the current node
                pre = current.left
                while pre.right and pre.right != current:
                    pre = pre.right
                
                if pre.right is None:
                    # Establish a temporary link to the current node
                    pre.right = current
                    current = current.left
                else:
                    # Remove the temporary link
                    pre.right = None
                    # Check if the current node is out of order
                    if prev and prev.val > current.val:
                        if not first:
                            first = prev
                        second = current
                    prev = current
                    current = current.right
        
        # Swap the values of the two nodes
        if first and second:
            first.val, second.val = second.val, first.val
```

This code uses Morris Traversal to perform an in-order traversal of the BST. During the traversal, it identifies the two nodes that are out of order and swaps their values to recover the BST. The space complexity is O(1) as it does not use any additional data structures for traversal.

Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
 
Example 1:


Input: p = [1,2,3], q = [1,2,3]
Output: true

Example 2:


Input: p = [1,2], q = [1,null,2]
Output: false

Example 3:


Input: p = [1,2,1], q = [1,1,2]
Output: false

 
Constraints:

The number of nodes in both trees is in the range [0, 100].
-104 <= Node.val <= 104



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # If both nodes are None, they are the same
        if not p and not q:
            return True
        # If one of the nodes is None, they are not the same
        if not p or not q:
            return False
        # If the values of the nodes are different, they are not the same
        if p.val != q.val:
            return False
        # Recursively check the left and right subtrees
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
 
Example 1:


Input: root = [1,2,2,3,4,4,3]
Output: true

Example 2:


Input: root = [1,2,2,null,3,null,3]
Output: false

 
Constraints:

The number of nodes in the tree is in the range [1, 1000].
-100 <= Node.val <= 100

 
Follow up: Could you solve it both recursively and iteratively?

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def isMirror(t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool:
            if not t1 and not t2:
                return True
            if not t1 or not t2:
                return False
            return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)
        
        return isMirror(root, root)
    
    def isSymmetricIterative(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        
        stack = [(root.left, root.right)]
        
        while stack:
            t1, t2 = stack.pop()
            if not t1 and not t2:
                continue
            if not t1 or not t2:
                return False
            if t1.val != t2.val:
                return False
            stack.append((t1.right, t2.left))
            stack.append((t1.left, t2.right))
        
        return True
```

This solution provides both a recursive and an iterative approach to determine if a binary tree is symmetric. The `isSymmetric` method uses the recursive helper function `isMirror` to compare subtrees, while `isSymmetricIterative` uses a stack to perform the comparison iteratively.

Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

Example 2:

Input: root = [1]
Output: [[1]]

Example 3:

Input: root = []
Output: []

 
Constraints:

The number of nodes in the tree is in the range [0, 2000].
-1000 <= Node.val <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
from typing import Optional, List

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(current_level)
        
        return result
```

Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]

Example 2:

Input: root = [1]
Output: [[1]]

Example 3:

Input: root = []
Output: []

 
Constraints:

The number of nodes in the tree is in the range [0, 2000].
-100 <= Node.val <= 100



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
from typing import List, Optional

class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        
        result = []
        queue = deque([root])
        left_to_right = True
        
        while queue:
            level_size = len(queue)
            current_level = deque()
            
            for _ in range(level_size):
                node = queue.popleft()
                
                if left_to_right:
                    current_level.append(node.val)
                else:
                    current_level.appendleft(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(list(current_level))
            left_to_right = not left_to_right
        
        return result
```

Given the root of a binary tree, return its maximum depth.
A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 3

Example 2:

Input: root = [1,null,2]
Output: 2

 
Constraints:

The number of nodes in the tree is in the range [0, 104].
-100 <= Node.val <= 100



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        return max(left_depth, right_depth) + 1
```

Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
 
Example 1:


Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

Example 2:

Input: preorder = [-1], inorder = [-1]
Output: [-1]

 
Constraints:

1 <= preorder.length <= 3000
inorder.length == preorder.length
-3000 <= preorder[i], inorder[i] <= 3000
preorder and inorder consist of unique values.
Each value of inorder also appears in preorder.
preorder is guaranteed to be the preorder traversal of the tree.
inorder is guaranteed to be the inorder traversal of the tree.



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import List, Optional

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        
        # The first element in preorder is the root
        root_val = preorder[0]
        root = TreeNode(root_val)
        
        # Find the index of the root in inorder
        mid = inorder.index(root_val)
        
        # Recursively build the left subtree
        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])
        
        # Recursively build the right subtree
        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])
        
        return root
```

This solution constructs the binary tree by using the properties of preorder and inorder traversals. The first element of the preorder list is always the root of the current subtree. We then find this root in the inorder list to determine the boundary between the left and right subtrees. We recursively apply the same logic to construct the entire tree.

Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.
 
Example 1:


Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]

Example 2:

Input: inorder = [-1], postorder = [-1]
Output: [-1]

 
Constraints:

1 <= inorder.length <= 3000
postorder.length == inorder.length
-3000 <= inorder[i], postorder[i] <= 3000
inorder and postorder consist of unique values.
Each value of postorder also appears in inorder.
inorder is guaranteed to be the inorder traversal of the tree.
postorder is guaranteed to be the postorder traversal of the tree.



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder or not postorder:
            return None
        
        # The last element in postorder is the root
        root_val = postorder[-1]
        root = TreeNode(root_val)
        
        # Find the index of the root in inorder list
        root_index = inorder.index(root_val)
        
        # Elements to the left of root_index in inorder list are part of left subtree
        # Elements to the right of root_index in inorder list are part of right subtree
        root.right = self.buildTree(inorder[root_index + 1:], postorder[root_index:-1])
        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])
        
        return root
```

This solution constructs the binary tree by recursively determining the left and right subtrees using the properties of inorder and postorder traversals. The root of the tree (or subtree) is always the last element in the current postorder list. Using this root, we partition the inorder list into left and right subtrees and recursively build the tree.

Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]

Example 2:

Input: root = [1]
Output: [[1]]

Example 3:

Input: root = []
Output: []

 
Constraints:

The number of nodes in the tree is in the range [0, 2000].
-1000 <= Node.val <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
from typing import List, Optional

class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            level_nodes = []
            
            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(level_nodes)
        
        return result[::-1]
```

This solution uses a breadth-first search (BFS) approach to traverse the tree level by level. It uses a queue to keep track of nodes at the current level. After processing all nodes at the current level, it appends the list of their values to the result list. Finally, it returns the result list in reverse order to achieve the bottom-up level order traversal.

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.
 
Example 1:


Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:


Example 2:


Input: nums = [1,3]
Output: [3,1]
Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.

 
Constraints:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums is sorted in a strictly increasing order.



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def helper(left, right):
            if left > right:
                return None
            
            # Always choose the middle element to maintain balance
            mid = (left + right) // 2
            
            # Create the root node with the middle element
            node = TreeNode(nums[mid])
            
            # Recursively build the left and right subtrees
            node.left = helper(left, mid - 1)
            node.right = helper(mid + 1, right)
            
            return node
        
        return helper(0, len(nums) - 1)
```

This solution defines a helper function that recursively builds the binary search tree by selecting the middle element of the current subarray as the root node. This ensures that the tree is height-balanced. The function is initially called with the full range of the input array indices.

Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.
 
Example 1:


Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.

Example 2:

Input: head = []
Output: []

 
Constraints:

The number of nodes in head is in the range [0, 2 * 104].
-105 <= Node.val <= 105



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        if not head:
            return None
        
        # Helper function to convert a linked list to array
        def convertListToArray(head):
            result = []
            while head:
                result.append(head.val)
                head = head.next
            return result
        
        # Helper function to build a BST from the sorted array
        def buildBST(nums, left, right):
            if left > right:
                return None
            mid = (left + right) // 2
            node = TreeNode(nums[mid])
            node.left = buildBST(nums, left, mid - 1)
            node.right = buildBST(nums, mid + 1, right)
            return node
        
        # Convert the linked list to an array
        nums = convertListToArray(head)
        
        # Build the BST from the sorted array
        return buildBST(nums, 0, len(nums) - 1)
```

This solution converts the sorted linked list to a sorted array first, and then constructs a height-balanced binary search tree from the array. The conversion to an array allows for easier access to the middle element, which is crucial for building a balanced BST.

Given a binary tree, determine if it is height-balanced.
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: true

Example 2:


Input: root = [1,2,2,3,3,null,null,4,4]
Output: false

Example 3:

Input: root = []
Output: true

 
Constraints:

The number of nodes in the tree is in the range [0, 5000].
-104 <= Node.val <= 104



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional

class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def check_balance(node):
            if not node:
                return 0, True
            
            left_height, left_balanced = check_balance(node.left)
            right_height, right_balanced = check_balance(node.right)
            
            current_height = max(left_height, right_height) + 1
            current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1
            
            return current_height, current_balanced
        
        _, balanced = check_balance(root)
        return balanced
```

This solution defines a helper function `check_balance` that recursively checks each node of the tree to determine its height and whether it is balanced. The main function `isBalanced` uses this helper function and returns whether the entire tree is balanced.

Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 2

Example 2:

Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5

 
Constraints:

The number of nodes in the tree is in the range [0, 105].
-1000 <= Node.val <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        # If the left or right subtree is None, we need to consider the non-None subtree
        if not root.left:
            return 1 + self.minDepth(root.right)
        if not root.right:
            return 1 + self.minDepth(root.left)
        
        # If both left and right subtrees are not None, we find the minimum depth of both
        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))
```

This solution handles the edge cases where one of the subtrees might be `None`. It recursively calculates the minimum depth of the left and right subtrees and returns the minimum of the two, plus one for the current node. If one of the subtrees is `None`, it only considers the depth of the non-`None` subtree.

Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
A leaf is a node with no children.
 
Example 1:


Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
Explanation: The root-to-leaf path with the target sum is shown.

Example 2:


Input: root = [1,2,3], targetSum = 5
Output: false
Explanation: There are two root-to-leaf paths in the tree:
(1 --> 2): The sum is 3.
(1 --> 3): The sum is 4.
There is no root-to-leaf path with sum = 5.

Example 3:

Input: root = [], targetSum = 0
Output: false
Explanation: Since the tree is empty, there are no root-to-leaf paths.

 
Constraints:

The number of nodes in the tree is in the range [0, 5000].
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        
        # Check if we are at a leaf node
        if not root.left and not root.right:
            return root.val == targetSum
        
        # Recur for left and right subtrees with the updated target sum
        return (self.hasPathSum(root.left, targetSum - root.val) or
                self.hasPathSum(root.right, targetSum - root.val))
```

This solution uses a recursive approach to traverse the binary tree. It checks if the current node is a leaf node and if the path sum equals the target sum. If not, it recursively checks the left and right subtrees, adjusting the target sum by subtracting the current node's value.

Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.
A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.
 
Example 1:


Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: [[5,4,11,2],[5,8,4,5]]
Explanation: There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22

Example 2:


Input: root = [1,2,3], targetSum = 5
Output: []

Example 3:

Input: root = [1,2], targetSum = 0
Output: []

 
Constraints:

The number of nodes in the tree is in the range [0, 5000].
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        def dfs(node, remaining_sum, path, result):
            if not node:
                return
            
            # Add the current node to the path
            path.append(node.val)
            
            # Check if it's a leaf node and the path sum equals the target sum
            if not node.left and not node.right and remaining_sum == node.val:
                result.append(list(path))
            
            # Recurse on the left and right children
            dfs(node.left, remaining_sum - node.val, path, result)
            dfs(node.right, remaining_sum - node.val, path, result)
            
            # Backtrack: remove the current node from the path
            path.pop()
        
        result = []
        dfs(root, targetSum, [], result)
        return result
```

Given the root of a binary tree, flatten the tree into a "linked list":

The "linked list" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.
The "linked list" should be in the same order as a pre-order traversal of the binary tree.

 
Example 1:


Input: root = [1,2,5,3,4,null,6]
Output: [1,null,2,null,3,null,4,null,5,null,6]

Example 2:

Input: root = []
Output: []

Example 3:

Input: root = [0]
Output: [0]

 
Constraints:

The number of nodes in the tree is in the range [0, 2000].
-100 <= Node.val <= 100

 
Follow up: Can you flatten the tree in-place (with O(1) extra space)?

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        
        # Initialize a stack with the root node
        stack = [root]
        
        while stack:
            # Pop the top item from the stack
            node = stack.pop()
            
            # If the node has a right child, push it onto the stack
            if node.right:
                stack.append(node.right)
            
            # If the node has a left child, push it onto the stack
            if node.left:
                stack.append(node.left)
            
            # Set the left child to None
            node.left = None
            
            # Set the right child to the next item in the stack, if any
            node.right = stack[-1] if stack else None
```

This solution uses a stack to perform a pre-order traversal of the tree and rearranges the nodes in-place to form the desired linked list. The stack ensures that we process nodes in the correct order, and by modifying the `left` and `right` pointers directly, we achieve the in-place flattening with O(1) extra space (excluding the space used by the stack).

Given two strings s and t, return the number of distinct subsequences of s which equals t.
The test cases are generated so that the answer fits on a 32-bit signed integer.
 
Example 1:

Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation:
As shown below, there are 3 ways you can generate "rabbit" from s.
rabbbit
rabbbit
rabbbit

Example 2:

Input: s = "babgbag", t = "bag"
Output: 5
Explanation:
As shown below, there are 5 ways you can generate "bag" from s.
babgbag
babgbag
babgbag
babgbag
babgbag
 
Constraints:

1 <= s.length, t.length <= 1000
s and t consist of English letters.



```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        # dp[i][j] will store the number of distinct subsequences of s[:i] which equals t[:j]
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # An empty t can be formed from any prefix of s by not selecting any characters.
        for i in range(m + 1):
            dp[i][0] = 1
        
        # Fill the dp array
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s[i - 1] == t[j - 1]:
                    # If the characters match, we can either include this character or not
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    # If the characters do not match, we can only exclude this character from s
                    dp[i][j] = dp[i - 1][j]
        
        return dp[m][n]
```

This solution uses dynamic programming to solve the problem. We define `dp[i][j]` as the number of distinct subsequences of `s[:i]` which equals `t[:j]`. We initialize the first column to 1 because an empty string `t` can be formed from any prefix of `s` by not selecting any characters. Then, we fill the `dp` table based on whether the current characters of `s` and `t` match or not. Finally, `dp[m][n]` will contain the answer.

Given an integer numRows, return the first numRows of Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

 
Example 1:
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
Example 2:
Input: numRows = 1
Output: [[1]]

 
Constraints:

1 <= numRows <= 30



```python
from typing import List

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return []
        
        triangle = [[1]]
        
        for i in range(1, numRows):
            row = [1]
            for j in range(1, i):
                row.append(triangle[i-1][j-1] + triangle[i-1][j])
            row.append(1)
            triangle.append(row)
        
        return triangle
```

This solution generates Pascal's triangle up to the specified number of rows. It starts with the first row `[1]` and then iteratively builds each subsequent row by summing the appropriate elements from the previous row. Each row is appended to the `triangle` list, which is returned at the end.

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

 
Example 1:
Input: rowIndex = 3
Output: [1,3,3,1]
Example 2:
Input: rowIndex = 0
Output: [1]
Example 3:
Input: rowIndex = 1
Output: [1,1]

 
Constraints:

0 <= rowIndex <= 33

 
Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?


```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        # Initialize the row with 1s
        row = [1] * (rowIndex + 1)
        
        # Calculate each element of the row except the first and last
        for i in range(1, rowIndex):
            # Calculate from the end to the start to avoid overwriting
            for j in range(i, 0, -1):
                row[j] += row[j - 1]
        
        return row
```

This solution initializes the row with 1s, which is correct for the first and last elements of any row in Pascal's triangle. It then iteratively calculates each element of the row from the end to the start, ensuring that the calculation of each element does not interfere with the elements that will be used to calculate the subsequent elements. This approach uses only O(rowIndex) extra space, as required by the follow-up constraint.

Given a triangle array, return the minimum path sum from top to bottom.
For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.
 
Example 1:

Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).

Example 2:

Input: triangle = [[-10]]
Output: -10

 
Constraints:

1 <= triangle.length <= 200
triangle[0].length == 1
triangle[i].length == triangle[i - 1].length + 1
-104 <= triangle[i][j] <= 104

 
Follow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?

```python
from typing import List

class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        # Initialize a DP array with an extra column for easier calculations
        dp = [0] * (n + 1)
        
        # Start from the bottom of the triangle and move upwards
        for row in range(n - 1, -1, -1):
            for col in range(row + 1):
                # Update the DP array with the minimum path sum for each element
                dp[col] = min(dp[col], dp[col + 1]) + triangle[row][col]
        
        # The top element now contains the minimum path sum
        return dp[0]
```

This solution uses dynamic programming with O(n) extra space, where `n` is the number of rows in the triangle. The `dp` array is updated in place, starting from the bottom row and moving upwards, to store the minimum path sums.

You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
 
Example 1:

Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

Example 2:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.

 
Constraints:

1 <= prices.length <= 105
0 <= prices[i] <= 104



```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        
        min_price = prices[0]
        max_profit = 0
        
        for price in prices:
            if price < min_price:
                min_price = price
            elif price - min_price > max_profit:
                max_profit = price - min_price
        
        return max_profit
```

This solution iterates through the list of prices, keeping track of the minimum price encountered so far and the maximum profit that can be achieved by selling at the current price after buying at the minimum price seen so far. The time complexity is O(n), where n is the length of the prices list, and the space complexity is O(1).

You are given an integer array prices where prices[i] is the price of a given stock on the ith day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.
Find and return the maximum profit you can achieve.
 
Example 1:

Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.

Example 2:

Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.

Example 3:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.

 
Constraints:

1 <= prices.length <= 3 * 104
0 <= prices[i] <= 104



```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                max_profit += prices[i] - prices[i - 1]
        return max_profit
```

This solution iterates through the list of prices and adds the difference to the `max_profit` whenever the price of the stock on the current day is higher than the price on the previous day. This effectively captures all upward trends in the stock prices, which contribute to the maximum profit.

You are given an array prices where prices[i] is the price of a given stock on the ith day.
Find the maximum profit you can achieve. You may complete at most two transactions.
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
 
Example 1:

Input: prices = [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
Example 2:

Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.

Example 3:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.

 
Constraints:

1 <= prices.length <= 105
0 <= prices[i] <= 105



```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0

        # Initialize variables to track the minimum cost and maximum profit for up to two transactions
        min_cost1 = float('inf')
        min_cost2 = float('inf')
        max_profit1 = 0
        max_profit2 = 0

        for price in prices:
            # Calculate the maximum profit after the first transaction
            max_profit1 = max(max_profit1, price - min_cost1)
            # Update the minimum cost for the first transaction
            min_cost1 = min(min_cost1, price)
            
            # Calculate the maximum profit after the second transaction
            max_profit2 = max(max_profit2, price - min_cost2)
            # Update the minimum cost for the second transaction
            min_cost2 = min(min_cost2, price - max_profit1)

        return max_profit2
```

This solution efficiently calculates the maximum profit with at most two transactions using a single pass through the list of prices. It maintains the minimum cost for each transaction and the maximum profit that can be achieved up to that point. The key is to ensure that the second transaction can only start after the first one has been completed.

A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node's values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path.
 
Example 1:


Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.

Example 2:


Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.

 
Constraints:

The number of nodes in the tree is in the range [1, 3 * 104].
-1000 <= Node.val <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        def helper(node):
            nonlocal max_sum
            if not node:
                return 0
            
            # Recursively get the maximum gain from the left and right subtrees
            left_gain = max(helper(node.left), 0)  # If the gain is negative, we treat it as 0
            right_gain = max(helper(node.right), 0)  # If the gain is negative, we treat it as 0
            
            # Calculate the price of the new path
            price_newpath = node.val + left_gain + right_gain
            
            # Update the maximum sum if the new path is better
            max_sum = max(max_sum, price_newpath)
            
            # For recursion, return the maximum gain the current node can contribute to its parent
            return node.val + max(left_gain, right_gain)
        
        max_sum = float('-inf')
        helper(root)
        return max_sum
```

This solution uses a helper function to perform a post-order traversal of the tree. It calculates the maximum path sum that can be formed by including the current node and its left and right children. The `max_sum` variable is used to keep track of the maximum path sum found during the traversal. The function returns the maximum gain the current node can contribute to its parent, which is the node's value plus the maximum of the gains from its left and right children.

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
 
Example 1:

Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.

Example 2:

Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.

Example 3:

Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.

 
Constraints:

1 <= s.length <= 2 * 105
s consists only of printable ASCII characters.



```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        # Convert to lowercase
        s = s.lower()
        # Filter out non-alphanumeric characters
        filtered_chars = [char for char in s if char.isalnum()]
        # Join the characters to form the cleaned string
        cleaned_string = ''.join(filtered_chars)
        # Check if the cleaned string is a palindrome
        return cleaned_string == cleaned_string[::-1]
```

This solution first converts the input string to lowercase to ensure the comparison is case-insensitive. It then filters out all non-alphanumeric characters using a list comprehension. After filtering, it joins the characters to form a cleaned string. Finally, it checks if the cleaned string is equal to its reverse, returning `True` if it is a palindrome and `False` otherwise.

A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:

Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
sk == endWord

Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.
 
Example 1:

Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.

Example 2:

Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: 0
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.

 
Constraints:

1 <= beginWord.length <= 10
endWord.length == beginWord.length
1 <= wordList.length <= 5000
wordList[i].length == beginWord.length
beginWord, endWord, and wordList[i] consist of lowercase English letters.
beginWord != endWord
All the words in wordList are unique.



```python
from collections import deque, defaultdict
from typing import List

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        # If endWord is not in wordList, return 0
        if endWord not in wordList:
            return 0
        
        # Create a dictionary to hold the intermediate words
        adj_list = defaultdict(list)
        L = len(beginWord)
        
        # Create patterns like 'h*t' for each word in the list
        for word in wordList:
            for i in range(L):
                pattern = word[:i] + '*' + word[i+1:]
                adj_list[pattern].append(word)
        
        # BFS initialization
        visited = set([beginWord])
        q = deque([(beginWord, 1)])  # (current_word, current_length_of_sequence)
        
        while q:
            current_word, length = q.popleft()
            
            # Check all intermediate states of the current word
            for i in range(L):
                pattern = current_word[:i] + '*' + current_word[i+1:]
                for word in adj_list[pattern]:
                    if word == endWord:
                        return length + 1
                    if word not in visited:
                        visited.add(word)
                        q.append((word, length + 1))
        
        return 0
```

This solution uses a breadth-first search (BFS) approach to find the shortest transformation sequence from `beginWord` to `endWord`. It first creates a dictionary of intermediate patterns for each word in the word list, then performs BFS to explore all possible transformations level by level. If `endWord` is found during the BFS, it returns the length of the transformation sequence. If the queue is exhausted without finding `endWord`, it returns 0.

Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.
 
Example 1:

Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.

Example 2:

Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

Example 3:

Input: nums = [1,0,1,2]
Output: 3

 
Constraints:

0 <= nums.length <= 105
-109 <= nums[i] <= 109



```python
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        num_set = set(nums)
        longest_streak = 0
        
        for num in num_set:
            # Check if it's the start of a sequence
            if num - 1 not in num_set:
                current_num = num
                current_streak = 1
                
                # Count the length of the sequence
                while current_num + 1 in num_set:
                    current_num += 1
                    current_streak += 1
                
                longest_streak = max(longest_streak, current_streak)
        
        return longest_streak
```

This solution works as follows:
1. If the input list `nums` is empty, it returns 0 immediately.
2. It converts the list `nums` into a set `num_set` to allow O(1) average time complexity for the lookups.
3. It initializes `longest_streak` to 0 to keep track of the length of the longest consecutive sequence found.
4. It iterates over each number in `num_set`.
5. For each number, it checks if it is the start of a sequence by verifying that `num - 1` is not in the set.
6. If it is the start of a sequence, it initializes `current_num` to `num` and `current_streak` to 1.
7. It then counts the length of the sequence by checking consecutive numbers (`current_num + 1`) and increments `current_streak` accordingly.
8. After counting the length of the sequence, it updates `longest_streak` if `current_streak` is greater.
9. Finally, it returns `longest_streak` as the result.

You are given the root of a binary tree containing digits from 0 to 9 only.
Each root-to-leaf path in the tree represents a number.

For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.

Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.
A leaf node is a node with no children.
 
Example 1:


Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

Example 2:


Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.

 
Constraints:

The number of nodes in the tree is in the range [1, 1000].
0 <= Node.val <= 9
The depth of the tree will not exceed 10.



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        def dfs(node, current_number):
            if not node:
                return 0
            
            current_number = current_number * 10 + node.val
            
            # If it's a leaf node, return the current number
            if not node.left and not node.right:
                return current_number
            
            # Otherwise, continue the DFS on left and right children
            return dfs(node.left, current_number) + dfs(node.right, current_number)
        
        return dfs(root, 0)
```

You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded:

Connect: A cell is connected to adjacent cells horizontally or vertically.
Region: To form a region connect every 'O' cell.
Surround: The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board.

To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.
 
Example 1:

Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
Explanation:

In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.

Example 2:

Input: board = [["X"]]
Output: [["X"]]

 
Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] is 'X' or 'O'.



To solve this problem, we can use the Depth-First Search (DFS) approach. The idea is to find all 'O's that are connected to the borders and mark them as temporary (e.g., 'T'). Then, we can flip all remaining 'O's to 'X's because they are surrounded by 'X's. Finally, we revert the marked 'T's back to 'O's.

Here is the Python code implementing this approach:

```python
from typing import List

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board or not board[0]:
            return
        
        rows, cols = len(board), len(board[0])
        
        def dfs(r, c):
            if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != 'O':
                return
            board[r][c] = 'T'
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)
        
        # Step 1: Mark 'O's on the border and connected 'O's as 'T'
        for r in range(rows):
            for c in [0, cols - 1]:
                if board[r][c] == 'O':
                    dfs(r, c)
        for c in range(cols):
            for r in [0, rows - 1]:
                if board[r][c] == 'O':
                    dfs(r, c)
        
        # Step 2: Flip all remaining 'O's to 'X's
        for r in range(rows):
            for c in range(cols):
                if board[r][c] == 'O':
                    board[r][c] = 'X'
        
        # Step 3: Revert all 'T's back to 'O's
        for r in range(rows):
            for c in range(cols):
                if board[r][c] == 'T':
                    board[r][c] = 'O'
```

This code follows these steps:
1. Traverse the border of the board and use DFS to mark all 'O's connected to the border as 'T'.
2. Traverse the entire board and flip all remaining 'O's to 'X's.
3. Revert all 'T's back to 'O's to restore the original 'O's that were connected to the border.

This approach ensures that all surrounded regions are captured correctly while preserving the regions connected to the border.

Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.
 
Example 1:
Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]
Example 2:
Input: s = "a"
Output: [["a"]]

 
Constraints:

1 <= s.length <= 16
s contains only lowercase English letters.



```python
from typing import List

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def is_palindrome(sub: str) -> bool:
            return sub == sub[::-1]
        
        def backtrack(start: int, path: List[str]):
            if start == len(s):
                result.append(path)
                return
            for end in range(start + 1, len(s) + 1):
                if is_palindrome(s[start:end]):
                    backtrack(end, path + [s[start:end]])
        
        result = []
        backtrack(0, [])
        return result
```

This solution uses a backtracking approach to explore all possible partitions of the string `s`. The function `is_palindrome` checks if a given substring is a palindrome. The `backtrack` function recursively builds partitions by extending the current path with valid palindromic substrings and adding the path to the result when the entire string is partitioned.

Given a string s, partition s such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of s.
 
Example 1:

Input: s = "aab"
Output: 1
Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.

Example 2:

Input: s = "a"
Output: 0

Example 3:

Input: s = "ab"
Output: 1

 
Constraints:

1 <= s.length <= 2000
s consists of lowercase English letters only.



```python
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        if n == 0:
            return 0
        
        # dp array to store the minimum cuts needed for the first i characters
        dp = [float('inf')] * n
        
        # Iterate over each character in the string
        for i in range(n):
            # Check for odd length palindromes centered at i
            l, r = i, i
            while l >= 0 and r < n and s[l] == s[r]:
                if l == 0:
                    dp[r] = 0
                else:
                    dp[r] = min(dp[r], dp[l - 1] + 1)
                l -= 1
                r += 1
            
            # Check for even length palindromes centered between i and i+1
            l, r = i, i + 1
            while l >= 0 and r < n and s[l] == s[r]:
                if l == 0:
                    dp[r] = 0
                else:
                    dp[r] = min(dp[r], dp[l - 1] + 1)
                l -= 1
                r += 1
        
        return dp[n - 1]
```

This solution uses dynamic programming to find the minimum cuts needed for palindrome partitioning of the string `s`. The `dp` array keeps track of the minimum cuts needed for the first `i` characters of the string. The algorithm checks for both odd and even length palindromes centered at each position and updates the `dp` array accordingly. The final result is the value in `dp[n-1]`, which represents the minimum cuts needed for the entire string.

There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.
Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.
 
Example 1:

Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.

Example 2:

Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.

 
Constraints:

n == gas.length == cost.length
1 <= n <= 105
0 <= gas[i], cost[i] <= 104



```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)
        i = j = n - 1
        cnt = s = 0
        while cnt < n:
            s += gas[j] - cost[j]
            cnt += 1
            j = (j + 1) % n
            while s < 0 and cnt < n:
                i -= 1
                s += gas[i] - cost[i]
                cnt += 1
        return -1 if s < 0 else i
```

This solution uses a two-pointer approach to find the starting gas station index from which you can complete the circuit. The key idea is to maintain a running sum (`s`) of the gas balance (gas available minus cost to travel) and adjust the starting point (`i`) whenever the sum becomes negative. The loop ensures that we check all possible starting points in a circular manner. If the total sum (`s`) is non-negative after checking all stations, the starting point `i` is returned; otherwise, `-1` is returned, indicating it's not possible to complete the circuit.

There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.
You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.

Return the minimum number of candies you need to have to distribute the candies to the children.
 
Example 1:

Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.

Example 2:

Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
The third child gets 1 candy because it satisfies the above two conditions.

 
Constraints:

n == ratings.length
1 <= n <= 2 * 104
0 <= ratings[i] <= 2 * 104



```python
from typing import List

class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        if n == 1:
            return 1
        
        # Initialize candies array with 1 candy for each child
        candies = [1] * n
        
        # Traverse the ratings from left to right
        for i in range(1, n):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1
        
        # Traverse the ratings from right to left
        for i in range(n - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                candies[i] = max(candies[i], candies[i + 1] + 1)
        
        # Return the total number of candies
        return sum(candies)
```

This solution works by first ensuring that each child has at least one candy and that the condition of higher-rated children receiving more candies than their left neighbor is satisfied. It then ensures that the condition of higher-rated children receiving more candies than their right neighbor is also satisfied by traversing the list from right to left. Finally, it sums up the candies array to get the total number of candies needed.

Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
 
Example 1:

Input: nums = [2,2,1]
Output: 1

Example 2:

Input: nums = [4,1,2,1,2]
Output: 4

Example 3:

Input: nums = [1]
Output: 1

 
Constraints:

1 <= nums.length <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104
Each element in the array appears twice except for one element which appears only once.



```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # Using XOR to find the single number
        single = 0
        for num in nums:
            single ^= num
        return single
```

### Explanation:
The solution uses the XOR bitwise operation to find the single number in the array. The XOR operation has a few useful properties:
- `a ^ a = 0` for any integer `a`
- `a ^ 0 = a` for any integer `a`
- XOR is commutative and associative, meaning the order of operations does not matter.

Given these properties, when we XOR all the numbers together, the numbers that appear twice will cancel each other out (since `a ^ a = 0`), and we will be left with the number that appears only once. This solution runs in O(n) time complexity and uses O(1) extra space, meeting the problem's constraints.

Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.
You must implement a solution with a linear runtime complexity and use only constant extra space.
 
Example 1:
Input: nums = [2,2,3,2]
Output: 3
Example 2:
Input: nums = [0,1,0,1,0,1,99]
Output: 99

 
Constraints:

1 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
Each element in nums appears exactly three times except for one element which appears once.



```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            cnt = sum(num >> i & 1 for num in nums)
            if cnt % 3:
                if i == 31:
                    ans -= 1 << i
                else:
                    ans |= 1 << i
        return ans
```

Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
Note that the same word in the dictionary may be reused multiple times in the segmentation.
 
Example 1:

Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".

Example 2:

Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.

Example 3:

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false

 
Constraints:

1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.



```python
from typing import List

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        word_set = set(wordDict)
        dp = [False] * (len(s) + 1)
        dp[0] = True  # Base case: empty string can be segmented
        
        for i in range(1, len(s) + 1):
            for j in range(i):
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break
        
        return dp[len(s)]
```

### Explanation:
- We use dynamic programming to solve this problem.
- `dp[i]` will be `True` if the substring `s[0:i]` can be segmented into words from the dictionary.
- We initialize `dp[0]` to `True` because an empty string can always be segmented.
- For each position `i` in the string `s`, we check all possible substrings ending at `i` (from `s[j:i]` where `0 <= j < i`).
- If `dp[j]` is `True` (meaning `s[0:j]` can be segmented) and `s[j:i]` is in the dictionary, then `dp[i]` can be set to `True`.
- Finally, `dp[len(s)]` will tell us if the entire string `s` can be segmented into words from the dictionary.

Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.
Note that the same word in the dictionary may be reused multiple times in the segmentation.
 
Example 1:

Input: s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
Output: ["cats and dog","cat sand dog"]

Example 2:

Input: s = "pineapplepenapple", wordDict = ["apple","pen","applepen","pine","pineapple"]
Output: ["pine apple pen apple","pineapple pen apple","pine applepen apple"]
Explanation: Note that you are allowed to reuse a dictionary word.

Example 3:

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: []

 
Constraints:

1 <= s.length <= 20
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 10
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.
Input is generated in a way that the length of the answer doesn't exceed 105.



```python
from typing import List

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        wordSet = set(wordDict)
        memo = {}
        
        def dfs(start):
            if start in memo:
                return memo[start]
            if start == len(s):
                return [""]
            
            res = []
            for end in range(start + 1, len(s) + 1):
                word = s[start:end]
                if word in wordSet:
                    for sub_sentence in dfs(end):
                        if sub_sentence:
                            res.append(word + " " + sub_sentence)
                        else:
                            res.append(word)
            memo[start] = res
            return res
        
        return dfs(0)
```

This solution uses a depth-first search (DFS) approach with memoization to find all possible sentences. The `dfs` function attempts to break the string `s` starting from index `start` and checks if the substring from `start` to `end` is in the `wordSet`. If it is, it recursively attempts to break the remaining string from `end` and constructs sentences. Memoization is used to store the results of subproblems to avoid redundant calculations.

Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.
Return true if there is a cycle in the linked list. Otherwise, return false.
 
Example 1:


Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

Example 2:


Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.

Example 3:


Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.

 
Constraints:

The number of the nodes in the list is in the range [0, 104].
-105 <= Node.val <= 105
pos is -1 or a valid index in the linked-list.

 
Follow up: Can you solve it using O(1) (i.e. constant) memory?


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return False
        
        slow = head
        fast = head.next
        
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        
        return True
```

This solution uses Floyd's Tortoise and Hare algorithm to detect a cycle in the linked list. It uses two pointers, `slow` and `fast`. The `slow` pointer moves one step at a time, while the `fast` pointer moves two steps at a time. If there is a cycle, the `fast` pointer will eventually meet the `slow` pointer. If there is no cycle, the `fast` pointer will reach the end of the list. The algorithm runs in O(n) time and uses O(1) space, meeting the problem's constraints and follow-up requirement.

You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - 1 → Ln

Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

You may not modify the values in the list's nodes. Only nodes themselves may be changed.
 
Example 1:


Input: head = [1,2,3,4]
Output: [1,4,2,3]

Example 2:


Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]

 
Constraints:

The number of nodes in the list is in the range [1, 5 * 104].
1 <= Node.val <= 1000



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head or not head.next:
            return

        # Find the middle of the linked list
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # Reverse the second half of the list
        prev, curr = None, slow
        while curr:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp

        # Merge the two halves
        first, second = head, prev
        while second.next:
            temp1, temp2 = first.next, second.next
            first.next = second
            second.next = temp1
            first, second = temp1, temp2
```

Given the root of a binary tree, return the preorder traversal of its nodes' values.
 
Example 1:

Input: root = [1,null,2,3]
Output: [1,2,3]
Explanation:


Example 2:

Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]
Output: [1,2,4,5,6,7,3,8,9]
Explanation:


Example 3:

Input: root = []
Output: []

Example 4:

Input: root = [1]
Output: [1]

 
Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100

 
Follow up: Recursive solution is trivial, could you do it iteratively?


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        
        stack, result = [root], []
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        
        return result
```

This solution performs an iterative preorder traversal of a binary tree using a stack. It starts by pushing the root node onto the stack. Then, while the stack is not empty, it pops a node from the stack, adds its value to the result list, and pushes its right and left children onto the stack (right first so that left is processed first, maintaining the preorder sequence of root, left, right).

Given the root of a binary tree, return the postorder traversal of its nodes' values.
 
Example 1:

Input: root = [1,null,2,3]
Output: [3,2,1]
Explanation:


Example 2:

Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]
Output: [4,6,7,5,2,9,8,3,1]
Explanation:


Example 3:

Input: root = []
Output: []

Example 4:

Input: root = [1]
Output: [1]

 
Constraints:

The number of the nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100

 
Follow up: Recursive solution is trivial, could you do it iteratively?

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        result = []
        stack = [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        
        return result[::-1]
```

This solution uses an iterative approach to perform a postorder traversal of a binary tree. It utilizes a stack to simulate the recursive call stack. The nodes are processed in a modified pre-order (root, right, left) and then the result is reversed to achieve the correct post-order (left, right, root).

Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.
The steps of the insertion sort algorithm:

Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.
At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.
It repeats until no input elements remain.

The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.

 
Example 1:


Input: head = [4,2,1,3]
Output: [1,2,3,4]

Example 2:


Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]

 
Constraints:

The number of nodes in the list is in the range [1, 5000].
-5000 <= Node.val <= 5000



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Create a dummy node to act as the new head of the sorted list
        dummy = ListNode(0)
        dummy.next = head
        current = head.next
        prev = head
        
        while current:
            # If the current node is in the correct position, move on
            if current.val >= prev.val:
                prev = current
                current = current.next
            else:
                # Otherwise, find the correct position for the current node
                temp = dummy
                while temp.next and temp.next.val < current.val:
                    temp = temp.next
                
                # Insert the current node in the correct position
                prev.next = current.next
                current.next = temp.next
                temp.next = current
                
                # Move to the next node
                current = prev.next
        
        return dummy.next
```

This implementation of the insertion sort for a singly linked list follows the algorithm's steps. It uses a dummy node to simplify edge cases and iteratively sorts the list by finding the correct position for each node.

Given the head of a linked list, return the list after sorting it in ascending order.
 
Example 1:


Input: head = [4,2,1,3]
Output: [1,2,3,4]

Example 2:


Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]

Example 3:

Input: head = []
Output: []

 
Constraints:

The number of nodes in the list is in the range [0, 5 * 104].
-105 <= Node.val <= 105

 
Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?


To solve the problem of sorting a linked list in ascending order with a time complexity of O(n log n) and a space complexity of O(1), we can use the merge sort algorithm. Merge sort is well-suited for linked lists because it does not require random access to elements, which is a limitation of linked lists compared to arrays.

Here's the complete implementation:

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Find the middle of the list
        middle = self.getMiddle(head)
        next_to_middle = middle.next
        middle.next = None
        
        # Recursively sort the two halves
        left = self.sortList(head)
        right = self.sortList(next_to_middle)
        
        # Merge the sorted halves
        sorted_list = self.sortedMerge(left, right)
        
        return sorted_list
    
    def getMiddle(self, head):
        if not head:
            return head
        
        slow = head
        fast = head.next
        
        while fast:
            fast = fast.next
            if fast:
                slow = slow.next
                fast = fast.next
        
        return slow
    
    def sortedMerge(self, a, b):
        result = None
        
        if not a:
            return b
        if not b:
            return a
        
        if a.val <= b.val:
            result = a
            result.next = self.sortedMerge(a.next, b)
        else:
            result = b
            result.next = self.sortedMerge(a, b.next)
        
        return result
```

### Explanation:
1. **Base Case**: If the list is empty or has only one element (`head` is `None` or `head.next` is `None`), it is already sorted, so we return `head`.

2. **Finding the Middle**: We use the `getMiddle` function to find the middle of the linked list. This function uses the slow and fast pointer technique to find the middle node. The slow pointer moves one step at a time, while the fast pointer moves two steps. When the fast pointer reaches the end, the slow pointer will be at the middle.

3. **Recursive Sorting**: We recursively sort the two halves of the list. The first half starts from the head and ends at the middle, and the second half starts from the node next to the middle.

4. **Merging**: We merge the two sorted halves using the `sortedMerge` function. This function takes two sorted linked lists and merges them into a single sorted linked list.

This implementation ensures that the linked list is sorted in O(n log n) time and uses O(1) additional space, meeting the constraints of the problem.

Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.
 
Example 1:


Input: points = [[1,1],[2,2],[3,3]]
Output: 3

Example 2:


Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4

 
Constraints:

1 <= points.length <= 300
points[i].length == 2
-104 <= xi, yi <= 104
All the points are unique.



```python
from typing import List

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        ans = 1
        for i in range(n):
            x1, y1 = points[i]
            for j in range(i + 1, n):
                x2, y2 = points[j]
                cnt = 2
                for k in range(j + 1, n):
                    x3, y3 = points[k]
                    a = (y2 - y1) * (x3 - x1)
                    b = (y3 - y1) * (x2 - x1)
                    cnt += a == b
                ans = max(ans, cnt)
        return ans
```

This solution iterates through all pairs of points and checks how many other points lie on the same line defined by each pair. The slope comparison is done using cross multiplication to avoid division and potential floating-point precision issues. The time complexity of this solution is O(n^3), which is acceptable given the constraint that the number of points is at most 300.

You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.
Evaluate the expression. Return an integer that represents the value of the expression.
Note that:

The valid operators are '+', '-', '*', and '/'.
Each operand may be an integer or another expression.
The division between two integers always truncates toward zero.
There will not be any division by zero.
The input represents a valid arithmetic expression in a reverse polish notation.
The answer and all the intermediate calculations can be represented in a 32-bit integer.

 
Example 1:

Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

Example 2:

Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6

Example 3:

Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22

 
Constraints:

1 <= tokens.length <= 104
tokens[i] is either an operator: "+", "-", "*", or "/", or an integer in the range [-200, 200].



```python
from typing import List

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        operators = {'+', '-', '*', '/'}
        
        for token in tokens:
            if token not in operators:
                stack.append(int(token))
            else:
                # Pop the two top elements from the stack
                b = stack.pop()
                a = stack.pop()
                
                # Perform the operation and push the result back onto the stack
                if token == '+':
                    stack.append(a + b)
                elif token == '-':
                    stack.append(a - b)
                elif token == '*':
                    stack.append(a * b)
                elif token == '/':
                    # Use int() for truncating division towards zero
                    stack.append(int(a / b))
        
        # The final result is the only element left in the stack
        return stack[0]
```

This solution uses a stack to evaluate the Reverse Polish Notation expression. It iterates through each token, pushing operands onto the stack and performing operations when an operator is encountered. The result of each operation is pushed back onto the stack. The final result remains as the only element in the stack.

Given an input string s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.
Return a string of the words in reverse order concatenated by a single space.
Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.
 
Example 1:

Input: s = "the sky is blue"
Output: "blue is sky the"

Example 2:

Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.

Example 3:

Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.

 
Constraints:

1 <= s.length <= 104
s contains English letters (upper-case and lower-case), digits, and spaces ' '.
There is at least one word in s.

 
Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?


```python
class Solution:
    def reverseWords(self, s: str) -> str:
        # Split the string by spaces and filter out any empty strings
        words = s.split()
        # Reverse the list of words
        words.reverse()
        # Join the words with a single space
        return ' '.join(words)
```

This solution first splits the input string `s` into a list of words, automatically handling multiple spaces and leading/trailing spaces by using the `split()` method without any arguments. It then reverses the list of words and finally joins them back into a single string with a single space between each word. This approach ensures that the output string meets the problem's requirements.

Given an integer array nums, find a subarray that has the largest product, and return the product.
The test cases are generated so that the answer will fit in a 32-bit integer.
 
Example 1:

Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

Example 2:

Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

 
Constraints:

1 <= nums.length <= 2 * 104
-10 <= nums[i] <= 10
The product of any subarray of nums is guaranteed to fit in a 32-bit integer.



```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        # Initialize the maximum product, minimum product, and result to the first element
        max_product = min_product = result = nums[0]
        
        # Iterate through the array starting from the second element
        for num in nums[1:]:
            if num < 0:
                # Swap max_product and min_product when a negative number is encountered
                max_product, min_product = min_product, max_product
            
            # Calculate the maximum and minimum product ending at the current position
            max_product = max(num, max_product * num)
            min_product = min(num, min_product * num)
            
            # Update the result with the maximum product found so far
            result = max(result, max_product)
        
        return result
```

This solution uses a dynamic programming approach to keep track of the maximum and minimum products up to the current position in the array. The reason for keeping track of the minimum product is that a negative number can turn a large negative product into a large positive product. The solution iterates through the array once, making it efficient with a time complexity of O(n).

Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.

Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
Given the sorted rotated array nums of unique elements, return the minimum element of this array.
You must write an algorithm that runs in O(log n) time.
 
Example 1:

Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.

Example 2:

Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.

Example 3:

Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 

 
Constraints:

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
All the integers of nums are unique.
nums is sorted and rotated between 1 and n times.



```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        if nums[0] <= nums[-1]:
            return nums[0]
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) >> 1
            if nums[0] <= nums[mid]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:

[4,5,6,7,0,1,4] if it was rotated 4 times.
[0,1,4,4,5,6,7] if it was rotated 7 times.

Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.
You must decrease the overall operation steps as much as possible.
 
Example 1:
Input: nums = [1,3,5]
Output: 1
Example 2:
Input: nums = [2,2,2,0,1]
Output: 0

 
Constraints:

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
nums is sorted and rotated between 1 and n times.

 
Follow up: This problem is similar to Find Minimum in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?
 


```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        
        while left < right:
            mid = (left + right) // 2
            
            # If mid element is greater than the rightmost element, the minimum is in the right half
            if nums[mid] > nums[right]:
                left = mid + 1
            # If mid element is less than the rightmost element, the minimum is in the left half including mid
            elif nums[mid] < nums[right]:
                right = mid
            # If mid element is equal to the rightmost element, we cannot determine the side, reduce the search space
            else:
                right -= 1
        
        return nums[left]
```

### Explanation:
- The solution uses a modified binary search to find the minimum element in a rotated sorted array that may contain duplicates.
- The key idea is to use the comparison between the middle element (`nums[mid]`) and the rightmost element (`nums[right]`) to decide which half of the array to search next.
- If `nums[mid] > nums[right]`, the minimum element must be in the right half, so we move the `left` pointer to `mid + 1`.
- If `nums[mid] < nums[right]`, the minimum element is in the left half including `mid`, so we move the `right` pointer to `mid`.
- If `nums[mid] == nums[right]`, we cannot determine which half to search, so we reduce the search space by moving the `right` pointer one step to the left (`right -= 1`).
- The loop continues until `left` equals `right`, at which point `nums[left]` is the minimum element.
- The time complexity is O(log n) in the average case but can degrade to O(n) in the worst case due to duplicates.

Given the root of a binary tree, turn the tree upside down and return the new root.
You can turn a binary tree upside down with the following steps:

The original left child becomes the new root.
The original root becomes the new right child.
The original right child becomes the new left child.


The mentioned steps are done level by level. It is guaranteed that every right node has a sibling (a left node with the same parent) and has no children.
 
Example 1:


Input: root = [1,2,3,4,5]
Output: [4,5,2,null,null,3,1]

Example 2:

Input: root = []
Output: []

Example 3:

Input: root = [1]
Output: [1]

 
Constraints:

The number of nodes in the tree will be in the range [0, 10].
1 <= Node.val <= 10
Every right node in the tree has a sibling (a left node that shares the same parent).
Every right node in the tree has no children.



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def upsideDownBinaryTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root or not root.left:
            return root
        
        new_root = self.upsideDownBinaryTree(root.left)
        root.left.left = root.right
        root.left.right = root
        root.left = root.right = None
        
        return new_root
```

This solution recursively turns the binary tree upside down by focusing on the left subtree and rearranging the nodes as specified in the problem statement. The base case handles scenarios where the tree is empty or has only one node.

Given a string s, return the length of the longest substring that contains at most two distinct characters.
 
Example 1:

Input: s = "eceba"
Output: 3
Explanation: The substring is "ece" which its length is 3.

Example 2:

Input: s = "ccaabbb"
Output: 5
Explanation: The substring is "aabbb" which its length is 5.

 
Constraints:

1 <= s.length <= 105
s consists of English letters.



```python
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        from collections import defaultdict
        
        # Dictionary to store the count of characters in the current window
        char_count = defaultdict(int)
        left = 0
        max_length = 0
        
        for right in range(len(s)):
            # Add the current character to the window
            char_count[s[right]] += 1
            
            # If we have more than 2 distinct characters, shrink the window from the left
            while len(char_count) > 2:
                char_count[s[left]] -= 1
                if char_count[s[left]] == 0:
                    del char_count[s[left]]
                left += 1
            
            # Update the maximum length of the window
            max_length = max(max_length, right - left + 1)
        
        return max_length
```

This solution uses a sliding window approach with a dictionary to keep track of the count of characters within the current window. It ensures that the window contains at most two distinct characters by adjusting the left boundary when necessary. The maximum length of such a window is updated and returned as the result.

Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
For example, the following two linked lists begin to intersect at node c1:

The test cases are generated such that there are no cycles anywhere in the entire linked structure.
Note that the linked lists must retain their original structure after the function returns.
Custom Judge:
The inputs to the judge are given as follows (your program is not given these inputs):

intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.
listA - The first linked list.
listB - The second linked list.
skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.
skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.

The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.
 
Example 1:


Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'
Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.

Example 2:


Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Intersected at '2'
Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.

Example 3:


Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: No intersection
Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.

 
Constraints:

The number of nodes of listA is in the m.
The number of nodes of listB is in the n.
1 <= m, n <= 3 * 104
1 <= Node.val <= 105
0 <= skipA <= m
0 <= skipB <= n
intersectVal is 0 if listA and listB do not intersect.
intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.

 
Follow up: Could you write a solution that runs in O(m + n) time and use only O(1) memory?

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        # Initialize two pointers for both lists
        pointerA = headA
        pointerB = headB
        
        # Traverse both lists
        while pointerA is not pointerB:
            # Move pointerA to the head of list B if it reaches the end of list A
            if pointerA is None:
                pointerA = headB
            else:
                pointerA = pointerA.next
            
            # Move pointerB to the head of list A if it reaches the end of list B
            if pointerB is None:
                pointerB = headA
            else:
                pointerB = pointerB.next
        
        # Either both pointers meet at the intersection node or both become None
        return pointerA
```

This solution works by using two pointers that traverse both linked lists. When a pointer reaches the end of its list, it is redirected to the head of the other list. This way, both pointers will traverse the same number of nodes (m + n) and will meet at the intersection node if there is one. If there is no intersection, both pointers will become `None` at the same time. This approach ensures an O(m + n) time complexity and O(1) space complexity.

Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.
A string s is said to be one distance apart from a string t if you can:

Insert exactly one character into s to get t.
Delete exactly one character from s to get t.
Replace exactly one character of s with a different character to get t.

 
Example 1:

Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.

Example 2:

Input: s = "", t = ""
Output: false
Explanation: We cannot get t from s by only one step.

 
Constraints:

0 <= s.length, t.length <= 104
s and t consist of lowercase letters, uppercase letters, and digits.



```python
class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        # Ensure s is the shorter string
        if len(s) > len(t):
            return self.isOneEditDistance(t, s)
        
        # If the length difference is greater than 1, they can't be one edit distance apart
        if len(t) - len(s) > 1:
            return False
        
        for i in range(len(s)):
            if s[i] != t[i]:
                # Check for the three possible one edit distances
                # 1. Replace one character in s to match t
                # 2. Insert one character in s to match t
                # 3. Delete one character from t to match s
                return s[i+1:] == t[i+1:] or s[i:] == t[i+1:] or s[i+1:] == t[i:]
        
        # If all characters are the same, the only way to be one edit distance apart is to add one character to s
        return len(s) + 1 == len(t)
```

This solution checks for the three possible one-edit distances: replacing a character, inserting a character, and deleting a character. It ensures that the strings are at most one character length apart and iterates through the characters to find the point of difference. If no difference is found, it checks if the length difference is exactly one, which would mean one character could be added to make the strings equal.

A peak element is an element that is strictly greater than its neighbors.
Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.
You must write an algorithm that runs in O(log n) time.
 
Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
 
Constraints:

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
nums[i] != nums[i + 1] for all valid i.



```python
from typing import List

class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        
        while left < right:
            mid = (left + right) // 2
            
            if nums[mid] > nums[mid + 1]:
                # If the middle element is greater than the next element,
                # then the peak is in the left half (including mid)
                right = mid
            else:
                # If the middle element is less than or equal to the next element,
                # then the peak is in the right half (excluding mid)
                left = mid + 1
        
        # When left == right, we have found a peak element
        return left
```

This solution implements a binary search approach to find a peak element in O(log n) time. The key idea is to compare the middle element with its right neighbor and decide which half of the array to search next based on this comparison.

You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are within the inclusive range.
A number x is considered missing if x is in the range [lower, upper] and x is not in nums.
Return the shortest sorted list of ranges that exactly covers all the missing numbers. That is, no element of nums is included in any of the ranges, and each missing number is covered by one of the ranges.
 
 
Example 1:

Input: nums = [0,1,3,50,75], lower = 0, upper = 99
Output: [[2,2],[4,49],[51,74],[76,99]]
Explanation: The ranges are:
[2,2]
[4,49]
[51,74]
[76,99]

Example 2:

Input: nums = [-1], lower = -1, upper = -1
Output: []
Explanation: There are no missing ranges since there are no missing numbers.

 
Constraints:

-109 <= lower <= upper <= 109
0 <= nums.length <= 100
lower <= nums[i] <= upper
All the values of nums are unique.



```python
from typing import List

class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[List[int]]:
        def add_range(start, end):
            if start == end:
                missing_ranges.append([start, start])
            elif start < end:
                missing_ranges.append([start, end])
        
        missing_ranges = []
        prev = lower - 1
        
        for num in nums + [upper + 1]:
            if num > prev + 1:
                add_range(prev + 1, num - 1)
            prev = num
        
        return missing_ranges

# Example usage:
# sol = Solution()
# print(sol.findMissingRanges([0,1,3,50,75], 0, 99))  # Output: [[2,2],[4,49],[51,74],[76,99]]
# print(sol.findMissingRanges([-1], -1, -1))  # Output: []
```

This solution iterates through the `nums` array and checks for gaps between the current number and the previous number. It uses a helper function `add_range` to append the missing ranges to the result list. The loop also includes `upper + 1` to ensure the last range is checked.

Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.
You must write an algorithm that runs in linear time and uses linear extra space.
 
Example 1:

Input: nums = [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.

Example 2:

Input: nums = [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.

 
Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109



To solve the problem in linear time and with linear extra space, we can use the concept of bucket sort. The idea is to distribute the numbers into buckets and then find the maximum gap between the minimum value of the next non-empty bucket and the maximum value of the current bucket.

Here's the implementation:

```python
from typing import List

class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return 0
        
        min_num = min(nums)
        max_num = max(nums)
        
        # If all numbers are the same, the maximum gap is 0
        if min_num == max_num:
            return 0
        
        # Bucket sort setup
        bucket_size = max(1, (max_num - min_num) // (n - 1))
        bucket_count = (max_num - min_num) // bucket_size + 1
        buckets = [{'min': float('inf'), 'max': float('-inf')} for _ in range(bucket_count)]
        
        # Distribute the numbers into buckets
        for num in nums:
            index = (num - min_num) // bucket_size
            buckets[index]['min'] = min(buckets[index]['min'], num)
            buckets[index]['max'] = max(buckets[index]['max'], num)
        
        # Find the maximum gap
        max_gap = 0
        prev_max = min_num
        
        for bucket in buckets:
            if bucket['min'] == float('inf'):
                continue  # Skip empty buckets
            max_gap = max(max_gap, bucket['min'] - prev_max)
            prev_max = bucket['max']
        
        return max_gap
```

### Explanation:
1. **Edge Cases**: If the array has less than 2 elements, return 0. If all elements are the same, return 0.
2. **Bucket Setup**: Calculate the bucket size and number of buckets. Each bucket will store the minimum and maximum values of the numbers that fall into it.
3. **Distribute Numbers**: Place each number in the appropriate bucket based on its value.
4. **Calculate Maximum Gap**: Iterate through the buckets and calculate the gap between the maximum value of the previous bucket and the minimum value of the current bucket. Keep track of the maximum gap found.

This approach ensures that the algorithm runs in O(n) time and uses O(n) extra space, meeting the problem's constraints.

Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros.
To compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0.
Return the following:

If version1 < version2, return -1.
If version1 > version2, return 1.
Otherwise, return 0.

 
Example 1:

Input: version1 = "1.2", version2 = "1.10"
Output: -1
Explanation:
version1's second revision is "2" and version2's second revision is "10": 2 < 10, so version1 < version2.

Example 2:

Input: version1 = "1.01", version2 = "1.001"
Output: 0
Explanation:
Ignoring leading zeroes, both "01" and "001" represent the same integer "1".

Example 3:

Input: version1 = "1.0", version2 = "1.0.0.0"
Output: 0
Explanation:
version1 has less revisions, which means every missing revision are treated as "0".

 
Constraints:

1 <= version1.length, version2.length <= 500
version1 and version2 only contain digits and '.'.
version1 and version2 are valid version numbers.
All the given revisions in version1 and version2 can be stored in a 32-bit integer.



```python
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        # Split the version strings by the dot
        revisions1 = version1.split('.')
        revisions2 = version2.split('.')
        
        # Get the maximum length of the two revision lists
        max_length = max(len(revisions1), len(revisions2))
        
        # Compare each revision
        for i in range(max_length):
            # Convert the current revision to integer, default to 0 if the revision is missing
            rev1 = int(revisions1[i]) if i < len(revisions1) else 0
            rev2 = int(revisions2[i]) if i < len(revisions2) else 0
            
            # Compare the current revisions
            if rev1 < rev2:
                return -1
            elif rev1 > rev2:
                return 1
        
        # If all revisions are equal
        return 0
```
This solution splits the version strings into their respective revisions, compares each corresponding pair of revisions, and returns the appropriate result based on the comparison. If one version string has fewer revisions, the missing revisions are treated as 0.

Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
If the fractional part is repeating, enclose the repeating part in parentheses.
If multiple answers are possible, return any of them.
It is guaranteed that the length of the answer string is less than 104 for all the given inputs.
 
Example 1:

Input: numerator = 1, denominator = 2
Output: "0.5"

Example 2:

Input: numerator = 2, denominator = 1
Output: "2"

Example 3:

Input: numerator = 4, denominator = 333
Output: "0.(012)"

 
Constraints:

-231 <= numerator, denominator <= 231 - 1
denominator != 0



```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator == 0:
            return "0"
        
        # Determine the sign of the result
        sign = '-' if (numerator < 0) ^ (denominator < 0) else ''
        
        # Work with absolute values to simplify the process
        numerator, denominator = abs(numerator), abs(denominator)
        
        # Calculate the integer part
        integer_part = numerator // denominator
        remainder = numerator % denominator
        
        # If there is no remainder, return the integer part with the sign
        if remainder == 0:
            return sign + str(integer_part)
        
        # Dictionary to store the seen remainders and their corresponding position in the result
        seen_remainders = {}
        fractional_part = []
        position = 0
        
        # Calculate the fractional part
        while remainder != 0:
            # If the remainder is seen before, we have a repeating part
            if remainder in seen_remainders:
                start = seen_remainders[remainder]
                non_repeating = ''.join(fractional_part[:start])
                repeating = ''.join(fractional_part[start:])
                return sign + str(integer_part) + '.' + non_repeating + '(' + repeating + ')'
            
            # Record the position of this remainder
            seen_remainders[remainder] = position
            position += 1
            
            # Calculate the next digit in the fractional part
            remainder *= 10
            digit = remainder // denominator
            fractional_part.append(str(digit))
            remainder %= denominator
        
        # If no repeating part, return the integer and fractional parts
        return sign + str(integer_part) + '.' + ''.join(fractional_part)
```

This code handles the conversion of a fraction to its decimal representation, identifying and enclosing any repeating parts in parentheses. It also correctly handles the sign of the result and edge cases such as when the numerator is zero.

Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution. You may not use the same element twice.
Your solution must use only constant extra space.
 
Example 1:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].

Example 2:

Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].

Example 3:

Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].

 
Constraints:

2 <= numbers.length <= 3 * 104
-1000 <= numbers[i] <= 1000
numbers is sorted in non-decreasing order.
-1000 <= target <= 1000
The tests are generated such that there is exactly one solution.



```python
from bisect import bisect_left
from typing import List

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        n = len(numbers)
        for i in range(n - 1):
            x = target - numbers[i]
            j = bisect_left(numbers, x, lo=i + 1)
            if j < n and numbers[j] == x:
                return [i + 1, j + 1]
```

This solution leverages the `bisect_left` function from the `bisect` module to perform a binary search, which is efficient given that the input list `numbers` is already sorted. The loop iterates through each element, calculates the complement needed to reach the target, and uses binary search to find the complement in the remaining part of the list. If the complement is found, it returns the 1-indexed positions of the two numbers.

Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.
For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...

 
Example 1:

Input: columnNumber = 1
Output: "A"

Example 2:

Input: columnNumber = 28
Output: "AB"

Example 3:

Input: columnNumber = 701
Output: "ZY"

 
Constraints:

1 <= columnNumber <= 231 - 1



```python
class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        result = ""
        while columnNumber > 0:
            # Convert the current part of the column number to a character
            columnNumber, remainder = divmod(columnNumber - 1, 26)
            result = chr(65 + remainder) + result
        return result
```

This code converts a given integer `columnNumber` to its corresponding Excel column title. The approach involves repeatedly dividing the number by 26 and mapping the remainder to a letter from A to Z. The subtraction by 1 before the division handles the 1-based indexing of the Excel columns.

Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
 
Example 1:
Input: nums = [3,2,3]
Output: 3
Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2

 
Constraints:

n == nums.length
1 <= n <= 5 * 104
-109 <= nums[i] <= 109

 
Follow-up: Could you solve the problem in linear time and in O(1) space?

```python
from typing import List

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # Boyer-Moore Voting Algorithm
        count = 0
        candidate = None
        
        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)
        
        return candidate
```

This solution implements the Boyer-Moore Voting Algorithm, which finds the majority element in linear time and with constant space complexity, O(1). The algorithm works by maintaining a count and a candidate for the majority element. As it iterates through the list, it adjusts the count based on whether the current number matches the candidate. When the count drops to zero, it selects a new candidate. The majority element, by definition, will be the last remaining candidate at the end of the iteration.

Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.
For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...

 
Example 1:

Input: columnTitle = "A"
Output: 1

Example 2:

Input: columnTitle = "AB"
Output: 28

Example 3:

Input: columnTitle = "ZY"
Output: 701

 
Constraints:

1 <= columnTitle.length <= 7
columnTitle consists only of uppercase English letters.
columnTitle is in the range ["A", "FXSHRXW"].



```python
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        result = 0
        for char in columnTitle:
            # Convert character to its corresponding number (A=1, B=2, ..., Z=26)
            num = ord(char) - ord('A') + 1
            # Update result by shifting the current result by 26 (base) and adding the new number
            result = result * 26 + num
        return result
```

This code converts an Excel column title to its corresponding column number by treating the column title as a base-26 number system where 'A' corresponds to 1, 'B' to 2, ..., 'Z' to 26, and so on. The function iterates over each character in the input string, converts it to its numeric equivalent, and accumulates the result.

Given an integer n, return the number of trailing zeroes in n!.
Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.
 
Example 1:

Input: n = 3
Output: 0
Explanation: 3! = 6, no trailing zero.

Example 2:

Input: n = 5
Output: 1
Explanation: 5! = 120, one trailing zero.

Example 3:

Input: n = 0
Output: 0

 
Constraints:

0 <= n <= 104

 
Follow up: Could you write a solution that works in logarithmic time complexity?


To solve the problem of finding the number of trailing zeroes in the factorial of a given integer \( n \), we need to understand that trailing zeroes are created by factors of 10 in the number. Since 10 is the product of 2 and 5, and there are always more factors of 2 than 5 in factorials, the number of trailing zeroes is determined by the number of times 5 is a factor in the numbers from 1 to \( n \).

The efficient way to count the number of factors of 5 is to repeatedly divide \( n \) by 5 and sum up the quotients. This works because each multiple of 5 contributes at least one factor of 5, each multiple of 25 contributes an additional factor of 5, and so on.

Here is the Python code implementing this logic:

```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
        while n > 0:
            n //= 5
            count += n
        return count
```

### Explanation:
- We initialize `count` to 0.
- We use a `while` loop to repeatedly divide \( n \) by 5.
- In each iteration, we add the integer division result `n // 5` to `count`.
- We continue this process until \( n \) becomes 0.
- The final value of `count` is the number of trailing zeroes in \( n! \).

This solution works in logarithmic time complexity \( O(\log n) \) because the number of times we can divide \( n \) by 5 is proportional to the number of digits in \( n \) in base 5.

The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.
The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.
Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).
To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.
Return the knight's minimum initial health so that he can rescue the princess.
Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
 
Example 1:


Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
Output: 7
Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.

Example 2:

Input: dungeon = [[0]]
Output: 1

 
Constraints:

m == dungeon.length
n == dungeon[i].length
1 <= m, n <= 200
-1000 <= dungeon[i][j] <= 1000



```python
from typing import List

class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        
        # Create a 2D list to store the minimum health needed at each cell
        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]
        dp[m][n - 1] = dp[m - 1][n] = 1
        
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                min_health_on_exit = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]
                dp[i][j] = 1 if min_health_on_exit <= 0 else min_health_on_exit
        
        return dp[0][0]
```

This solution uses dynamic programming to calculate the minimum health required for the knight to rescue the princess. The `dp` table is used to store the minimum health needed at each cell to ensure the knight reaches the princess with at least 1 health point. The knight can only move right or down, so the solution iterates from the bottom-right corner to the top-left corner of the dungeon, updating the `dp` table accordingly.

Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
Since the result may be very large, so you need to return a string instead of an integer.
 
Example 1:

Input: nums = [10,2]
Output: "210"

Example 2:

Input: nums = [3,30,34,5,9]
Output: "9534330"

 
Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 109



```python
from typing import List

class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        # Convert all integers to strings for comparison
        nums_str = list(map(str, nums))
        
        # Sort the numbers based on custom comparator
        # We compare two numbers x and y by comparing xy and yx
        # If xy > yx, x should come before y
        nums_str.sort(key=lambda x: x*10, reverse=True)
        
        # Join the sorted numbers into a single string
        largest_number = ''.join(nums_str)
        
        # Handle the case where the result is all zeros
        return '0' if largest_number[0] == '0' else largest_number
```

### Explanation:
1. **Conversion to Strings**: We first convert all integers in the list to strings. This is necessary because we need to compare numbers based on their concatenated results, not their numerical value.

2. **Custom Sorting**: We sort the list of string numbers using a custom key. The key is `lambda x: x*10`, which effectively sorts the numbers by comparing them in a way that determines their order in the final concatenated result. By repeating the string up to 10 times, we ensure that the comparison considers the order correctly for numbers of different lengths.

3. **Joining the Strings**: After sorting, we join the list of strings into a single string to form the largest number.

4. **Handling Edge Cases**: If the result is a string of zeros (which can happen if the input is all zeros), we return '0' instead of multiple zeros. This is handled by checking if the first character of the result is '0'.

Given a character array s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.
Your code must solve the problem in-place, i.e. without allocating extra space.
 
Example 1:
Input: s = ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]
Example 2:
Input: s = ["a"]
Output: ["a"]

 
Constraints:

1 <= s.length <= 105
s[i] is an English letter (uppercase or lowercase), digit, or space ' '.
There is at least one word in s.
s does not contain leading or trailing spaces.
All the words in s are guaranteed to be separated by a single space.



```python
class Solution:
    def reverseWords(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        # Reverse the entire character array
        s.reverse()
        
        # Initialize pointers for reversing each word
        start = 0
        end = 0
        n = len(s)
        
        # Reverse each word in the reversed array
        while start < n:
            # Find the end of the current word
            while end < n and s[end] != ' ':
                end += 1
            
            # Reverse the current word
            s[start:end] = reversed(s[start:end])
            
            # Move to the next word
            start = end + 1
            end += 1
```

The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.

For example, "ACGAATTCCG" is a DNA sequence.

When studying DNA, it is useful to identify repeated sequences within the DNA.
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.
 
Example 1:
Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
Output: ["AAAAACCCCC","CCCCCAAAAA"]
Example 2:
Input: s = "AAAAAAAAAAAAA"
Output: ["AAAAAAAAAA"]

 
Constraints:

1 <= s.length <= 105
s[i] is either 'A', 'C', 'G', or 'T'.



```python
from collections import Counter
from typing import List

class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        cnt = Counter()
        ans = []
        for i in range(len(s) - 10 + 1):
            t = s[i : i + 10]
            cnt[t] += 1
            if cnt[t] == 2:
                ans.append(t)
        return ans
```

This solution uses a `Counter` to keep track of the frequency of each 10-letter-long sequence in the DNA string `s`. It iterates through the string, extracts each 10-letter sequence, and updates its count in the `Counter`. If a sequence's count reaches 2, it means the sequence is repeated, and it is added to the result list `ans`. Finally, the function returns the list of repeated sequences.

You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.
Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
 
Example 1:

Input: k = 2, prices = [2,4,1]
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.

Example 2:

Input: k = 2, prices = [3,2,6,5,0,3]
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.

 
Constraints:

1 <= k <= 100
1 <= prices.length <= 1000
0 <= prices[i] <= 1000



```python
from typing import List

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices or k == 0:
            return 0
        
        n = len(prices)
        if k >= n // 2:
            # If k is large enough, we can make as many transactions as we want
            return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))
        
        # Initialize DP table
        dp = [[0] * n for _ in range(k + 1)]
        
        for i in range(1, k + 1):
            max_diff = -prices[0]
            for j in range(1, n):
                dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)
                max_diff = max(max_diff, dp[i-1][j] - prices[j])
        
        return dp[k][n-1]
```

This solution uses dynamic programming to solve the problem. The `dp` table is used to store the maximum profit up to the i-th transaction on the j-th day. The `max_diff` variable helps in keeping track of the maximum difference we can achieve by selling on the j-th day after having bought on any of the previous days, considering the (i-1)-th transaction. This approach ensures that we do not engage in multiple transactions simultaneously and efficiently computes the maximum profit for at most k transactions.

Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
 
Example 1:

Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

Example 2:

Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

 
Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105

 
Follow up:

Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.
Could you do it in-place with O(1) extra space?



```python
from typing import List

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k % n  # In case k is greater than n
        
        # Helper function to reverse a portion of the array
        def reverse(start: int, end: int) -> None:
            while start < end:
                nums[start], nums[end] = nums[end], nums[start]
                start += 1
                end -= 1
        
        # Reverse the whole array
        reverse(0, n - 1)
        # Reverse the first k elements
        reverse(0, k - 1)
        # Reverse the remaining n-k elements
        reverse(k, n - 1)
```

This solution rotates the array in-place with O(1) extra space. It uses a helper function to reverse portions of the array, which allows us to achieve the desired rotation by reversing the entire array, then reversing the first k elements, and finally reversing the remaining n-k elements. This approach ensures that the array is rotated to the right by k steps as required.

Reverse bits of a given 32 bits unsigned integer.
Note:

Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.

 
Example 1:

Input: n = 00000010100101000001111010011100
Output:    964176192 (00111001011110000010100101000000)
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.

Example 2:

Input: n = 11111111111111111111111111111101
Output:   3221225471 (10111111111111111111111111111111)
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.

 
Constraints:

The input must be a binary string of length 32

 
Follow up: If this function is called many times, how would you optimize it?


```python
class Solution:
    def reverseBits(self, n: int) -> int:
        # Convert the integer to a binary string, remove the '0b' prefix, and pad with zeros to ensure it's 32 bits
        binary_str = format(n, '032b')
        # Reverse the binary string
        reversed_binary_str = binary_str[::-1]
        # Convert the reversed binary string back to an integer
        reversed_int = int(reversed_binary_str, 2)
        return reversed_int
```

This solution converts the given integer `n` to a 32-bit binary string, reverses the string, and then converts it back to an integer. The `format(n, '032b')` ensures that the binary representation is 32 bits long, padding with zeros if necessary. The slicing operation `[::-1]` is used to reverse the string. Finally, `int(reversed_binary_str, 2)` converts the reversed binary string back to an integer. 

For the follow-up question, if this function is called many times, you could consider using memoization to store previously computed results for a given input, which could save time if the same inputs are encountered multiple times. However, for bit manipulation like this, the overhead of memoization might not provide significant benefits unless the input space is very constrained and inputs are highly repetitive. Another approach could be to use bitwise operations directly in a loop to avoid string manipulations, which might be faster. Here is an optimized version using bitwise operations:

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        result = 0
        for _ in range(32):
            # Shift result to the left to make space for the next bit
            result <<= 1
            # Add the least significant bit of n to the result
            result |= n & 1
            # Shift n to the right to process the next bit
            n >>= 1
        return result
```

This version uses bitwise operations to reverse the bits without converting to and from strings, which can be more efficient.

Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).
 
Example 1:

Input: n = 11
Output: 3
Explanation:
The input binary string 1011 has a total of three set bits.

Example 2:

Input: n = 128
Output: 1
Explanation:
The input binary string 10000000 has a total of one set bit.

Example 3:

Input: n = 2147483645
Output: 30
Explanation:
The input binary string 1111111111111111111111111111101 has a total of thirty set bits.

 
Constraints:

1 <= n <= 231 - 1

 
Follow up: If this function is called many times, how would you optimize it?

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # Convert the integer to its binary representation and count the '1's
        return bin(n).count('1')
```

This solution converts the integer `n` to its binary representation using Python's built-in `bin()` function, which returns a string prefixed with '0b'. The `count('1')` method is then used to count the number of '1's in this binary string, which corresponds to the number of set bits (Hamming weight).

### Follow-up Optimization:
If this function is called many times, one way to optimize it is to use bit manipulation. This avoids the overhead of string conversion and counting. Here's an optimized version using bit manipulation:

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        while n:
            count += n & 1  # Increment count if the least significant bit is 1
            n >>= 1         # Right shift n by 1 to check the next bit
        return count
```

This version uses a loop to repeatedly check the least significant bit of `n` (using `n & 1`), increments the count if it is 1, and then right shifts `n` by one bit (`n >>= 1`) to process the next bit. This continues until `n` becomes zero. This method is efficient and works directly with the integer representation.

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
 
Example 1:

Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.

Example 2:

Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.

 
Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 400



```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]
        
        # Initialize the dp array
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        # Fill the dp array
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        
        # The last element of dp array will have the result
        return dp[-1]
```

This solution uses dynamic programming to solve the problem. The `dp` array keeps track of the maximum amount of money that can be robbed up to each house. For each house, the decision is made whether to rob it (adding its money to the maximum amount robbed up to two houses before) or to skip it (keeping the maximum amount robbed up to the previous house). The final result is the maximum amount of money that can be robbed up to the last house.

Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
 
Example 1:

Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
Explanation:


Example 2:

Input: root = [1,2,3,4,null,null,null,5]
Output: [1,3,4,5]
Explanation:


Example 3:

Input: root = [1,null,3]
Output: [1,3]

Example 4:

Input: root = []
Output: []

 
Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import List, Optional

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        result = []
        queue = [root]
        
        while queue:
            level_length = len(queue)
            for i in range(level_length):
                node = queue.pop(0)
                if i == level_length - 1:  # The last node in the current level
                    result.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        
        return result
```

This solution uses a breadth-first search (BFS) approach with a queue to traverse the binary tree level by level. For each level, it appends the value of the last node (which would be the rightmost node) to the result list.

Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
 
Example 1:

Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1

Example 2:

Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3

 
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 300
grid[i][j] is '0' or '1'.



```python
from typing import List

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        
        def dfs(i, j):
            # Check for boundary conditions and if the current cell is water
            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
                return
            # Mark the current cell as visited by setting it to '0'
            grid[i][j] = '0'
            # Perform DFS in all four possible directions
            dfs(i + 1, j)
            dfs(i - 1, j)
            dfs(i, j + 1)
            dfs(i, j - 1)
        
        num_islands = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':  # If the cell is land, it's an unvisited island
                    num_islands += 1
                    dfs(i, j)  # Perform DFS to mark the entire island as visited
        return num_islands
```

This solution uses Depth-First Search (DFS) to explore each island once it finds an unvisited piece of land ('1'). It marks all parts of the island as visited by setting them to '0'. The function iterates over the entire grid, and for each '1' found, it increments the island count and performs a DFS to mark the island. This ensures that each island is counted exactly once.

Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.
 
Example 1:

Input: left = 5, right = 7
Output: 4

Example 2:

Input: left = 0, right = 0
Output: 0

Example 3:

Input: left = 1, right = 2147483647
Output: 0

 
Constraints:

0 <= left <= right <= 231 - 1



```python
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        shift = 0
        # Find the common prefix bits
        while left < right:
            left >>= 1
            right >>= 1
            shift += 1
        # Append zeros to the right
        return left << shift
```

This solution works by shifting both `left` and `right` to the right until they are equal, effectively finding the common prefix of their binary representations. The number of shifts is recorded. Finally, the common prefix is shifted back to the left by the number of shifts to get the result. This approach efficiently computes the bitwise AND of all numbers in the range.

Write an algorithm to determine if a number n is happy.
A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.

Return true if n is a happy number, and false if not.
 
Example 1:

Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

Example 2:

Input: n = 2
Output: false

 
Constraints:

1 <= n <= 231 - 1



```python
class Solution:
    def isHappy(self, n: int) -> bool:
        def get_next(number):
            total_sum = 0
            while number > 0:
                digit = number % 10
                number = number // 10
                total_sum += digit * digit
            return total_sum
        
        seen = set()
        while n != 1 and n not in seen:
            seen.add(n)
            n = get_next(n)
        
        return n == 1
```

This solution uses a helper function `get_next` to calculate the sum of the squares of the digits of a number. It then uses a set `seen` to keep track of numbers that have already been encountered to detect cycles. If the process reaches 1, the number is happy; otherwise, if a cycle is detected (i.e., a number repeats), the number is not happy.

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
 
Example 1:


Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]

Example 2:

Input: head = [], val = 1
Output: []

Example 3:

Input: head = [7,7,7,7], val = 7
Output: []

 
Constraints:

The number of nodes in the list is in the range [0, 104].
1 <= Node.val <= 50
0 <= val <= 50



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        # Create a dummy node that points to the head of the list
        dummy = ListNode(next=head)
        current = dummy
        
        # Traverse the list
        while current.next:
            if current.next.val == val:
                # Skip the node with the target value
                current.next = current.next.next
            else:
                # Move to the next node
                current = current.next
        
        # Return the new head of the list
        return dummy.next
```

This solution uses a dummy node to handle edge cases, such as when the head node itself needs to be removed. The `current` pointer is used to traverse the list, and nodes with the target value are skipped by adjusting the `next` pointer of the `current` node.

Given an integer n, return the number of prime numbers that are strictly less than n.
 
Example 1:

Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.

Example 2:

Input: n = 0
Output: 0

Example 3:

Input: n = 1
Output: 0

 
Constraints:

0 <= n <= 5 * 106



```python
class Solution:
    def countPrimes(self, n: int) -> int:
        if n <= 2:
            return 0
        
        # Initialize a list to track prime status of numbers from 0 to n-1
        is_prime = [True] * n
        is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers
        
        # Use the Sieve of Eratosthenes algorithm
        for start in range(2, int(n**0.5) + 1):
            if is_prime[start]:
                for multiple in range(start*start, n, start):
                    is_prime[multiple] = False
        
        # Count the number of primes
        return sum(is_prime)
```

This solution implements the Sieve of Eratosthenes algorithm, which is efficient for finding all prime numbers up to a given limit. The time complexity is \(O(n \log \log n)\), making it suitable for the upper constraint of \(n \leq 5 \times 10^6\).

Given two strings s and t, determine if they are isomorphic.
Two strings s and t are isomorphic if the characters in s can be replaced to get t.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.
 
Example 1:

Input: s = "egg", t = "add"
Output: true
Explanation:
The strings s and t can be made identical by:

Mapping 'e' to 'a'.
Mapping 'g' to 'd'.


Example 2:

Input: s = "foo", t = "bar"
Output: false
Explanation:
The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.

Example 3:

Input: s = "paper", t = "title"
Output: true

 
Constraints:

1 <= s.length <= 5 * 104
t.length == s.length
s and t consist of any valid ascii character.



```python
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        # Dictionaries to store the mapping of characters from s to t and vice versa
        mapping_s_to_t = {}
        mapping_t_to_s = {}
        
        # Iterate over the characters of both strings
        for char_s, char_t in zip(s, t):
            # Check if there is a conflicting mapping from s to t
            if char_s in mapping_s_to_t:
                if mapping_s_to_t[char_s] != char_t:
                    return False
            else:
                mapping_s_to_t[char_s] = char_t
            
            # Check if there is a conflicting mapping from t to s
            if char_t in mapping_t_to_s:
                if mapping_t_to_s[char_t] != char_s:
                    return False
            else:
                mapping_t_to_s[char_t] = char_s
        
        # If no conflicts were found, the strings are isomorphic
        return True
```

Given the head of a singly linked list, reverse the list, and return the reversed list.
 
Example 1:


Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Example 2:


Input: head = [1,2]
Output: [2,1]

Example 3:

Input: head = []
Output: []

 
Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000

 
Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Iterative approach
        prev = None
        current = head
        while current:
            next_node = current.next  # Store the next node
            current.next = prev       # Reverse the current node's pointer
            prev = current            # Move pointers one position ahead
            current = next_node
        return prev

    def reverseListRecursive(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Base case: if head is empty or only one node, return it
        if not head or not head.next:
            return head
        # Recursively reverse the rest of the list
        new_head = self.reverseListRecursive(head.next)
        # Reverse the current node's pointer
        head.next.next = head
        head.next = None
        return new_head
```

This solution includes both the iterative and recursive methods to reverse a singly linked list. The `reverseList` method implements the iterative approach, while the `reverseListRecursive` method implements the recursive approach. Both methods return the head of the reversed list.

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.

Return true if you can finish all courses. Otherwise, return false.
 
Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.

Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

 
Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
All the pairs prerequisites[i] are unique.



```python
from typing import List

class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        from collections import defaultdict, deque
        
        # Create a graph
        graph = defaultdict(list)
        in_degree = [0] * numCourses
        
        # Build the graph
        for course, prereq in prerequisites:
            graph[prereq].append(course)
            in_degree[course] += 1
        
        # Add all courses with no prerequisites to the queue
        queue = deque([course for course in range(numCourses) if in_degree[course] == 0])
        
        # Process the queue
        while queue:
            course = queue.popleft()
            numCourses -= 1
            for next_course in graph[course]:
                in_degree[next_course] -= 1
                if in_degree[next_course] == 0:
                    queue.append(next_course)
        
        return numCourses == 0
```

This solution uses a topological sorting approach with Kahn's algorithm to detect cycles in the directed graph represented by the courses and their prerequisites. If we can process all courses (i.e., `numCourses` becomes 0), it means there are no cycles, and we can finish all courses. If not, there's a cycle, and we cannot finish all courses.

Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.
 
Example 1:

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

Example 2:

Input: target = 4, nums = [1,4,4]
Output: 1

Example 3:

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

 
Constraints:

1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104

 
Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).

To solve this problem, we can use the sliding window technique to achieve an O(n) time complexity. The idea is to maintain a window that expands to include more elements if the sum is less than the target and contracts if the sum is greater than or equal to the target. This way, we can find the minimal length of a subarray whose sum is greater than or equal to the target.

Here is the implementation of the solution:

```python
from typing import List

class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        current_sum = 0
        min_length = float('inf')
        
        for right in range(len(nums)):
            current_sum += nums[right]
            
            while current_sum >= target:
                min_length = min(min_length, right - left + 1)
                current_sum -= nums[left]
                left += 1
        
        return min_length if min_length != float('inf') else 0
```

### Explanation:
1. **Initialization**: We initialize `left` pointer to the start of the array, `current_sum` to 0, and `min_length` to infinity (`float('inf')`).

2. **Expand the Window**: We iterate over the array with the `right` pointer, adding `nums[right]` to `current_sum`.

3. **Contract the Window**: Whenever `current_sum` is greater than or equal to `target`, we update `min_length` to be the minimum of its current value and the length of the current window (`right - left + 1`). Then, we subtract `nums[left]` from `current_sum` and move the `left` pointer to the right to try and find a smaller subarray.

4. **Return the Result**: After the loop, if `min_length` is still infinity, it means no subarray was found that meets the condition, so we return 0. Otherwise, we return `min_length`.

This solution ensures that each element is processed at most twice (once by the `right` pointer and once by the `left` pointer), resulting in an O(n) time complexity.

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.

Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.
 
Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].

Example 2:

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].

Example 3:

Input: numCourses = 1, prerequisites = []
Output: [0]

 
Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= numCourses * (numCourses - 1)
prerequisites[i].length == 2
0 <= ai, bi < numCourses
ai != bi
All the pairs [ai, bi] are distinct.



```python
from collections import defaultdict, deque
from typing import List

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # Create a graph and in-degree array
        graph = defaultdict(list)
        in_degree = [0] * numCourses
        
        # Build the graph and fill in-degree array
        for course, prereq in prerequisites:
            graph[prereq].append(course)
            in_degree[course] += 1
        
        # Initialize the queue with all courses having 0 in-degree
        queue = deque([course for course in range(numCourses) if in_degree[course] == 0])
        result = []
        
        # Process nodes in the queue
        while queue:
            course = queue.popleft()
            result.append(course)
            
            # Decrease the in-degree of adjacent courses
            for neighbor in graph[course]:
                in_degree[neighbor] -= 1
                # If in-degree becomes 0, add to the queue
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        # If we have processed all courses, return the result
        return result if len(result) == numCourses else []
```

This solution uses a topological sort approach with Kahn's algorithm to find a valid order of courses. It first constructs the graph and in-degree array from the prerequisites, then uses a queue to process nodes with zero in-degree, adding them to the result list and reducing the in-degree of their neighbors. If the result list contains all courses, it is returned; otherwise, an empty list is returned, indicating that it's impossible to complete all courses due to a cycle.

Given an m x n board of characters and a list of strings words, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
 
Example 1:


Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]

Example 2:


Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []

 
Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 12
board[i][j] is a lowercase English letter.
1 <= words.length <= 3 * 104
1 <= words[i].length <= 10
words[i] consists of lowercase English letters.
All the strings of words are unique.



```python
from typing import List, Tuple
from itertools import pairwise

class Trie:
    def __init__(self):
        self.children: List[Trie | None] = [None] * 26
        self.ref: int = -1

    def insert(self, w: str, ref: int):
        node = self
        for c in w:
            idx = ord(c) - ord('a')
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.ref = ref

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        def dfs(node: Trie, i: int, j: int):
            idx = ord(board[i][j]) - ord('a')
            if node.children[idx] is None:
                return
            node = node.children[idx]
            if node.ref >= 0:
                ans.append(words[node.ref])
                node.ref = -1
            c = board[i][j]
            board[i][j] = '#'
            for a, b in pairwise((-1, 0, 1, 0, -1)):
                x, y = i + a, j + b
                if 0 <= x < m and 0 <= y < n and board[x][y] != '#':
                    dfs(node, x, y)
            board[i][j] = c

        tree = Trie()
        for i, w in enumerate(words):
            tree.insert(w, i)
        m, n = len(board), len(board[0])
        ans = []
        for i in range(m):
            for j in range(n):
                dfs(tree, i, j)
        return ans
```

This solution uses a Trie data structure to efficiently store the list of words and then performs a depth-first search (DFS) on the board to find all the words. The `dfs` function checks each cell and its neighbors recursively, marking cells as visited with `'#'` to avoid reusing them in the same word path. If a word is found, it is added to the result list and its reference in the Trie is set to `-1` to prevent duplicate findings.

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
 
Example 1:

Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.

Example 2:

Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.

Example 3:

Input: nums = [1,2,3]
Output: 3

 
Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 1000



```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]
        
        # Helper function to rob a linear sequence of houses
        def rob_linear(houses: List[int]) -> int:
            if not houses:
                return 0
            if len(houses) == 1:
                return houses[0]
            
            prev1, prev2 = 0, 0
            for amount in houses:
                current = max(prev2 + amount, prev1)
                prev2 = prev1
                prev1 = current
            return prev1
        
        # Rob houses excluding the last one or excluding the first one
        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))
```

This solution addresses the problem by considering two scenarios: one where the first house is not robbed (hence we consider houses from the second to the last), and the other where the last house is not robbed (hence we consider houses from the first to the second last). The maximum of these two scenarios will give the desired result. The `rob_linear` function is a helper function that solves the linear house robbing problem, which is a variation of the classic "House Robber" problem.

You are given a string s. You can convert s to a palindrome by adding characters in front of it.
Return the shortest palindrome you can find by performing this transformation.
 
Example 1:
Input: s = "aacecaaa"
Output: "aaacecaaa"
Example 2:
Input: s = "abcd"
Output: "dcbabcd"

 
Constraints:

0 <= s.length <= 5 * 104
s consists of lowercase English letters only.



```python
class Solution:
    def shortestPalindrome(self, s: str) -> str:
        # Helper function to find the longest palindromic prefix
        def longest_palindromic_prefix(s):
            n = len(s)
            rev_s = s[::-1]
            # Create a new string which is s + '#' + reverse of s
            new_s = s + '#' + rev_s
            # Create a LPS (Longest Prefix Suffix) array
            lps = [0] * len(new_s)
            # Build the LPS array
            for i in range(1, len(new_s)):
                j = lps[i - 1]
                while j > 0 and new_s[i] != new_s[j]:
                    j = lps[j - 1]
                if new_s[i] == new_s[j]:
                    j += 1
                lps[i] = j
            # The length of the longest palindromic prefix
            return lps[-1]
        
        # Find the longest palindromic prefix
        lpp_length = longest_palindromic_prefix(s)
        # Characters to add in front to make the whole string a palindrome
        to_add = s[lpp_length:][::-1]
        # Return the shortest palindrome
        return to_add + s
```

This solution uses the concept of the longest palindromic prefix and the Knuth-Morris-Pratt (KMP) algorithm's LPS (Longest Prefix Suffix) array to efficiently find the shortest palindrome that can be formed by adding characters to the front of the given string.

Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Can you solve it without sorting?
 
Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4

 
Constraints:

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104



To solve the problem of finding the kth largest element in an array without sorting, we can use a min-heap (or priority queue). The idea is to maintain a heap of size k. By iterating through the array, we can ensure that the heap always contains the k largest elements seen so far, with the smallest of these k elements at the root of the heap. This way, the root of the heap will be the kth largest element in the array.

Here's the implementation using Python's `heapq` module:

```python
from typing import List
import heapq

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # Create a min-heap with the first k elements
        min_heap = nums[:k]
        heapq.heapify(min_heap)
        
        # Iterate over the remaining elements
        for num in nums[k:]:
            # If the current number is larger than the smallest in the heap, replace it
            if num > min_heap[0]:
                heapq.heappushpop(min_heap, num)
        
        # The root of the heap is the kth largest element
        return min_heap[0]
```

### Explanation:
1. **Heap Initialization**: We start by creating a min-heap with the first `k` elements of the array. This can be done using `heapq.heapify`, which transforms the list into a heap in-place.
2. **Heap Maintenance**: We iterate through the remaining elements of the array. For each element, if it is larger than the smallest element in the heap (the root of the heap), we replace the root with the current element using `heapq.heappushpop`. This operation ensures that the heap always contains the `k` largest elements seen so far.
3. **Result Extraction**: After processing all elements, the root of the heap (`min_heap[0]`) is the kth largest element in the array.

This approach is efficient with a time complexity of \(O(n \log k)\), where \(n\) is the number of elements in the array. This is because each insertion or removal operation on the heap takes \(O(\log k)\) time, and we perform such operations \(n-k\) times. The space complexity is \(O(k)\) for storing the heap.

Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

Only numbers 1 through 9 are used.
Each number is used at most once.

Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.
 
Example 1:

Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
Example 2:

Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.

Example 3:

Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.

 
Constraints:

2 <= k <= 9
1 <= n <= 60



```python
from typing import List

class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        def backtrack(start, path, target, k):
            if k == 0:
                if target == 0:
                    result.append(path)
                return
            for i in range(start, 10):
                if i > target:
                    break
                backtrack(i + 1, path + [i], target - i, k - 1)
        
        result = []
        backtrack(1, [], n, k)
        return result

# Example usage:
# sol = Solution()
# print(sol.combinationSum3(3, 7))  # Output: [[1,2,4]]
# print(sol.combinationSum3(3, 9))  # Output: [[1,2,6],[1,3,5],[2,3,4]]
# print(sol.combinationSum3(4, 1))  # Output: []
```

This solution uses a backtracking approach to explore all possible combinations of numbers from 1 to 9 that sum up to `n` and consist of exactly `k` numbers. The `backtrack` function is a recursive helper that builds combinations starting from a given number, ensuring each number is used at most once. The function prunes the search space by stopping early if the current number exceeds the remaining target sum.

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
 
Example 1:

Input: nums = [1,2,3,1]
Output: true
Explanation:
The element 1 occurs at the indices 0 and 3.

Example 2:

Input: nums = [1,2,3,4]
Output: false
Explanation:
All elements are distinct.

Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

 
Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109



```python
from typing import List

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        # Use a set to track seen numbers
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False
```

This solution uses a set to keep track of the numbers we have already seen as we iterate through the list. If we encounter a number that is already in the set, we return `True` because it means the number appears at least twice. If we finish iterating through the list without finding any duplicates, we return `False`. This approach is efficient with a time complexity of O(n) and a space complexity of O(n).

A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.
The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:

lefti is the x coordinate of the left edge of the ith building.
righti is the x coordinate of the right edge of the ith building.
heighti is the height of the ith building.

You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.
The skyline should be represented as a list of "key points" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.
Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]
 
Example 1:


Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
Explanation:
Figure A shows the buildings of the input.
Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.

Example 2:

Input: buildings = [[0,2,3],[2,5,3]]
Output: [[0,3],[5,0]]

 
Constraints:

1 <= buildings.length <= 104
0 <= lefti < righti <= 231 - 1
1 <= heighti <= 231 - 1
buildings is sorted by lefti in non-decreasing order.



To solve the problem of finding the skyline formed by a set of buildings, we need to consider the critical points where the skyline changes, which are the left and right edges of the buildings. We can use a combination of sorting and a max-heap to efficiently process these points and determine the height of the skyline at each critical point.

Here's a step-by-step breakdown of the solution:

1. **Critical Points**: Extract the unique x-coordinates from the buildings (both the left and right edges). These will be the points where the height of the skyline can change.
2. **Heap for Heights**: Use a max-heap to keep track of the heights of buildings that are currently active (i.e., buildings that have started but not yet ended).
3. **Iterate Over Critical Points**: For each critical point, update the active buildings in the heap:
   - Remove buildings that end before the current critical point.
   - Add buildings that start at the current critical point.
   - Determine the highest building in the heap (this will be the height of the skyline at the current critical point).
   - If the height changes, add this point to the result set.

4. **Result Construction**: The result set will contain the key points of the skyline, ensuring there are no consecutive points with the same height.

Here is the complete implementation:

```python
from typing import List
import heapq

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        # Create a list of all the critical points (start and end of buildings)
        critical_points = set()
        for left, right, height in buildings:
            critical_points.add(left)
            critical_points.add(right)
        
        # Convert the set to a sorted list
        critical_points = sorted(critical_points)
        
        # Create a list of events, where each event is (left, -height, right) for start points
        # and (right, 0, 0) for end points. The negative height ensures that start points
        # are processed before end points when they share the same x-coordinate.
        events = []
        for left, right, height in buildings:
            events.append((left, -height, right))
        
        # Sort events by x-coordinate. If two events have the same x-coordinate,
        # start points (negative height) come before end points (height 0).
        events.sort()
        
        # Initialize a max-heap with a sentinel value of (0, float('inf')) to represent
        # the ground level.
        max_heap = [(0, float('inf'))]
        
        # List to store the result skyline points
        result = []
        
        # Index to track the current position in the events list
        event_idx = 0
        n = len(events)
        
        # Iterate over each critical point
        for point in critical_points:
            # Process all events that happen at the current critical point
            while event_idx < n and events[event_idx][0] == point:
                _, height, right = events[event_idx]
                # Push the height (negative) and right boundary of the building into the heap
                heapq.heappush(max_heap, (height, right))
                event_idx += 1
            
            # Remove buildings from the heap that have ended before the current critical point
            while max_heap[0][1] <= point:
                heapq.heappop(max_heap)
            
            # The current maximum height in the heap is the height of the skyline at this point
            current_height = -max_heap[0][0]
            
            # If the current height is different from the last height in the result,
            # add it to the result skyline
            if not result or result[-1][1] != current_height:
                result.append([point, current_height])
        
        return result

# Example usage:
# sol = Solution()
# print(sol.getSkyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]))
```

This code efficiently computes the skyline by leveraging the properties of heaps to manage the active buildings and their heights, ensuring the solution is both correct and performant for the given constraints.

Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
 
Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true

Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true

Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false

 
Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109
0 <= k <= 105



```python
from typing import List

class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        # Dictionary to store the last seen index of each number
        last_seen = {}
        
        for i, num in enumerate(nums):
            if num in last_seen and abs(i - last_seen[num]) <= k:
                return True
            last_seen[num] = i
        
        return False
```

This solution uses a dictionary to keep track of the last seen index of each number. As we iterate through the list, we check if the current number has been seen before and if the difference between the current index and the last seen index is less than or equal to `k`. If both conditions are met, we return `True`. If we finish the loop without finding such a pair, we return `False`. This approach ensures that we only traverse the list once, making it efficient with a time complexity of O(n).

You are given an integer array nums and two integers indexDiff and valueDiff.
Find a pair of indices (i, j) such that:

i != j,
abs(i - j) <= indexDiff.
abs(nums[i] - nums[j]) <= valueDiff, and

Return true if such pair exists or false otherwise.
 
Example 1:

Input: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0
Output: true
Explanation: We can choose (i, j) = (0, 3).
We satisfy the three conditions:
i != j --> 0 != 3
abs(i - j) <= indexDiff --> abs(0 - 3) <= 3
abs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0

Example 2:

Input: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3
Output: false
Explanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.

 
Constraints:

2 <= nums.length <= 105
-109 <= nums[i] <= 109
1 <= indexDiff <= nums.length
0 <= valueDiff <= 109



```python
from sortedcontainers import SortedSet

class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:
        # This will store the numbers in a sorted order
        sorted_set = SortedSet()
        
        for i, num in enumerate(nums):
            # Find the smallest number >= nums[i] - valueDiff
            ceil_index = sorted_set.bisect_left(num - valueDiff)
            
            # Check if this number satisfies the condition abs(nums[i] - nums[j]) <= valueDiff
            if ceil_index < len(sorted_set) and sorted_set[ceil_index] <= num + valueDiff:
                return True
            
            # Add the current number to the sorted set
            sorted_set.add(num)
            
            # Maintain the window size of indexDiff
            if i >= indexDiff:
                sorted_set.remove(nums[i - indexDiff])
        
        return False
```

This solution uses a `SortedSet` from the `sortedcontainers` module to maintain a window of the last `indexDiff` numbers in sorted order. The `bisect_left` method is used to find the smallest number in the set that is greater than or equal to `nums[i] - valueDiff`. If such a number is found and it is less than or equal to `nums[i] + valueDiff`, then we have found a pair that satisfies the conditions. The set is updated by adding the current number and removing the number that falls out of the window as we iterate through the list.

Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.
 
Example 1:


Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4

Example 2:


Input: matrix = [["0","1"],["1","0"]]
Output: 1

Example 3:

Input: matrix = [["0"]]
Output: 0

 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] is '0' or '1'.



```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        max_side = 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if matrix[i - 1][j - 1] == '1':
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    max_side = max(max_side, dp[i][j])
        
        return max_side ** 2
```

This solution uses dynamic programming to solve the problem. The `dp` table is used to store the size of the largest square ending at each cell. If the current cell contains a '1', the size of the largest square ending at that cell is one plus the minimum of the sizes of the squares ending at the cell above, the cell to the left, and the cell diagonally above and to the left. The result is the area of the largest square found, which is the square of `max_side`.

Given the root of a complete binary tree, return the number of the nodes in the tree.
According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.
Design an algorithm that runs in less than O(n) time complexity.
 
Example 1:


Input: root = [1,2,3,4,5,6]
Output: 6

Example 2:

Input: root = []
Output: 0

Example 3:

Input: root = [1]
Output: 1

 
Constraints:

The number of nodes in the tree is in the range [0, 5 * 104].
0 <= Node.val <= 5 * 104
The tree is guaranteed to be complete.



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)

```

Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.
The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2).
The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).
 
Example 1:


Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
Output: 45

Example 2:

Input: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
Output: 16

 
Constraints:

-104 <= ax1 <= ax2 <= 104
-104 <= ay1 <= ay2 <= 104
-104 <= bx1 <= bx2 <= 104
-104 <= by1 <= by2 <= 104



```python
class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        # Calculate the area of the first rectangle
        area1 = (ax2 - ax1) * (ay2 - ay1)
        
        # Calculate the area of the second rectangle
        area2 = (bx2 - bx1) * (by2 - by1)
        
        # Calculate the overlap in the x-dimension
        overlap_x = max(0, min(ax2, bx2) - max(ax1, bx1))
        
        # Calculate the overlap in the y-dimension
        overlap_y = max(0, min(ay2, by2) - max(ay1, by1))
        
        # Calculate the area of the overlap
        overlap_area = overlap_x * overlap_y
        
        # Total area is the sum of the areas minus the overlap
        total_area = area1 + area2 - overlap_area
        
        return total_area
```

This solution calculates the area of each rectangle individually and then subtracts the area of their overlap, if any. The overlap is determined by finding the intersection in both the x and y dimensions. If there is no overlap, the intersection dimensions will be zero, resulting in no area subtraction.

Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
 
Example 1:

Input: s = "1 + 1"
Output: 2

Example 2:

Input: s = " 2-1 + 2 "
Output: 3

Example 3:

Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23

 
Constraints:

1 <= s.length <= 3 * 105
s consists of digits, '+', '-', '(', ')', and ' '.
s represents a valid expression.
'+' is not used as a unary operation (i.e., "+1" and "+(2 + 3)" is invalid).
'-' could be used as a unary operation (i.e., "-1" and "-(2 + 3)" is valid).
There will be no two consecutive operators in the input.
Every number and running calculation will fit in a signed 32-bit integer.



```python
class Solution:
    def calculate(self, s: str) -> int:
        stk = []
        ans, sign = 0, 1
        i, n = 0, len(s)
        while i < n:
            if s[i].isdigit():
                x = 0
                j = i
                while j < n and s[j].isdigit():
                    x = x * 10 + int(s[j])
                    j += 1
                ans += sign * x
                i = j - 1
            elif s[i] == "+":
                sign = 1
            elif s[i] == "-":
                sign = -1
            elif s[i] == "(":
                stk.append(ans)
                stk.append(sign)
                ans, sign = 0, 1
            elif s[i] == ")":
                ans = stk.pop() * ans + stk.pop()
            i += 1
        return ans
```

Given the root of a binary tree, invert the tree, and return its root.
 
Example 1:


Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]

Example 2:


Input: root = [2,1,3]
Output: [2,3,1]

Example 3:

Input: root = []
Output: []

 
Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return None
        
        # Swap the left and right children
        root.left, root.right = root.right, root.left
        
        # Recursively invert the left subtree
        self.invertTree(root.left)
        
        # Recursively invert the right subtree
        self.invertTree(root.right)
        
        return root
```

Given a string s which represents an expression, evaluate this expression and return its value. 
The integer division should truncate toward zero.
You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().
 
Example 1:
Input: s = "3+2*2"
Output: 7
Example 2:
Input: s = " 3/2 "
Output: 1
Example 3:
Input: s = " 3+5 / 2 "
Output: 5

 
Constraints:

1 <= s.length <= 3 * 105
s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.
s represents a valid expression.
All the integers in the expression are non-negative integers in the range [0, 231 - 1].
The answer is guaranteed to fit in a 32-bit integer.



```python
class Solution:
    def calculate(self, s: str) -> int:
        def update(op, num):
            if op == '+':
                stack.append(num)
            elif op == '-':
                stack.append(-num)
            elif op == '*':
                stack.append(stack.pop() * num)
            elif op == '/':
                # Integer division that truncates toward zero
                stack.append(int(stack.pop() / num))

        stack = []
        num = 0
        op = '+'

        for i, char in enumerate(s):
            if char.isdigit():
                num = num * 10 + int(char)
            
            if char in '+-*/' or i == len(s) - 1:
                update(op, num)
                op = char
                num = 0

        return sum(stack)
```

This solution processes the string `s` character by character, building numbers and applying operators as it goes. It uses a stack to keep track of the intermediate results, applying multiplication and division immediately when encountered, and deferring addition and subtraction until the end. This ensures that the operations are performed with the correct precedence.

You are given a sorted unique integer array nums.
A range [a,b] is the set of all integers from a to b (inclusive).
Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.
Each range [a,b] in the list should be output as:

"a->b" if a != b
"a" if a == b

 
Example 1:

Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"

Example 2:

Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"

 
Constraints:

0 <= nums.length <= 20
-231 <= nums[i] <= 231 - 1
All the values of nums are unique.
nums is sorted in ascending order.



```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        if not nums:
            return []
        
        ranges = []
        start = nums[0]
        end = nums[0]
        
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1] + 1:
                end = nums[i]
            else:
                if start == end:
                    ranges.append(f"{start}")
                else:
                    ranges.append(f"{start}->{end}")
                start = nums[i]
                end = nums[i]
        
        # Add the last range
        if start == end:
            ranges.append(f"{start}")
        else:
            ranges.append(f"{start}->{end}")
        
        return ranges
```

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
 
Example 1:

Input: nums = [3,2,3]
Output: [3]

Example 2:

Input: nums = [1]
Output: [1]

Example 3:

Input: nums = [1,2]
Output: [1,2]

 
Constraints:

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109

 
Follow up: Could you solve the problem in linear time and in O(1) space?


```python
from typing import List

class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        n1 = n2 = 0
        m1, m2 = 0, 1
        for m in nums:
            if m == m1:
                n1 += 1
            elif m == m2:
                n2 += 1
            elif n1 == 0:
                m1, n1 = m, 1
            elif n2 == 0:
                m2, n2 = m, 1
            else:
                n1, n2 = n1 - 1, n2 - 1
        return [m for m in [m1, m2] if nums.count(m) > len(nums) // 3]
```

This solution implements the Boyer-Moore Voting Algorithm, which allows finding all elements that appear more than ⌊ n/3 ⌋ times in linear time and with constant space complexity. The algorithm maintains two potential candidates for majority elements and their counts, updating them as it iterates through the list. After the first pass, it verifies the candidates by counting their occurrences in the list to ensure they meet the criteria.

Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.
 
Example 1:


Input: root = [3,1,4,null,2], k = 1
Output: 1

Example 2:


Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3

 
Constraints:

The number of nodes in the tree is n.
1 <= k <= n <= 104
0 <= Node.val <= 104

 
Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stk = []
        while root or stk:
            if root:
                stk.append(root)
                root = root.left
            else:
                root = stk.pop()
                k -= 1
                if k == 0:
                    return root.val
                root = root.right
```

This solution uses an iterative in-order traversal approach to find the kth smallest element in a binary search tree. The in-order traversal of a BST visits nodes in ascending order, so the kth node visited is the kth smallest. The use of a stack allows us to traverse the tree without recursion, making it efficient in terms of space complexity. 

For the follow-up question, if the BST is modified often and we need to find the kth smallest element frequently, one optimization strategy would be to augment the tree nodes to store the size of their respective subtrees. This way, we can determine the rank of any node in constant time, and use this information to guide our search for the kth smallest element, reducing the average time complexity from O(h) to O(log n) for balanced trees.

Given an integer n, return true if it is a power of two. Otherwise, return false.
An integer n is a power of two, if there exists an integer x such that n == 2x.
 
Example 1:

Input: n = 1
Output: true
Explanation: 20 = 1

Example 2:

Input: n = 16
Output: true
Explanation: 24 = 16

Example 3:

Input: n = 3
Output: false

 
Constraints:

-231 <= n <= 231 - 1

 
Follow up: Could you solve it without loops/recursion?

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        return n & (n - 1) == 0
```

### Explanation:
The solution provided checks if a given integer `n` is a power of two without using loops or recursion. The key insight is based on the binary representation of powers of two. A power of two in binary form has exactly one bit set to `1` and all other bits set to `0`. For example:
- 1 (2^0) is `0001`
- 2 (2^1) is `0010`
- 4 (2^2) is `0100`
- 8 (2^3) is `1000`

If you subtract 1 from a power of two, you get a number with all bits set to `1` up to the position of the `1` bit in the original number. For example:
- 1 (2^0) - 1 = 0 (0000)
- 2 (2^1) - 1 = 1 (0001)
- 4 (2^2) - 1 = 3 (0011)
- 8 (2^3) - 1 = 7 (0111)

The bitwise AND of a power of two `n` and `n-1` will be zero because they have no bits in common set to `1`. This property is used to determine if `n` is a power of two. Additionally, we check if `n` is greater than zero because non-positive numbers cannot be powers of two.

Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.
 
Example 1:

Input: n = 13
Output: 6

Example 2:

Input: n = 0
Output: 0

 
Constraints:

0 <= n <= 109



```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        count = 0
        factor = 1
        while factor <= n:
            lower_nums = n - (n // factor) * factor
            cur_num = (n // factor) % 10
            higher_nums = n // (factor * 10)
            
            if cur_num == 0:
                count += higher_nums * factor
            elif cur_num == 1:
                count += higher_nums * factor + lower_nums + 1
            else:
                count += (higher_nums + 1) * factor
            
            factor *= 10
        
        return count
```

Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
 
Example 1:


Input: head = [1,2,2,1]
Output: true

Example 2:


Input: head = [1,2]
Output: false

 
Constraints:

The number of nodes in the list is in the range [1, 105].
0 <= Node.val <= 9

 
Follow up: Could you do it in O(n) time and O(1) space?

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return True
        
        # Find the middle of the linked list
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        # Reverse the second half of the list
        prev = None
        while slow:
            next_node = slow.next
            slow.next = prev
            prev = slow
            slow = next_node
        
        # Check if the first half and the reversed second half are the same
        first_half = head
        second_half = prev
        while second_half:  # Only need to check until the end of the reversed second half
            if first_half.val != second_half.val:
                return False
            first_half = first_half.next
            second_half = second_half.next
        
        return True
```

This solution achieves the goal of checking if a singly linked list is a palindrome in O(n) time and O(1) space. It uses two main steps:

1. Finding the middle of the list using the slow and fast pointer technique.
2. Reversing the second half of the list and comparing it with the first half.

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
 
Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.

Example 2:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.

Example 3:

Input: root = [1,2], p = 1, q = 2
Output: 1

 
Constraints:

The number of nodes in the tree is in the range [2, 105].
-109 <= Node.val <= 109
All Node.val are unique.
p != q
p and q will exist in the tree.



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # Base case: if the root is None, or root is one of p or q, then root is the LCA
        if root is None or root == p or root == q:
            return root
        
        # Recurse on the left and right subtrees
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        # If both left and right are non-null, root is the LCA
        if left is not None and right is not None:
            return root
        
        # Otherwise, return the non-null child
        return left if left is not None else right
```

This solution uses a recursive approach to find the lowest common ancestor (LCA) of two nodes in a binary tree. The function checks if the current node is `None` or one of the nodes `p` or `q`. If so, it returns the current node. It then recursively checks the left and right subtrees. If both subtrees return non-null values, it means `p` and `q` are found in different subtrees, and the current node is their LCA. If only one subtree returns a non-null value, it returns that value, indicating that both `p` and `q` are located in that subtree.

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
 
Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]

 
Constraints:

2 <= nums.length <= 105
-30 <= nums[i] <= 30
The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.

 
Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)


```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        answer = [1] * n
        
        # Calculate left products
        left_product = 1
        for i in range(n):
            answer[i] = left_product
            left_product *= nums[i]
        
        # Calculate right products and multiply with left products
        right_product = 1
        for i in range(n - 1, -1, -1):
            answer[i] *= right_product
            right_product *= nums[i]
        
        return answer
```

This solution calculates the product of all elements except the current one in O(n) time complexity and O(1) extra space complexity, excluding the output array. It does this by first calculating the product of all elements to the left of each index and storing it in the answer array. Then, it calculates the product of all elements to the right of each index and multiplies it with the corresponding value in the answer array.

You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.
Return the max sliding window.
 
Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

Example 2:

Input: nums = [1], k = 1
Output: [1]

 
Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length



To solve the problem of finding the maximum value in each sliding window of size `k` over an array `nums`, we can use a double-ended queue (deque) to keep track of the indices of the elements in the current window. This approach ensures that we can efficiently retrieve the maximum value for each window in O(n) time complexity.

Here's the solution using the provided starter code format:

```python
from collections import deque
from typing import List

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums or k == 0:
            return []
        
        # Deque to store indices of elements in the current window
        deq = deque()
        result = []
        
        for i in range(len(nums)):
            # Remove elements not within the sliding window
            if deq and deq[0] < i - k + 1:
                deq.popleft()
            
            # Remove elements smaller than the current element from the deque
            while deq and nums[deq[-1]] < nums[i]:
                deq.pop()
            
            # Add the current element's index to the deque
            deq.append(i)
            
            # The front of the deque is the largest element's index for the current window
            if i >= k - 1:
                result.append(nums[deq[0]])
        
        return result
```

### Explanation:
1. **Initialization**: We initialize an empty deque `deq` to store indices of elements in the current window and a list `result` to store the maximum values for each window.
2. **Iterate through the array**: For each element in `nums`:
   - **Remove out-of-bound indices**: If the index at the front of the deque is out of the current window (i.e., `deq[0] < i - k + 1`), we remove it.
   - **Maintain decreasing order in deque**: We remove all elements from the back of the deque that are smaller than the current element `nums[i]`. This ensures that the deque is always in decreasing order of element values.
   - **Add current index**: We add the current index `i` to the deque.
   - **Append maximum to result**: Once we have processed at least `k` elements, the front of the deque contains the index of the maximum element for the current window. We append this value to the result list.
3. **Return result**: After processing all elements, we return the result list containing the maximum values for each sliding window.

This approach ensures that each element is added and removed from the deque at most once, resulting in an overall time complexity of O(n).

Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.

 
Example 1:


Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true

Example 2:


Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false

 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= n, m <= 300
-109 <= matrix[i][j] <= 109
All the integers in each row are sorted in ascending order.
All the integers in each column are sorted in ascending order.
-109 <= target <= 109



```python
from typing import List

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False
        
        # Start from the top-right corner
        row, col = 0, len(matrix[0]) - 1
        
        while row < len(matrix) and col >= 0:
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] > target:
                col -= 1  # Move left
            else:
                row += 1  # Move down
        
        return False
```

This solution takes advantage of the sorted properties of the matrix. By starting from the top-right corner, we can eliminate a row or a column in each step, leading to an efficient O(m + n) time complexity, where m is the number of rows and n is the number of columns.

Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.
The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104.
 
Example 1:

Input: expression = "2-1-1"
Output: [0,2]
Explanation:
((2-1)-1) = 0 
(2-(1-1)) = 2

Example 2:

Input: expression = "2*3-4*5"
Output: [-34,-14,-10,-10,10]
Explanation:
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10

 
Constraints:

1 <= expression.length <= 20
expression consists of digits and the operator '+', '-', and '*'.
All the integer values in the input expression are in the range [0, 99].
The integer values in the input expression do not have a leading '-' or '+' denoting the sign.



```python
from typing import List

class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        # Helper function to perform the arithmetic operation
        def compute(left, right, operator):
            if operator == '+':
                return left + right
            elif operator == '-':
                return left - right
            elif operator == '*':
                return left * right
        
        # Base case: if the expression is a number, return it as the only result
        if expression.isdigit():
            return [int(expression)]
        
        results = []
        
        # Iterate through the expression to find operators
        for i in range(len(expression)):
            if expression[i] in "+-*":
                # Split the expression into left and right parts
                left_results = self.diffWaysToCompute(expression[:i])
                right_results = self.diffWaysToCompute(expression[i+1:])
                
                # Combine the results from the left and right parts using the current operator
                for left in left_results:
                    for right in right_results:
                        results.append(compute(left, right, expression[i]))
        
        return results
```

This solution uses a recursive approach to split the expression at each operator, computes the results for the left and right sub-expressions, and then combines them using the current operator. The base case handles when the expression is a single number.

Given two strings s and t, return true if t is an anagram of s, and false otherwise.
 
Example 1:

Input: s = "anagram", t = "nagaram"
Output: true

Example 2:

Input: s = "rat", t = "car"
Output: false

 
Constraints:

1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.

 
Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?


```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        # If the lengths of the strings are not the same, they cannot be anagrams
        if len(s) != len(t):
            return False
        
        # Create a dictionary to count the frequency of each character in s
        char_count = {}
        
        for char in s:
            if char in char_count:
                char_count[char] += 1
            else:
                char_count[char] = 1
        
        # Decrease the count based on characters in t
        for char in t:
            if char in char_count:
                char_count[char] -= 1
                if char_count[char] < 0:
                    return False
            else:
                return False
        
        # If all counts are zero, then t is an anagram of s
        return all(count == 0 for count in char_count.values())
```

This solution works by first checking if the lengths of the two strings are the same. If not, they cannot be anagrams. It then uses a dictionary to count the occurrences of each character in the first string `s`. For each character in the second string `t`, it decreases the count in the dictionary. If a character is not found or the count goes below zero, it returns `False`. Finally, it checks if all counts in the dictionary are zero, indicating that `t` is an anagram of `s`.

For the follow-up question regarding Unicode characters, the same solution would work without any modifications because Python's `str` type natively supports Unicode. The counting logic and dictionary operations remain valid for Unicode characters.

Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest distance between these two words in the list.
 
Example 1:

Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "coding", word2 = "practice"
Output: 3

Example 2:

Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
Output: 1

 
Constraints:

2 <= wordsDict.length <= 3 * 104
1 <= wordsDict[i].length <= 10
wordsDict[i] consists of lowercase English letters.
word1 and word2 are in wordsDict.
word1 != word2



```python
from typing import List
from math import inf

class Solution:
    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        i = j = -1
        ans = inf
        for k, w in enumerate(wordsDict):
            if w == word1:
                i = k
            if w == word2:
                j = k
            if i != -1 and j != -1:
                ans = min(ans, abs(i - j))
        return ans
```

Given an array of strings wordsDict and two strings that already exist in the array word1 and word2, return the shortest distance between the occurrence of these two words in the list.
Note that word1 and word2 may be the same. It is guaranteed that they represent two individual words in the list.
 
Example 1:
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
Output: 1
Example 2:
Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "makes"
Output: 3

 
Constraints:

1 <= wordsDict.length <= 105
1 <= wordsDict[i].length <= 10
wordsDict[i] consists of lowercase English letters.
word1 and word2 are in wordsDict.



```python
from typing import List

class Solution:
    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
        min_distance = float('inf')
        prev_word1 = -1
        prev_word2 = -1
        
        for i, word in enumerate(wordsDict):
            if word == word1:
                if word1 == word2:
                    if prev_word1 != -1:
                        min_distance = min(min_distance, i - prev_word1)
                else:
                    if prev_word2 != -1:
                        min_distance = min(min_distance, i - prev_word2)
                prev_word1 = i
            elif word == word2:
                if prev_word1 != -1:
                    min_distance = min(min_distance, i - prev_word1)
                prev_word2 = i
        
        return min_distance
```

This solution iterates through the `wordsDict` list and keeps track of the most recent positions of `word1` and `word2`. It updates the minimum distance whenever it finds an occurrence of either word and the other word has been seen before. The special case where `word1` and `word2` are the same is handled by updating the position of `word1` first and then checking the distance if the previous occurrence was also `word1`.

Given a string num which represents an integer, return true if num is a strobogrammatic number.
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
 
Example 1:

Input: num = "69"
Output: true

Example 2:

Input: num = "88"
Output: true

Example 3:

Input: num = "962"
Output: false

 
Constraints:

1 <= num.length <= 50
num consists of only digits.
num does not contain any leading zeros except for zero itself.



```python
class Solution:
    def isStrobogrammatic(self, num: str) -> bool:
        # Mapping of digits to their strobogrammatic counterparts
        strobogrammatic_map = {
            '0': '0',
            '1': '1',
            '6': '9',
            '8': '8',
            '9': '6'
        }
        
        # Reverse the number and check if each digit maps correctly
        rotated = []
        for digit in reversed(num):
            if digit not in strobogrammatic_map:
                return False
            rotated.append(strobogrammatic_map[digit])
        
        # Join the rotated list to form the rotated number string
        rotated_num = ''.join(rotated)
        
        # Check if the original number is the same as the rotated number
        return num == rotated_num
```

This code defines a method `isStrobogrammatic` that checks if a given string `num` is a strobogrammatic number. It uses a dictionary to map each digit to its strobogrammatic counterpart, reverses the input number, and checks if the reversed number, when transformed using the map, matches the original number.

Given an integer n, return all the strobogrammatic numbers that are of length n. You may return the answer in any order.
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
 
Example 1:
Input: n = 2
Output: ["11","69","88","96"]
Example 2:
Input: n = 1
Output: ["0","1","8"]

 
Constraints:

1 <= n <= 14



```python
from typing import List

class Solution:
    def findStrobogrammatic(self, n: int) -> List[str]:
        def dfs(u):
            if u == 0:
                return ['']
            if u == 1:
                return ['0', '1', '8']
            ans = []
            for v in dfs(u - 2):
                for l, r in ('11', '88', '69', '96'):
                    ans.append(l + v + r)
                if u != n:
                    ans.append('0' + v + '0')
            return ans

        return dfs(n)
```

This solution uses a depth-first search (DFS) approach to generate all strobogrammatic numbers of a given length `n`. The function `dfs(u)` generates all strobogrammatic numbers of length `u`. The base cases handle numbers of length 0 and 1. For other lengths, it recursively builds the numbers by adding strobogrammatic pairs around the results of `dfs(u - 2)`. Special care is taken to avoid leading zeros for numbers of length `n`.

Given two strings low and high that represent two integers low and high where low <= high, return the number of strobogrammatic numbers in the range [low, high].
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
 
Example 1:
Input: low = "50", high = "100"
Output: 3
Example 2:
Input: low = "0", high = "0"
Output: 1

 
Constraints:

1 <= low.length, high.length <= 15
low and high consist of only digits.
low <= high
low and high do not contain any leading zeros except for zero itself.



```python
class Solution:
    def strobogrammaticInRange(self, low: str, high: str) -> int:
        # Helper function to generate strobogrammatic numbers of a given length
        def generate(length, isFinal):
            if length == 0:
                return [""]
            if length == 1:
                return ["0", "1", "8"]
            
            middles = generate(length - 2, False)
            result = []
            for middle in middles:
                if not isFinal:
                    result.append("0" + middle + "0")
                result.append("1" + middle + "1")
                result.append("6" + middle + "9")
                result.append("8" + middle + "8")
                result.append("9" + middle + "6")
            return result
        
        # Count strobogrammatic numbers within the range
        def countStrobogrammatic(low, high):
            count = 0
            for length in range(len(low), len(high) + 1):
                for num in generate(length, True):
                    if (length == len(low) and num < low) or (length == len(high) and num > high):
                        continue
                    count += 1
            return count
        
        return countStrobogrammatic(low, high)
```

This solution generates all strobogrammatic numbers of lengths between the lengths of `low` and `high` and counts those that fall within the range `[low, high]`. The helper function `generate` creates strobogrammatic numbers of a specified length, and `countStrobogrammatic` uses this to count valid numbers within the given range.

Perform the following shift operations on a string:

Right shift: Replace every letter with the successive letter of the English alphabet, where 'z' is replaced by 'a'. For example, "abc" can be right-shifted to "bcd" or "xyz" can be right-shifted to "yza".
Left shift: Replace every letter with the preceding letter of the English alphabet, where 'a' is replaced by 'z'. For example, "bcd" can be left-shifted to "abc" or "yza" can be left-shifted to "xyz".

We can keep shifting the string in both directions to form an endless shifting sequence.

For example, shift "abc" to form the sequence: ... <-> "abc" <-> "bcd" <-> ... <-> "xyz" <-> "yza" <-> .... <-> "zab" <-> "abc" <-> ...

You are given an array of strings strings, group together all strings[i] that belong to the same shifting sequence. You may return the answer in any order.
 
Example 1:

Input: strings = ["abc","bcd","acef","xyz","az","ba","a","z"]
Output: [["acef"],["a","z"],["abc","bcd","xyz"],["az","ba"]]

Example 2:

Input: strings = ["a"]
Output: [["a"]]

 
Constraints:

1 <= strings.length <= 200
1 <= strings[i].length <= 50
strings[i] consists of lowercase English letters.



```python
from typing import List
from collections import defaultdict

class Solution:
    def groupStrings(self, strings: List[str]) -> List[List[str]]:
        def hash_string(s: str) -> str:
            # If the string is empty, return a special hash
            if not s:
                return ""
            # Calculate the hash by the difference between consecutive characters
            hash_code = []
            for i in range(1, len(s)):
                diff = (ord(s[i]) - ord(s[i - 1])) % 26
                hash_code.append(str(diff))
            return ",".join(hash_code)
        
        # Dictionary to hold the groups of strings with the same hash
        groups = defaultdict(list)
        
        # Group strings by their hash
        for s in strings:
            hash_key = hash_string(s)
            groups[hash_key].append(s)
        
        # Return the grouped strings as a list of lists
        return list(groups.values())
```

### Explanation:
- **hash_string(s: str) -> str**: This helper function generates a hash for each string `s`. The hash is based on the difference between the ASCII values of consecutive characters in the string. The difference is taken modulo 26 to handle the circular nature of the alphabet (e.g., 'z' to 'a').
- **groups**: A dictionary where the keys are the hashes generated by `hash_string`, and the values are lists of strings that share the same hash.
- **Iterate through each string in `strings`**: For each string, compute its hash and add it to the corresponding list in the `groups` dictionary.
- **Return the grouped strings**: Convert the dictionary values (which are lists of grouped strings) into a list of lists and return it.

Given the root of a binary tree, return the number of uni-value subtrees.
A uni-value subtree means all nodes of the subtree have the same value.
 
Example 1:


Input: root = [5,1,5,5,5,null,5]
Output: 4

Example 2:

Input: root = []
Output: 0

Example 3:

Input: root = [5,5,5,5,5,null,5]
Output: 6

 
Constraints:

The number of the node in the tree will be in the range [0, 1000].
-1000 <= Node.val <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:
        self.count = 0
        
        def is_unival(node):
            if not node:
                return True, None
            
            left_is_unival, left_val = is_unival(node.left)
            right_is_unival, right_val = is_unival(node.right)
            
            if left_is_unival and right_is_unival:
                if (left_val is None or left_val == node.val) and (right_val is None or right_val == node.val):
                    self.count += 1
                    return True, node.val
            
            return False, node.val
        
        is_unival(root)
        return self.count
```

Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.
 
Example 1:
Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
Example 2:
Input: intervals = [[7,10],[2,4]]
Output: true

 
Constraints:

0 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti < endi <= 106



```python
from typing import List

class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        # Sort the intervals based on the start time
        intervals.sort(key=lambda x: x[0])
        
        # Check if there is any overlap between consecutive intervals
        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i - 1][1]:
                return False
        
        return True
```

This solution works by first sorting the meeting intervals based on their start times. Then, it checks each pair of consecutive intervals to see if there is any overlap. If any overlap is found, it returns `False`, indicating that the person cannot attend all meetings. If no overlaps are found, it returns `True`.

Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.
 
Example 1:
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2
Example 2:
Input: intervals = [[7,10],[2,4]]
Output: 1

 
Constraints:

1 <= intervals.length <= 104
0 <= starti < endi <= 106



To solve the problem of finding the minimum number of conference rooms required for a given set of meeting time intervals, we can use a sweep line algorithm. This approach involves treating the start and end of meetings as events and then sorting these events. As we process each event, we adjust the count of ongoing meetings, which helps us determine the maximum number of rooms needed at any point in time.

Here is the Python code implementing this solution:

```python
from typing import List
import heapq

class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        # Create a list of all events: start and end times
        events = []
        for start, end in intervals:
            events.append((start, 1))  # Meeting starts
            events.append((end, -1))   # Meeting ends
        
        # Sort events by time. If two events have the same time, end comes before start
        events.sort()
        
        # Initialize variables to keep track of the current number of rooms and the maximum number of rooms needed
        current_rooms = 0
        max_rooms = 0
        
        # Process each event in the sorted list
        for time, delta in events:
            current_rooms += delta  # Update the number of current rooms
            max_rooms = max(max_rooms, current_rooms)  # Update the maximum number of rooms needed
        
        return max_rooms
```

### Explanation:

1. **Event Creation**: We create a list of events where each event is a tuple. For each interval `[start, end]`, we add two events to the list: `(start, 1)` and `(end, -1)`. The `1` indicates a meeting start, and `-1` indicates a meeting end.

2. **Event Sorting**: The events are sorted by time. If two events have the same time, the end event (`-1`) comes before the start event (`1`). This ensures that a meeting ending at the same time a new meeting starts does not require an additional room.

3. **Processing Events**: We iterate through the sorted events, updating the count of current rooms with the value of `delta` (either `+1` or `-1`). At each step, we also update the maximum number of rooms needed.

4. **Result**: The maximum value of `current_rooms` during the iteration gives us the minimum number of conference rooms required to accommodate all meetings.

This approach efficiently determines the minimum number of rooms using a time complexity of `O(n log n)` due to the sorting step, where `n` is the number of intervals. The space complexity is `O(n)` for storing the events.

Numbers can be regarded as the product of their factors.

For example, 8 = 2 x 2 x 2 = 2 x 4.

Given an integer n, return all possible combinations of its factors. You may return the answer in any order.
Note that the factors should be in the range [2, n - 1].
 
Example 1:

Input: n = 1
Output: []

Example 2:

Input: n = 12
Output: [[2,6],[3,4],[2,2,3]]

Example 3:

Input: n = 37
Output: []

 
Constraints:

1 <= n <= 107



```python
from typing import List

class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        def backtrack(start, target):
            for i in range(start, int(target**0.5) + 1):
                if target % i == 0:
                    path.append(i)
                    res.append(path[:] + [target // i])
                    backtrack(i, target // i)
                    path.pop()
        
        res = []
        path = []
        backtrack(2, n)
        return res
```

This solution uses a backtracking approach to find all factor combinations of a given integer `n`. The `backtrack` function explores all possible factors starting from a given number `start` up to the square root of the current target. If a factor is found, it is added to the current path, and the function continues to find factors of the quotient. Once a complete combination is found, it is added to the result list. The path is then backtracked to explore other combinations.

Given an array of unique integers preorder, return true if it is the correct preorder traversal sequence of a binary search tree.
 
Example 1:


Input: preorder = [5,2,1,3,6]
Output: true

Example 2:

Input: preorder = [5,2,6,1,3]
Output: false

 
Constraints:

1 <= preorder.length <= 104
1 <= preorder[i] <= 104
All the elements of preorder are unique.

 
Follow up: Could you do it using only constant space complexity?


```python
from typing import List

class Solution:
    def verifyPreorder(self, preorder: List[int]) -> bool:
        stack = []
        lower_bound = float('-inf')
        
        for value in preorder:
            if value <= lower_bound:
                return False
            if not stack or value < stack[-1]:
                stack.append(value)
            else:
                while stack and value >= stack[-1]:
                    lower_bound = stack.pop()
                stack.append(value)
        
        return True
```

This solution uses a stack to simulate the traversal of the binary search tree and maintains a `lower_bound` to ensure that all elements in the right subtree are greater than the root of that subtree. The solution operates in O(n) time complexity and uses O(h) space complexity, where h is the height of the tree. In the worst case (a skewed tree), this can be O(n), but for a balanced tree, it would be O(log n). To achieve constant space complexity, we can use Morris Traversal techniques, but that is more complex and not shown here. For this problem, the provided solution is efficient and meets the requirements.

There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.
The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.

For example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...

Return the minimum cost to paint all houses.
 
Example 1:

Input: costs = [[17,2,17],[16,16,5],[14,3,19]]
Output: 10
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.
Minimum cost: 2 + 5 + 3 = 10.

Example 2:

Input: costs = [[7,6,2]]
Output: 2

 
Constraints:

costs.length == n
costs[i].length == 3
1 <= n <= 100
1 <= costs[i][j] <= 20



```python
from typing import List

class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
        # Initialize the previous house's costs with the first house's costs
        prev_red, prev_blue, prev_green = costs[0]
        
        # Iterate over the costs starting from the second house
        for red, blue, green in costs[1:]:
            # Calculate the minimum cost for the current house with each color
            # Ensure no two adjacent houses have the same color
            curr_red = red + min(prev_blue, prev_green)
            curr_blue = blue + min(prev_red, prev_green)
            curr_green = green + min(prev_red, prev_blue)
            
            # Update the previous costs to the current costs for the next iteration
            prev_red, prev_blue, prev_green = curr_red, curr_blue, curr_green
        
        # The result is the minimum cost among the last house's three color costs
        return min(prev_red, prev_blue, prev_green)
```

This solution uses dynamic programming to keep track of the minimum cost to paint each house while ensuring no two adjacent houses have the same color. The space complexity is O(1) since we only store the costs for the previous house, and the time complexity is O(n) where n is the number of houses.

Given the root of a binary tree, return all root-to-leaf paths in any order.
A leaf is a node with no children.
 
Example 1:


Input: root = [1,2,3,null,5]
Output: ["1->2->5","1->3"]

Example 2:

Input: root = [1]
Output: ["1"]

 
Constraints:

The number of nodes in the tree is in the range [1, 100].
-100 <= Node.val <= 100



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def dfs(node, path):
            if not node:
                return
            # Add the current node to the path
            path.append(str(node.val))
            # If it's a leaf, add the path to the result
            if not node.left and not node.right:
                result.append("->".join(path))
            else:
                # Continue the search on the left and right children
                dfs(node.left, path)
                dfs(node.right, path)
            # Backtrack: remove the current node from the path
            path.pop()
        
        result = []
        dfs(root, [])
        return result
```

Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.
 
Example 1:

Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.

Example 2:

Input: num = 0
Output: 0

 
Constraints:

0 <= num <= 231 - 1

 
Follow up: Could you do it without any loop/recursion in O(1) runtime?


To solve this problem efficiently in O(1) time without using loops or recursion, we can use a mathematical property known as the digital root. The digital root of a number is the single digit obtained by repeatedly summing the digits of the number until only a single digit remains.

For a given number `num`, the digital root can be found using the following formula:
- If `num` is 0, the result is 0.
- Otherwise, the result is `1 + (num - 1) % 9`.

This formula is derived from properties of numbers in modular arithmetic, specifically modulo 9.

Here is the Python code implementing this solution:

```python
class Solution:
    def addDigits(self, num: int) -> int:
        if num == 0:
            return 0
        else:
            return 1 + (num - 1) % 9
```

This code directly computes the result in constant time, satisfying the O(1) runtime requirement.

Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.
 
Example 1:

Input: nums = [-2,0,1,3], target = 2
Output: 2
Explanation: Because there are two triplets which sums are less than 2:
[-2,0,1]
[-2,0,3]

Example 2:

Input: nums = [], target = 0
Output: 0

Example 3:

Input: nums = [0], target = 0
Output: 0

 
Constraints:

n == nums.length
0 <= n <= 3500
-100 <= nums[i] <= 100
-100 <= target <= 100



```python
from typing import List

class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        nums.sort()
        count = 0
        n = len(nums)
        
        for i in range(n - 2):
            left, right = i + 1, n - 1
            while left < right:
                current_sum = nums[i] + nums[left] + nums[right]
                if current_sum < target:
                    # If the sum of nums[i], nums[left], and nums[right] is less than the target,
                    # then all sums of nums[i], nums[left], and nums[left+1] to nums[right] are also less than the target.
                    count += right - left
                    left += 1
                else:
                    right -= 1
        
        return count
```

This solution sorts the array first and then uses a two-pointer technique to find the number of triplets that satisfy the condition. The time complexity is O(n^2), which is efficient given the constraint n ≤ 3500.

Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.
You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.
 
Example 1:

Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.

Example 2:

Input: nums = [-1,0]
Output: [-1,0]

Example 3:

Input: nums = [0,1]
Output: [1,0]

 
Constraints:

2 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
Each integer in nums will appear twice, only two integers will appear once.



```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        # Step 1: XOR all the numbers to get the XOR of the two unique numbers
        xor_all = 0
        for num in nums:
            xor_all ^= num
        
        # Step 2: Find a set bit in the xor_all (rightmost set bit in this case)
        diff_bit = xor_all & -xor_all
        
        # Step 3: Divide numbers into two groups based on the set bit and XOR each group
        num1, num2 = 0, 0
        for num in nums:
            if num & diff_bit:
                num1 ^= num
            else:
                num2 ^= num
        
        return [num1, num2]
```

This solution works by using bitwise operations to achieve the required linear runtime complexity and constant space usage. Here's a brief explanation of the steps:

1. **XOR all the numbers**: This will give us the XOR of the two unique numbers since all other numbers appear twice and will cancel out.

2. **Find a set bit**: We find a bit that is set (1) in the XOR result. This bit is set in one of the unique numbers but not in the other.

3. **Divide and XOR**: We divide the numbers into two groups based on whether they have the set bit or not. Each group will contain one of the unique numbers and all other numbers will appear in pairs. XORing the numbers in each group will give us the unique numbers.

You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.
Return true if the edges of the given graph make up a valid tree, and false otherwise.
 
Example 1:


Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true

Example 2:


Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
Output: false

 
Constraints:

1 <= n <= 2000
0 <= edges.length <= 5000
edges[i].length == 2
0 <= ai, bi < n
ai != bi
There are no self-loops or repeated edges.



To determine if the given graph forms a valid tree, we need to ensure two main conditions:

1. **Acyclic**: The graph should not contain any cycles.
2. **Connected**: All nodes should be connected, meaning there should be a path between any two nodes.

A valid tree with `n` nodes will always have exactly `n-1` edges. If there are fewer than `n-1` edges, the graph cannot be connected. If there are more than `n-1` edges, the graph must contain cycles.

We can use Union-Find (Disjoint Set Union) to efficiently check for cycles and ensure connectivity. Here is the implementation:

```python
from typing import List

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX == rootY:
            return False
        if self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        elif self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1
        return True

class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != n - 1:
            return False
        
        uf = UnionFind(n)
        
        for u, v in edges:
            if not uf.union(u, v):
                return False
        
        return True
```

### Explanation:
1. **Union-Find Data Structure**:
   - **Initialization**: Each node is its own parent initially, and the rank is set to 0.
   - **Find**: This function finds the root of a node and performs path compression to flatten the structure.
   - **Union**: This function connects two nodes. If both nodes have the same root, a cycle is detected, and we return `False`. Otherwise, we connect them and adjust the rank if necessary.

2. **Main Function**:
   - **Edge Count Check**: If the number of edges is not `n-1`, the graph cannot be a tree.
   - **Union Operations**: We iterate through each edge and attempt to union the nodes. If any union operation fails (indicating a cycle), we return `False`.
   - **Return True**: If all edges are successfully processed without detecting a cycle, the graph is a valid tree.

An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.
Given an integer n, return true if n is an ugly number.
 
Example 1:

Input: n = 6
Output: true
Explanation: 6 = 2 × 3

Example 2:

Input: n = 1
Output: true
Explanation: 1 has no prime factors.

Example 3:

Input: n = 14
Output: false
Explanation: 14 is not ugly since it includes the prime factor 7.

 
Constraints:

-231 <= n <= 231 - 1



```python
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        for factor in [2, 3, 5]:
            while n % factor == 0:
                n //= factor
        return n == 1
```

This code defines a method `isUgly` that checks if a given integer `n` is an ugly number. It first handles the case where `n` is less than or equal to zero by returning `False`, as ugly numbers are positive. Then, it iteratively divides `n` by the prime factors 2, 3, and 5 as long as it is divisible by them. Finally, it checks if the resulting value of `n` is 1, which would mean that `n` was only composed of the prime factors 2, 3, and 5, and thus is an ugly number.

An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return the nth ugly number.
 
Example 1:

Input: n = 10
Output: 12
Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.

Example 2:

Input: n = 1
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.

 
Constraints:

1 <= n <= 1690



```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        # Initialize the first ugly number
        ugly_numbers = [1]
        
        # Pointers for multiples of 2, 3, and 5
        i2 = i3 = i5 = 0
        
        # Generate ugly numbers until we have the nth one
        while len(ugly_numbers) < n:
            # Next multiple of 2, 3, and 5
            next_multiple_of_2 = ugly_numbers[i2] * 2
            next_multiple_of_3 = ugly_numbers[i3] * 3
            next_multiple_of_5 = ugly_numbers[i5] * 5
            
            # Choose the smallest next ugly number
            next_ugly = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)
            ugly_numbers.append(next_ugly)
            
            # Increment the pointer for the chosen multiple
            if next_ugly == next_multiple_of_2:
                i2 += 1
            if next_ugly == next_multiple_of_3:
                i3 += 1
            if next_ugly == next_multiple_of_5:
                i5 += 1
        
        # Return the nth ugly number
        return ugly_numbers[-1]
```

This solution uses a dynamic programming approach to generate the sequence of ugly numbers up to the nth one. It maintains three pointers to track the next multiple of 2, 3, and 5, and always selects the smallest of these multiples to ensure the sequence is in increasing order.

There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.
The cost of painting each house with a certain color is represented by an n x k cost matrix costs.

For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on...

Return the minimum cost to paint all houses.
 
Example 1:

Input: costs = [[1,5,3],[2,9,4]]
Output: 5
Explanation:
Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; 
Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.

Example 2:

Input: costs = [[1,3],[2,4]]
Output: 5

 
Constraints:

costs.length == n
costs[i].length == k
1 <= n <= 100
2 <= k <= 20
1 <= costs[i][j] <= 20

 
Follow up: Could you solve it in O(nk) runtime?


```python
from typing import List

class Solution:
    def minCostII(self, costs: List[List[int]]) -> int:
        if not costs:
            return 0
        
        n = len(costs)
        k = len(costs[0])
        
        # Initialize the dp array with the first house's costs
        dp = costs[0][:]
        
        for i in range(1, n):
            # Find the two minimum costs from the previous house
            min1 = min2 = float('inf')
            min1_idx = -1
            for j in range(k):
                if dp[j] < min1:
                    min2 = min1
                    min1 = dp[j]
                    min1_idx = j
                elif dp[j] < min2:
                    min2 = dp[j]
            
            # Update the dp array for the current house
            for j in range(k):
                if j == min1_idx:
                    dp[j] = costs[i][j] + min2
                else:
                    dp[j] = costs[i][j] + min1
        
        # The minimum cost to paint all houses is the minimum value in the last dp array
        return min(dp)
```

This solution efficiently computes the minimum cost to paint all houses with the constraint that no two adjacent houses have the same color. It uses dynamic programming with a time complexity of O(nk), where n is the number of houses and k is the number of colors. The space complexity is O(k) due to the `dp` array used to store the minimum costs for the current and previous houses.

Given a string s, return true if a permutation of the string could form a palindrome and false otherwise.
 
Example 1:

Input: s = "code"
Output: false

Example 2:

Input: s = "aab"
Output: true

Example 3:

Input: s = "carerac"
Output: true

 
Constraints:

1 <= s.length <= 5000
s consists of only lowercase English letters.



```python
class Solution:
    def canPermutePalindrome(self, s: str) -> bool:
        from collections import Counter
        
        # Count the frequency of each character in the string
        char_count = Counter(s)
        
        # Count how many characters have an odd frequency
        odd_count = sum(1 for count in char_count.values() if count % 2 != 0)
        
        # A string can form a palindrome if it has at most one character with an odd frequency
        return odd_count <= 1
```

This solution uses the `Counter` class from the `collections` module to count the frequency of each character in the string. It then checks how many characters have an odd frequency. A string can be permuted to form a palindrome if and only if at most one character has an odd frequency. The function returns `True` if this condition is met, and `False` otherwise.

Given a string s, return all the palindromic permutations (without duplicates) of it.
You may return the answer in any order. If s has no palindromic permutation, return an empty list.
 
Example 1:
Input: s = "aabb"
Output: ["abba","baab"]
Example 2:
Input: s = "abc"
Output: []

 
Constraints:

1 <= s.length <= 16
s consists of only lowercase English letters.



```python
from collections import Counter
from typing import List

class Solution:
    def generatePalindromes(self, s: str) -> List[str]:
        def dfs(t):
            if len(t) == len(s):
                ans.append(t)
                return
            for c, v in cnt.items():
                if v > 1:
                    cnt[c] -= 2
                    dfs(c + t + c)
                    cnt[c] += 2

        cnt = Counter(s)
        mid = ''
        for c, v in cnt.items():
            if v & 1:
                if mid:
                    return []
                mid = c
                cnt[c] -= 1
        ans = []
        dfs(mid)
        return ans
```

This solution uses a depth-first search (DFS) approach to generate all possible palindromic permutations of the input string `s`. It first counts the frequency of each character in the string using `Counter`. It then checks if there is more than one character with an odd count, in which case it's impossible to form a palindrome, and it returns an empty list. If there is exactly one character with an odd count, that character is placed in the middle of the palindrome. The DFS function recursively builds palindromes by adding characters to both ends of the current string `t`, ensuring that the final string is a palindrome. The result is stored in the list `ans`, which is returned at the end.

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
 
Example 1:

Input: nums = [3,0,1]
Output: 2
Explanation:
n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.

Example 2:

Input: nums = [0,1]
Output: 2
Explanation:
n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.

Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation:
n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.



 


 

 
 





 
Constraints:

n == nums.length
1 <= n <= 104
0 <= nums[i] <= n
All the numbers of nums are unique.

 
Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?


To solve the problem of finding the missing number in an array of distinct numbers ranging from 0 to n with O(n) runtime complexity and O(1) extra space complexity, we can use the XOR operation. XOR has some useful properties:
1. \( a \oplus a = 0 \) for any integer \( a \).
2. \( a \oplus 0 = a \) for any integer \( a \).
3. XOR is commutative and associative, meaning the order of operands does not matter.

By XORing all the numbers in the array with all the numbers from 0 to n, the numbers that appear in the array will cancel out, leaving only the missing number.

Here is the solution:

```python
from typing import List

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        missing = len(nums)  # Start with n
        for i in range(len(nums)):
            missing ^= i ^ nums[i]  # XOR i and nums[i] and the current missing value
        return missing
```

This solution works as follows:
1. Initialize `missing` with the value of \( n \) (which is `len(nums)`).
2. Iterate through the array. For each index \( i \) and the element at that index `nums[i]`, XOR `missing` with both \( i \) and `nums[i]`.
3. After the loop, `missing` will hold the value of the missing number because all the numbers that appear both in the array and in the range will cancel out, leaving only the missing number.

This approach ensures that the solution has O(n) runtime complexity and O(1) extra space complexity.

There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.
You are given a list of strings words from the alien language's dictionary. Now it is claimed that the strings in words are sorted lexicographically by the rules of this new language.
If this claim is incorrect, and the given arrangement of string in words cannot correspond to any order of letters, return "".
Otherwise, return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there are multiple solutions, return any of them.
 
Example 1:

Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"

Example 2:

Input: words = ["z","x"]
Output: "zx"

Example 3:

Input: words = ["z","x","z"]
Output: ""
Explanation: The order is invalid, so return "".

 
Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] consists of only lowercase English letters.



```python
from collections import deque
from typing import List

class Solution:
    def alienOrder(self, words: List[str]) -> str:
        g = [[False] * 26 for _ in range(26)]
        s = [False] * 26
        cnt = 0
        n = len(words)
        for i in range(n - 1):
            for c in words[i]:
                if cnt == 26:
                    break
                o = ord(c) - ord('a')
                if not s[o]:
                    cnt += 1
                    s[o] = True
            m = len(words[i])
            for j in range(m):
                if j >= len(words[i + 1]):
                    return ''
                c1, c2 = words[i][j], words[i + 1][j]
                if c1 == c2:
                    continue
                o1, o2 = ord(c1) - ord('a'), ord(c2) - ord('a')
                if g[o2][o1]:
                    return ''
                g[o1][o2] = True
                break
        for c in words[n - 1]:
            if cnt == 26:
                break
            o = ord(c) - ord('a')
            if not s[o]:
                cnt += 1
                s[o] = True

        indegree = [0] * 26
        for i in range(26):
            for j in range(26):
                if i != j and s[i] and s[j] and g[i][j]:
                    indegree[j] += 1
        q = deque()
        ans = []
        for i in range(26):
            if s[i] and indegree[i] == 0:
                q.append(i)
        while q:
            t = q.popleft()
            ans.append(chr(t + ord('a')))
            for i in range(26):
                if s[i] and i != t and g[t][i]:
                    indegree[i] -= 1
                    if indegree[i] == 0:
                        q.append(i)
        return '' if len(ans) < cnt else ''.join(ans)
```

Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest.
 
Example 1:


Input: root = [4,2,5,1,3], target = 3.714286
Output: 4

Example 2:

Input: root = [1], target = 4.428571
Output: 1

 
Constraints:

The number of nodes in the tree is in the range [1, 104].
0 <= Node.val <= 109
-109 <= target <= 109



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -> int:
        closest = root.val
        while root:
            # Update closest if the current node is closer to the target
            if abs(target - root.val) < abs(target - closest):
                closest = root.val
            # Move to the left or right child based on the target value
            if target < root.val:
                root = root.left
            else:
                root = root.right
        return closest
```

This solution leverages the properties of a binary search tree (BST) to efficiently find the value closest to the target. It iteratively traverses the tree, updating the closest value found so far, and moves in the direction that could potentially yield a closer value.

Given the root of a binary search tree, a target value, and an integer k, return the k values in the BST that are closest to the target. You may return the answer in any order.
You are guaranteed to have only one unique set of k values in the BST that are closest to the target.
 
Example 1:


Input: root = [4,2,5,1,3], target = 3.714286, k = 2
Output: [4,3]

Example 2:

Input: root = [1], target = 0.000000, k = 1
Output: [1]

 
Constraints:

The number of nodes in the tree is n.
1 <= k <= n <= 104.
0 <= Node.val <= 109
-109 <= target <= 109

 
Follow up: Assume that the BST is balanced. Could you solve it in less than O(n) runtime (where n = total nodes)?


To solve the problem of finding the k values in a Binary Search Tree (BST) that are closest to a given target, we can leverage the properties of BSTs and use an in-order traversal to efficiently find the closest values. The in-order traversal of a BST yields values in sorted order, which helps in maintaining a sliding window of the k closest values.

Here is the solution:

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
from typing import Optional, List

class Solution:
    def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -> List[int]:
        # Initialize a deque to keep track of the closest k values
        closest_values = deque()
        
        # Perform in-order traversal
        def inorder(node: Optional[TreeNode]):
            if not node:
                return
            
            # Traverse the left subtree
            inorder(node.left)
            
            # Process the current node
            if len(closest_values) < k:
                closest_values.append(node.val)
            else:
                # Compare the current node with the farthest value in the deque
                if abs(node.val - target) < abs(closest_values[0] - target):
                    closest_values.popleft()
                    closest_values.append(node.val)
                else:
                    # Since the BST is sorted in-order, no need to check further
                    return
            
            # Traverse the right subtree
            inorder(node.right)
        
        # Start the in-order traversal from the root
        inorder(root)
        
        # Convert deque to list and return
        return list(closest_values)
```

### Explanation:
1. **In-order Traversal**: We perform an in-order traversal of the BST. This ensures that we process the nodes in ascending order.
2. **Deque for Closest Values**: We use a deque to maintain the k closest values to the target. This allows us to efficiently add and remove values from both ends.
3. **Comparison Logic**: During the traversal, if the deque has fewer than k values, we simply add the current node's value. If the deque already contains k values, we compare the current node's value with the farthest value (the first element in the deque). If the current value is closer to the target, we remove the farthest value and add the current value.
4. **Early Termination**: Since the BST is sorted, once we find a node that is farther from the target than the farthest value in the deque, we can terminate the traversal early for the right subtree.

This approach ensures that we only traverse the necessary parts of the tree, making it efficient even for unbalanced trees. If the BST is balanced, the runtime can be improved to O(log n + k) using a more advanced approach with two deques to track the closest values on both sides of the target.

Convert a non-negative integer num to its English words representation.
 
Example 1:

Input: num = 123
Output: "One Hundred Twenty Three"

Example 2:

Input: num = 12345
Output: "Twelve Thousand Three Hundred Forty Five"

Example 3:

Input: num = 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

 
Constraints:

0 <= num <= 231 - 1



```python
class Solution:
    def numberToWords(self, num: int) -> str:
        if num == 0:
            return "Zero"
        
        billion = 10 ** 9
        million = 10 ** 6
        thousand = 10 ** 3
        hundred = 10 ** 2
        
        below_twenty = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", 
                        "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]
        tens = ["", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]
        
        def helper(n):
            if n == 0:
                return ""
            elif n < 20:
                return below_twenty[n] + " "
            elif n < 100:
                return tens[n // 10] + " " + helper(n % 10)
            else:
                return below_twenty[n // 100] + " Hundred " + helper(n % 100)
        
        result = ""
        
        if num >= billion:
            result += helper(num // billion) + "Billion "
            num %= billion
        if num >= million:
            result += helper(num // million) + "Million "
            num %= million
        if num >= thousand:
            result += helper(num // thousand) + "Thousand "
            num %= thousand
        if num > 0:
            result += helper(num)
        
        return result.strip()
```

Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.
According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.
 
Example 1:

Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.

Example 2:

Input: citations = [1,3,1]
Output: 1

 
Constraints:

n == citations.length
1 <= n <= 5000
0 <= citations[i] <= 1000



```python
from typing import List

class Solution:
    def hIndex(self, citations: List[int]) -> int:
        # Sort the citations in descending order
        citations.sort(reverse=True)
        
        # Initialize h-index to 0
        h_index = 0
        
        # Iterate over the sorted citations
        for citation in citations:
            # If the citation count is greater than the current h-index, increment h-index
            if citation > h_index:
                h_index += 1
            else:
                # If not, we can't increase the h-index further
                break
        
        return h_index
```

This solution sorts the list of citations in descending order and iteratively checks how many papers have at least as many citations as the current h-index. The time complexity of this approach is O(n log n) due to the sorting step, and the space complexity is O(1) if we ignore the space used by the sorting algorithm.

Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in ascending order, return the researcher's h-index.
According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.
You must write an algorithm that runs in logarithmic time.
 
Example 1:

Input: citations = [0,1,3,5,6]
Output: 3
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.

Example 2:

Input: citations = [1,2,100]
Output: 2

 
Constraints:

n == citations.length
1 <= n <= 105
0 <= citations[i] <= 1000
citations is sorted in ascending order.



```python
from typing import List

class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        left, right = 0, n
        
        while left < right:
            mid = (left + right) // 2
            if citations[mid] >= n - mid:
                right = mid
            else:
                left = mid + 1
        
        return n - left
```

This solution uses binary search to find the h-index in logarithmic time. The key idea is to find the first position `mid` such that `citations[mid]` is at least `n - mid`, where `n` is the total number of papers. The h-index is then `n - mid`.

You are painting a fence of n posts with k different colors. You must paint the posts following these rules:

Every post must be painted exactly one color.
There cannot be three or more consecutive posts with the same color.

Given the two integers n and k, return the number of ways you can paint the fence.
 
Example 1:


Input: n = 3, k = 2
Output: 6
Explanation: All the possibilities are shown.
Note that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.

Example 2:

Input: n = 1, k = 1
Output: 1

Example 3:

Input: n = 7, k = 2
Output: 42

 
Constraints:

1 <= n <= 50
1 <= k <= 105
The testcases are generated such that the answer is in the range [0, 231 - 1] for the given n and k.



```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return k
        if n == 2:
            return k * k
        
        # Initialize the number of ways to paint the first two posts
        same = k  # Last two posts have the same color
        diff = k * (k - 1)  # Last two posts have different colors
        total = same + diff
        
        for i in range(3, n + 1):
            new_same = diff  # If the last two posts are the same, the third one must be different from the second last
            new_diff = total * (k - 1)  # If the last two posts are different, the third one can be any color except the last one
            same = new_same
            diff = new_diff
            total = same + diff
        
        return total
```

This solution uses dynamic programming to keep track of the number of ways to paint the fence such that no three consecutive posts have the same color. The `same` variable keeps track of the number of ways to paint the fence where the last two posts are the same color, and the `diff` variable keeps track of the number of ways where the last two posts are different colors. The total number of ways to paint `i` posts is the sum of `same` and `diff` for each step.

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.
You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.
 
Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.

Example 2:

Input: n = 1, bad = 1
Output: 1

 
Constraints:

1 <= bad <= n <= 231 - 1



```python
# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:
        left, right = 1, n
        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return left
```

This solution uses a binary search approach to minimize the number of calls to the `isBadVersion` API. The idea is to repeatedly divide the search interval in half. If the middle version is bad, then the first bad version must be at `mid` or to the left of `mid`, so we adjust the `right` pointer. Otherwise, the first bad version must be to the right of `mid`, so we adjust the `left` pointer. The loop continues until `left` equals `right`, which will be the first bad version.

Given an integer n, return the least number of perfect square numbers that sum to n.
A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.
 
Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.

Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.

 
Constraints:

1 <= n <= 104



```python
class Solution:
    def numSquares(self, n: int) -> int:
        # Create a list to store the minimum number of perfect squares for each number up to n
        dp = [float('inf')] * (n + 1)
        dp[0] = 0  # Base case: 0 can be represented by 0 perfect squares
        
        # Precompute all perfect squares less than or equal to n
        squares = []
        i = 1
        while i * i <= n:
            squares.append(i * i)
            i += 1
        
        # Fill the dp array
        for i in range(1, n + 1):
            for square in squares:
                if i < square:
                    break
                dp[i] = min(dp[i], dp[i - square] + 1)
        
        return dp[n]
```

This solution uses dynamic programming to find the minimum number of perfect squares that sum to `n`. The `dp` array is used to store the minimum number of perfect squares for each number up to `n`. We iterate through each number and update the `dp` array by considering each perfect square less than or equal to that number. The final result is stored in `dp[n]`.

Given an integer array nums, reorder it such that nums[0] <= nums[1] >= nums[2] <= nums[3]....
You may assume the input array always has a valid answer.
 
Example 1:

Input: nums = [3,5,2,1,6,4]
Output: [3,5,1,6,2,4]
Explanation: [1,6,2,5,3,4] is also accepted.

Example 2:

Input: nums = [6,6,5,6,3,8]
Output: [6,6,5,6,3,8]

 
Constraints:

1 <= nums.length <= 5 * 104
0 <= nums[i] <= 104
It is guaranteed that there will be an answer for the given input nums.

 
Follow up: Could you solve the problem in O(n) time complexity?


```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        less = True  # Start with the expectation of nums[0] <= nums[1]
        
        for i in range(len(nums) - 1):
            if less:
                if nums[i] > nums[i + 1]:
                    nums[i], nums[i + 1] = nums[i + 1], nums[i]
            else:
                if nums[i] < nums[i + 1]:
                    nums[i], nums[i + 1] = nums[i + 1], nums[i]
            less = not less  # Toggle the expectation for the next pair
```

This solution works by iterating through the list and ensuring that each pair of elements satisfies the wiggle property. It uses a boolean flag `less` to keep track of whether the current element should be less than or greater than the next element. The flag is toggled after each comparison to alternate the expectation for the next pair. This approach ensures that the list is reordered in O(n) time complexity.

Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.
Note that operands in the returned expressions should not contain leading zeros.
 
Example 1:

Input: num = "123", target = 6
Output: ["1*2*3","1+2+3"]
Explanation: Both "1*2*3" and "1+2+3" evaluate to 6.

Example 2:

Input: num = "232", target = 8
Output: ["2*3+2","2+3*2"]
Explanation: Both "2*3+2" and "2+3*2" evaluate to 8.

Example 3:

Input: num = "3456237490", target = 9191
Output: []
Explanation: There are no expressions that can be created from "3456237490" to evaluate to 9191.

 
Constraints:

1 <= num.length <= 10
num consists of only digits.
-231 <= target <= 231 - 1



```python
from typing import List

class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        def backtrack(index, path, value, prev):
            # If we have reached the end of the string and the value equals the target, add to result
            if index == len(num):
                if value == target:
                    result.append(path)
                return
            
            # Try all possible splits of the remaining string
            for i in range(index + 1, len(num) + 1):
                # Extract the current number
                current_str = num[index:i]
                current_num = int(current_str)
                
                # If the current number starts with a zero, skip to avoid numbers with leading zeros
                if i != index + 1 and num[index] == '0':
                    break
                
                # If this is the first number in the path, just add it
                if index == 0:
                    backtrack(i, current_str, current_num, current_num)
                else:
                    # Addition
                    backtrack(i, path + '+' + current_str, value + current_num, current_num)
                    # Subtraction
                    backtrack(i, path + '-' + current_str, value - current_num, -current_num)
                    # Multiplication
                    # prev is the previous operand, which we multiply with current_num
                    # We subtract prev from value to remove its effect, then add prev * current_num
                    backtrack(i, path + '*' + current_str, value - prev + prev * current_num, prev * current_num)
        
        result = []
        backtrack(0, "", 0, 0)
        return result
```

This solution uses a backtracking approach to explore all possible ways to insert the operators '+', '-', and '*' between the digits of the input string `num`. It keeps track of the current path, the current evaluated value, and the previous operand to handle multiplication correctly. The function avoids numbers with leading zeros and checks if the final evaluated value matches the target.

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
 
Example 1:
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:
Input: nums = [0]
Output: [0]

 
Constraints:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

 
Follow up: Could you minimize the total number of operations done?

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # Initialize a pointer for the position of the next non-zero element
        last_non_zero_found_at = 0

        # Move all the non-zero elements to the beginning of the array
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[last_non_zero_found_at] = nums[i]
                last_non_zero_found_at += 1

        # Fill the remaining positions with zeros
        for i in range(last_non_zero_found_at, len(nums)):
            nums[i] = 0
```

This solution moves all the non-zero elements to the front of the array while maintaining their relative order, and then fills the rest of the array with zeros. It does this in-place and minimizes the total number of operations by only writing to the array when necessary.

You are given an m x n grid rooms initialized with these three possible values.

-1 A wall or an obstacle.
0 A gate.
INF Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.
 
Example 1:


Input: rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]
Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]

Example 2:

Input: rooms = [[-1]]
Output: [[-1]]

 
Constraints:

m == rooms.length
n == rooms[i].length
1 <= m, n <= 250
rooms[i][j] is -1, 0, or 231 - 1.



```python
from typing import List
from collections import deque

class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        if not rooms or not rooms[0]:
            return
        
        rows, cols = len(rooms), len(rooms[0])
        queue = deque()
        
        # Add all gates to the queue
        for r in range(rows):
            for c in range(cols):
                if rooms[r][c] == 0:
                    queue.append((r, c))
        
        # Directions for moving up, down, left, right
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        # Perform BFS from each gate
        while queue:
            r, c = queue.popleft()
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                # Check if the new position is within bounds and is an empty room
                if 0 <= nr < rows and 0 <= nc < cols and rooms[nr][nc] == 2147483647:
                    rooms[nr][nc] = rooms[r][c] + 1
                    queue.append((nr, nc))
```

This solution uses a breadth-first search (BFS) approach starting from each gate (cells with value `0`). It explores all four possible directions (up, down, left, right) from each gate and updates the distance to the nearest gate for each empty room (cells with value `2147483647`). The BFS ensures that each room is updated with the shortest distance to a gate.

Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and using only constant extra space.
 
Example 1:

Input: nums = [1,3,4,2,2]
Output: 2

Example 2:

Input: nums = [3,1,3,4,2]
Output: 3

Example 3:

Input: nums = [3,3,3,3,3]
Output: 3
 
Constraints:

1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
All the integers in nums appear only once except for precisely one integer which appears two or more times.

 
Follow up:

How can we prove that at least one duplicate number must exist in nums?
Can you solve the problem in linear runtime complexity?



To solve this problem within the given constraints, we can use a binary search approach combined with the pigeonhole principle. The idea is to leverage the fact that if there are `n+1` numbers in the range `[1, n]`, at least one number must be repeated.

Here's the step-by-step explanation and the code:

1. **Binary Search Setup**: We'll perform a binary search on the numbers from 1 to n. The search space is the range of possible numbers in the array.

2. **Counting Occurrences**: For each midpoint `x` in our binary search, we count how many numbers in the array are less than or equal to `x`.

3. **Pigeonhole Principle**: If the count of numbers `≤ x` is greater than `x`, it means that the duplicate number must be in the range `[1, x]` because there are more numbers in this range than the possible unique numbers. Otherwise, the duplicate number must be in the range `[x+1, n]`.

4. **Return the Result**: The binary search will eventually converge to the duplicate number.

Here is the implementation of the above logic:

```python
from typing import List
from bisect import bisect_left

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        def f(x: int) -> bool:
            return sum(v <= x for v in nums) > x

        return bisect_left(range(1, len(nums)), True, key=f) + 1
```

### Explanation of the Code:
- `bisect_left(range(1, len(nums)), True, key=f)`: This performs a binary search on the range `[1, n]` (inclusive). The `key=f` argument means that the function `f` is used to determine the sorting order.
- `def f(x: int) -> bool`: This function checks if the number of elements in `nums` that are `≤ x` is greater than `x`.
- `+ 1`: Since `bisect_left` returns a 0-based index, we add 1 to convert it to the correct number in the range `[1, n]`.

This solution works in `O(n log n)` time complexity due to the binary search and the counting of elements, and it uses `O(1)` extra space as required.

According to Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

Any live cell with fewer than two live neighbors dies as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population.
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.
Given the current state of the board, update the board to reflect its next state.
Note that you do not need to return anything.
 
Example 1:


Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

Example 2:


Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]

 
Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 25
board[i][j] is 0 or 1.

 
Follow up:

Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.
In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?



```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        # Directions for the 8 neighbors
        neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        
        rows = len(board)
        cols = len(board[0])
        
        # Use two bits to store the current state and the next state
        # Current state: cell >> 0 & 1 (least significant bit)
        # Next state: cell >> 1 & 1 (second least significant bit)
        
        # First pass: count live neighbors and mark next state
        for r in range(rows):
            for c in range(cols):
                live_neighbors = 0
                
                # Count live neighbors
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and (board[nr][nc] & 1) == 1:
                        live_neighbors += 1
                
                # Apply rules to determine the next state
                if board[r][c] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    # Live cell dies
                    board[r][c] = 1 | (0 << 1)  # 01 -> 01
                elif board[r][c] == 0 and live_neighbors == 3:
                    # Dead cell becomes live
                    board[r][c] = 0 | (1 << 1)  # 00 -> 10
                else:
                    # Cell remains in the same state
                    board[r][c] = board[r][c] | ((board[r][c] & 1) << 1)
        
        # Second pass: update the board to the next state
        for r in range(rows):
            for c in range(cols):
                board[r][c] >>= 1  # Shift right to get the next state
```

This solution uses an in-place approach to update the board by encoding both the current and next states of each cell within a single integer. The least significant bit stores the current state, and the second least significant bit stores the next state. After processing all cells to determine their next states, a second pass is made to update the board to these new states. This ensures that all updates happen simultaneously, as required by the problem constraints.

Given a pattern and a string s, find if s follows the same pattern.
Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:

Each letter in pattern maps to exactly one unique word in s.
Each unique word in s maps to exactly one letter in pattern.
No two letters map to the same word, and no two words map to the same letter.

 
Example 1:

Input: pattern = "abba", s = "dog cat cat dog"
Output: true
Explanation:
The bijection can be established as:

'a' maps to "dog".
'b' maps to "cat".


Example 2:

Input: pattern = "abba", s = "dog cat cat fish"
Output: false

Example 3:

Input: pattern = "aaaa", s = "dog cat cat dog"
Output: false

 
Constraints:

1 <= pattern.length <= 300
pattern contains only lower-case English letters.
1 <= s.length <= 3000
s contains only lowercase English letters and spaces ' '.
s does not contain any leading or trailing spaces.
All the words in s are separated by a single space.



```python
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        if len(pattern) != len(words):
            return False
        
        char_to_word = {}
        word_to_char = {}
        
        for char, word in zip(pattern, words):
            if char in char_to_word:
                if char_to_word[char] != word:
                    return False
            else:
                char_to_word[char] = word
            
            if word in word_to_char:
                if word_to_char[word] != char:
                    return False
            else:
                word_to_char[word] = char
        
        return True
```

This solution uses two dictionaries to maintain the bijection between characters in the pattern and words in the string `s`. It checks if each character maps to exactly one unique word and vice versa, ensuring no two characters map to the same word and no two words map to the same character.

Given a pattern and a string s, return true if s matches the pattern.
A string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.
 
Example 1:

Input: pattern = "abab", s = "redblueredblue"
Output: true
Explanation: One possible mapping is as follows:
'a' -> "red"
'b' -> "blue"
Example 2:

Input: pattern = "aaaa", s = "asdasdasdasd"
Output: true
Explanation: One possible mapping is as follows:
'a' -> "asd"

Example 3:

Input: pattern = "aabb", s = "xyzabcxzyabc"
Output: false

 
Constraints:

1 <= pattern.length, s.length <= 20
pattern and s consist of only lowercase English letters.



```python
class Solution:
    def wordPatternMatch(self, pattern: str, s: str) -> bool:
        def backtrack(pattern_index, string_index, mapping, used):
            # If we reached the end of the pattern, check if we also reached the end of the string
            if pattern_index == len(pattern):
                return string_index == len(s)
            
            # Get the current character in the pattern
            current_char = pattern[pattern_index]
            
            # If the current character is already mapped, we check if the string from the current index matches the mapped string
            if current_char in mapping:
                word = mapping[current_char]
                if s[string_index:string_index + len(word)] == word:
                    return backtrack(pattern_index + 1, string_index + len(word), mapping, used)
                else:
                    return False
            
            # If the current character is not mapped, try to map it to every possible substring
            for end_index in range(string_index + 1, len(s) + 1):
                candidate = s[string_index:end_index]
                
                # Ensure that the candidate is not already used for another character
                if candidate in used:
                    continue
                
                # Map the current character to the candidate and mark it as used
                mapping[current_char] = candidate
                used.add(candidate)
                
                # Recur for the next part of the pattern and string
                if backtrack(pattern_index + 1, end_index, mapping, used):
                    return True
                
                # Backtrack: unmap the current character and unmark the candidate as used
                del mapping[current_char]
                used.remove(candidate)
            
            return False
        
        # Start the backtracking with an empty mapping and an empty set of used words
        return backtrack(0, 0, {}, set())
```

This solution uses backtracking to try all possible mappings of pattern characters to substrings of `s`. It ensures that each character in the pattern maps to a unique substring and that no two characters map to the same substring. The function `backtrack` recursively attempts to build a valid mapping, and if it finds one, it returns `True`. If it exhausts all possibilities without finding a valid mapping, it returns `False`.

You are playing the following Nim Game with your friend:

Initially, there is a heap of stones on the table.
You and your friend will alternate taking turns, and you go first.
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.
The one who removes the last stone is the winner.

Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.
 
Example 1:

Input: n = 4
Output: false
Explanation: These are the possible outcomes:
1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.
2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.
3. You remove 3 stones. Your friend removes the last stone. Your friend wins.
In all outcomes, your friend wins.

Example 2:

Input: n = 1
Output: true

Example 3:

Input: n = 2
Output: true

 
Constraints:

1 <= n <= 231 - 1



```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        # If n is a multiple of 4, you will always lose if both play optimally.
        # Otherwise, you can always win.
        return n % 4 != 0
```

You are playing a Flip Game with your friend.
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move, and therefore the other person will be the winner.
Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].
 
Example 1:

Input: currentState = "++++"
Output: ["--++","+--+","++--"]

Example 2:

Input: currentState = "+"
Output: []

 
Constraints:

1 <= currentState.length <= 500
currentState[i] is either '+' or '-'.



```python
from typing import List

class Solution:
    def generatePossibleNextMoves(self, currentState: str) -> List[str]:
        possible_states = []
        for i in range(len(currentState) - 1):
            if currentState[i:i+2] == "++":
                new_state = currentState[:i] + "--" + currentState[i+2:]
                possible_states.append(new_state)
        return possible_states
```

This code defines a method `generatePossibleNextMoves` that iterates through the `currentState` string and checks for consecutive "++". When found, it creates a new state by flipping "++" to "--" and adds this new state to the list of possible states. Finally, it returns the list of all possible states after one valid move. If no valid move is found, it returns an empty list.

You are playing a Flip Game with your friend.
You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move, and therefore the other person will be the winner.
Return true if the starting player can guarantee a win, and false otherwise.
 
Example 1:

Input: currentState = "++++"
Output: true
Explanation: The starting player can guarantee a win by flipping the middle "++" to become "+--+".

Example 2:

Input: currentState = "+"
Output: false

 
Constraints:

1 <= currentState.length <= 60
currentState[i] is either '+' or '-'.

 
Follow up: Derive your algorithm's runtime complexity.

```python
class Solution:
    def canWin(self, currentState: str) -> bool:
        def canWinHelper(state, memo):
            if state in memo:
                return memo[state]
            
            for i in range(len(state) - 1):
                if state[i] == '+' and state[i + 1] == '+':
                    new_state = state[:i] + '--' + state[i + 2:]
                    if not canWinHelper(new_state, memo):
                        memo[state] = True
                        return True
            
            memo[state] = False
            return False
        
        memo = {}
        return canWinHelper(currentState, memo)
```

### Explanation:
The algorithm uses recursion with memoization to determine if the starting player can guarantee a win. Here's a step-by-step breakdown of the approach:

1. **Recursive Function (`canWinHelper`)**: This function checks if the current player can force a win given the current state of the board. It tries every possible move (flipping "++" to "--") and recursively checks if the opponent can win from the resulting state.

2. **Memoization**: To avoid redundant calculations, the results of previously computed states are stored in a dictionary (`memo`). If a state has been encountered before, the result is directly returned from the dictionary, which significantly reduces the number of recursive calls.

3. **Base Case**: If no "++" is found in the current state, the player cannot make a move and loses, so the function returns `False`.

4. **Recursive Case**: For each possible move, if flipping "++" to "--" results in a state where the opponent cannot guarantee a win (`not canWinHelper(new_state, memo)`), the current player can guarantee a win, and the function returns `True`.

5. **Memoization Storage**: If no winning move is found for the current state, the result `False` is stored in the memo dictionary.

### Runtime Complexity:
The runtime complexity of this algorithm is difficult to express in a simple Big-O notation due to its recursive nature and memoization. However, it is significantly better than the brute-force approach. In the worst case, without memoization, the time complexity would be exponential, O(2^n), where n is the length of the string. With memoization, the time complexity is reduced to O(n * 2^n) in the worst case, where each state is computed and stored once. This is because there are at most 2^n possible states of the string (each position can be either '+' or '-'), and for each state, we potentially make n-1 recursive calls (one for each possible move). However, memoization ensures that each state is processed only once.

Given an m x n binary grid grid where each 1 marks the home of one friend, return the minimal total travel distance.
The total travel distance is the sum of the distances between the houses of the friends and the meeting point.
The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.
 
Example 1:


Input: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
Output: 6
Explanation: Given three friends living at (0,0), (0,4), and (2,2).
The point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.
So return 6.

Example 2:

Input: grid = [[1,1]]
Output: 1

 
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 200
grid[i][j] is either 0 or 1.
There will be at least two friends in the grid.



```python
from typing import List

class Solution:
    def minTotalDistance(self, grid: List[List[int]]) -> int:
        # Collect row and column indices of all homes
        rows = [i for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 1]
        cols = [j for j in range(len(grid[0])) for i in range(len(grid)) if grid[i][j] == 1]
        
        # Function to calculate minimum distance for a given sorted list of coordinates
        def min_distance(points):
            return sum(abs(points[i] - points[len(points) // 2]) for i in range(len(points)))
        
        # Calculate the minimum total distance using the median
        return min_distance(rows) + min_distance(cols)
```

### Explanation:
To solve this problem, we need to find a meeting point that minimizes the total Manhattan distance to all the homes. The optimal meeting point in a grid with Manhattan distance is the median of the row and column indices of all the homes.

Here's a step-by-step breakdown of the solution:

1. **Collect Indices of Homes**: We first collect the row and column indices of all the homes (cells with `1` in the grid).

2. **Calculate Median**: The median minimizes the sum of absolute deviations. So, we find the median of the row indices and the median of the column indices.

3. **Compute Total Distance**: The total distance is the sum of the distances from each home to the median row and the median column. This is computed using the `min_distance` function, which calculates the sum of absolute differences from each point to the median.

This approach ensures that we find the optimal meeting point efficiently. The time complexity is O(m * n log(m * n)) due to the sorting step to find the median, which is efficient given the problem constraints.

Given the root of a binary tree, return the length of the longest consecutive sequence path.
A consecutive sequence path is a path where the values increase by one along the path.
Note that the path can start at any node in the tree, and you cannot go from a node to its parent in the path.
 
Example 1:


Input: root = [1,null,3,2,4,null,null,null,5]
Output: 3
Explanation: Longest consecutive sequence path is 3-4-5, so return 3.

Example 2:


Input: root = [2,null,3,2,null,1]
Output: 2
Explanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.

 
Constraints:

The number of nodes in the tree is in the range [1, 3 * 104].
-3 * 104 <= Node.val <= 3 * 104



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        def dfs(node, parent_val, current_length):
            if not node:
                return current_length
            
            # Check if the current node is consecutive
            if node.val == parent_val + 1:
                current_length += 1
            else:
                current_length = 1
            
            # Recur for left and right children and return the maximum length found
            left_length = dfs(node.left, node.val, current_length)
            right_length = dfs(node.right, node.val, current_length)
            
            return max(current_length, left_length, right_length)
        
        # Start DFS from the root with initial parent value as -inf and length 0
        return dfs(root, float('-inf'), 0)
```

This solution uses a depth-first search (DFS) approach to traverse the binary tree. It keeps track of the current length of the consecutive sequence and updates the maximum length found during the traversal. The function `dfs` is called recursively for each node, checking if the current node continues the consecutive sequence from its parent. If it does, the length is incremented; otherwise, it is reset to 1. The function returns the maximum length of any consecutive sequence found in the tree.

You are playing the Bulls and Cows game with your friend.
You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

The number of "bulls", which are digits in the guess that are in the correct position.
The number of "cows", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.

Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.
The hint should be formatted as "xAyB", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.
 
Example 1:

Input: secret = "1807", guess = "7810"
Output: "1A3B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1807"
  |
"7810"
Example 2:

Input: secret = "1123", guess = "0111"
Output: "1A1B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1123"        "1123"
  |      or     |
"0111"        "0111"
Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.

 
Constraints:

1 <= secret.length, guess.length <= 1000
secret.length == guess.length
secret and guess consist of digits only.



```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        from collections import defaultdict
        
        bulls = 0
        cows = 0
        secret_count = defaultdict(int)
        guess_count = defaultdict(int)
        
        # First pass to count bulls and potential cows
        for s, g in zip(secret, guess):
            if s == g:
                bulls += 1
            else:
                secret_count[s] += 1
                guess_count[g] += 1
        
        # Calculate cows based on the counts
        for digit in secret_count:
            if digit in guess_count:
                cows += min(secret_count[digit], guess_count[digit])
        
        return f"{bulls}A{cows}B"
```

This solution works by first iterating through the `secret` and `guess` strings simultaneously to count the number of bulls (correct digit in the correct position) and to keep track of the counts of each digit that is not a bull in both strings. In the second pass, it calculates the number of cows by finding the minimum count of each digit that appears in both `secret` and `guess` (but not in the same position). Finally, it returns the result in the required format.

Given an integer array nums, return the length of the longest strictly increasing subsequence.
 
Example 1:

Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.

Example 2:

Input: nums = [0,1,0,3,2,3]
Output: 4

Example 3:

Input: nums = [7,7,7,7,7,7,7]
Output: 1

 
Constraints:

1 <= nums.length <= 2500
-104 <= nums[i] <= 104

 
Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?


```python
from typing import List
import bisect

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        # This list will store the smallest tail of all increasing subsequences
        # with different lengths found so far.
        tails = []
        
        for num in nums:
            # Use binary search to find the insertion point of the current number
            # in the tails list.
            index = bisect.bisect_left(tails, num)
            
            # If the number is larger than any element in tails, append it.
            if index == len(tails):
                tails.append(num)
            else:
                # Otherwise, replace the element at the found index with the current number.
                tails[index] = num
        
        # The length of the tails list is the length of the longest increasing subsequence.
        return len(tails)

# Example usage:
# solution = Solution()
# print(solution.lengthOfLIS([10,9,2,5,3,7,101,18]))  # Output: 4
# print(solution.lengthOfLIS([0,1,0,3,2,3]))         # Output: 4
# print(solution.lengthOfLIS([7,7,7,7,7,7,7]))        # Output: 1
```

This solution uses a dynamic programming approach with binary search to achieve the desired O(n log n) time complexity. The `tails` list keeps track of the smallest possible tail value for all increasing subsequences of different lengths. For each number in the input list, we determine its position using binary search and either extend the list or replace an existing value. The length of the `tails` list at the end of the process is the length of the longest increasing subsequence.

You are given an m x n binary matrix image where 0 represents a white pixel and 1 represents a black pixel.
The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.
Given two integers x and y that represents the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.
You must write an algorithm with less than O(mn) runtime complexity
 
Example 1:


Input: image = [["0","0","1","0"],["0","1","1","0"],["0","1","0","0"]], x = 0, y = 2
Output: 6

Example 2:

Input: image = [["1"]], x = 0, y = 0
Output: 1

 
Constraints:

m == image.length
n == image[i].length
1 <= m, n <= 100
image[i][j] is either '0' or '1'.
0 <= x < m
0 <= y < n
image[x][y] == '1'.
The black pixels in the image only form one component.



To solve this problem efficiently with a runtime complexity of less than O(mn), we can use binary search to find the boundaries of the smallest rectangle that encloses all black pixels. The idea is to focus on the rows and columns and use binary search to determine the smallest and largest indices that contain black pixels. Here's the implementation:

```python
from typing import List

class Solution:
    def minArea(self, image: List[List[str]], x: int, y: int) -> int:
        if not image or not image[0]:
            return 0
        
        m, n = len(image), len(image[0])
        
        # Helper function to check if there is any black pixel in the given row
        def hasBlackPixelRow(row: int) -> bool:
            for col in range(n):
                if image[row][col] == '1':
                    return True
            return False
        
        # Helper function to check if there is any black pixel in the given column
        def hasBlackPixelCol(col: int) -> bool:
            for row in range(m):
                if image[row][col] == '1':
                    return True
            return False
        
        # Binary search to find the topmost row with a black pixel
        top = self.binarySearch(0, x, hasBlackPixelRow, True)
        # Binary search to find the bottommost row with a black pixel
        bottom = self.binarySearch(x, m - 1, hasBlackPixelRow, False)
        # Binary search to find the leftmost column with a black pixel
        left = self.binarySearch(0, y, hasBlackPixelCol, True)
        # Binary search to find the rightmost column with a black pixel
        right = self.binarySearch(y, n - 1, hasBlackPixelCol, False)
        
        # Calculate the area of the rectangle
        return (bottom - top + 1) * (right - left + 1)
    
    def binarySearch(self, low: int, high: int, checkFunc, goLower: bool) -> int:
        while low < high:
            mid = (low + high) // 2
            if checkFunc(mid):
                if goLower:
                    high = mid
                else:
                    low = mid
            else:
                if goLower:
                    low = mid + 1
                else:
                    high = mid - 1
            if low + 1 == high:
                if goLower:
                    if checkFunc(low):
                        return low
                    else:
                        return high
                else:
                    if checkFunc(high):
                        return high
                    else:
                        return low
        return low
```

### Explanation:
1. **Helper Functions**:
   - `hasBlackPixelRow(row)`: Checks if there is any black pixel in the given row.
   - `hasBlackPixelCol(col)`: Checks if there is any black pixel in the given column.

2. **Binary Search**:
   - `binarySearch(low, high, checkFunc, goLower)`: Searches for the boundary (either top/bottom row or left/right column) using binary search. The `goLower` flag determines whether we are looking for the lower boundary or the upper boundary.

3. **Main Function**:
   - Uses binary search to find the top, bottom, left, and right boundaries of the smallest rectangle enclosing all black pixels.
   - Calculates and returns the area of the rectangle.

This approach ensures that the solution runs in less than O(mn) time by leveraging binary search on the rows and columns, resulting in a time complexity of O(m log n) or O(n log m), depending on the relative sizes of m and n.

You are given an empty 2D binary grid grid of size m x n. The grid represents a map where 0's represent water and 1's represent land. Initially, all the cells of grid are water cells (i.e., all the cells are 0's).
We may perform an add land operation which turns the water at position into a land. You are given an array positions where positions[i] = [ri, ci] is the position (ri, ci) at which we should operate the ith operation.
Return an array of integers answer where answer[i] is the number of islands after turning the cell (ri, ci) into a land.
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
 
Example 1:


Input: m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
Output: [1,1,2,3]
Explanation:
Initially, the 2d grid is filled with water.
- Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land. We have 1 island.
- Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land. We still have 1 island.
- Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land. We have 2 islands.
- Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land. We have 3 islands.

Example 2:

Input: m = 1, n = 1, positions = [[0,0]]
Output: [1]

 
Constraints:

1 <= m, n, positions.length <= 104
1 <= m * n <= 104
positions[i].length == 2
0 <= ri < m
0 <= ci < n

 
Follow up: Could you solve it in time complexity O(k log(mn)), where k == positions.length?


```python
from typing import List

class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size
        self.count = 0

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])  # Path compression
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return False
        # Union by rank
        if self.rank[rootP] > self.rank[rootQ]:
            self.parent[rootQ] = rootP
        elif self.rank[rootP] < self.rank[rootQ]:
            self.parent[rootP] = rootQ
        else:
            self.parent[rootQ] = rootP
            self.rank[rootP] += 1
        self.count -= 1
        return True

    def getCount(self):
        return self.count

class Solution:
    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -> List[int]:
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        uf = UnionFind(m * n)
        grid = [[0] * n for _ in range(m)]
        result = []
        island_count = 0

        for r, c in positions:
            if grid[r][c] == 1:
                result.append(island_count)
                continue

            grid[r][c] = 1
            island_count += 1
            index = r * n + c

            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:
                    neighbor_index = nr * n + nc
                    if uf.union(index, neighbor_index):
                        island_count -= 1

            result.append(island_count)

        return result
```

This solution uses the Union-Find (Disjoint Set Union) data structure with path compression and union by rank to efficiently manage the merging of islands. The time complexity of this approach is approximately O(k log(mn)), where k is the number of positions, due to the efficient union and find operations in the Union-Find structure.

An additive number is a string whose digits can form an additive sequence.
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.
Given a string containing only digits, return true if it is an additive number or false otherwise.
Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.
 
Example 1:

Input: "112358"
Output: true
Explanation: 
The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 
1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

Example 2:

Input: "199100199"
Output: true
Explanation: 
The additive sequence is: 1, 99, 100, 199. 
1 + 99 = 100, 99 + 100 = 199

 
Constraints:

1 <= num.length <= 35
num consists only of digits.

 
Follow up: How would you handle overflow for very large input integers?


```python
class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        
        def is_valid_sequence(start: int, first: int, second: int) -> bool:
            if start == len(num):
                return True
            
            expected = first + second
            expected_str = str(expected)
            
            if num.startswith(expected_str, start):
                return is_valid_sequence(start + len(expected_str), second, expected)
            
            return False
        
        n = len(num)
        
        # The first number can be from index 0 to n-3 (inclusive)
        for i in range(1, n - 1):
            # The second number can be from index i to n-2 (inclusive)
            for j in range(i + 1, n):
                first_num = num[:i]
                second_num = num[i:j]
                
                # Check for leading zeros
                if (len(first_num) > 1 and first_num[0] == '0') or (len(second_num) > 1 and second_num[0] == '0'):
                    continue
                
                if is_valid_sequence(j, int(first_num), int(second_num)):
                    return True
        
        return False
```

This solution uses a backtracking approach to check all possible pairs of starting numbers and verifies if the rest of the string can form a valid additive sequence. It handles the constraint of no leading zeros and ensures that the sequence is valid by recursively checking the sum of the previous two numbers against the next part of the string.

You are given an array prices where prices[i] is the price of a given stock on the ith day.
Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:

After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
 
Example 1:

Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]

Example 2:

Input: prices = [1]
Output: 0

 
Constraints:

1 <= prices.length <= 5000
0 <= prices[i] <= 1000



```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0

        n = len(prices)
        # hold: the maximum profit we can have while holding a stock
        # sold: the maximum profit we can have just after selling a stock
        # rest: the maximum profit we can have while being in cooldown
        hold, sold, rest = float('-inf'), 0, 0

        for price in prices:
            # Update hold to be the max of itself or the profit from the rest state minus the price of the stock
            hold = max(hold, rest - price)
            # Update rest to be the max of itself or the previous sold state
            rest = max(rest, sold)
            # Update sold to be the profit from holding a stock and selling it at the current price
            sold = hold + price

        # The answer will be the max profit we can have in the rest or sold state (since we cannot hold a stock in the end)
        return max(sold, rest)
```

This solution uses dynamic programming to keep track of three states: holding a stock, just sold a stock, and in a cooldown period. It iteratively updates these states based on the current price, ensuring that the cooldown restriction is respected.

A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.
Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).
Return a list of all MHTs' root labels. You can return the answer in any order.
The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.
 
Example 1:


Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.

Example 2:


Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]

 
Constraints:

1 <= n <= 2 * 104
edges.length == n - 1
0 <= ai, bi < n
ai != bi
All the pairs (ai, bi) are distinct.
The given input is guaranteed to be a tree and there will be no repeated edges.



```python
from collections import deque
from typing import List

class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1:
            return [0]
        g = [[] for _ in range(n)]
        degree = [0] * n
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
            degree[a] += 1
            degree[b] += 1
        q = deque(i for i in range(n) if degree[i] == 1)
        ans = []
        while q:
            ans.clear()
            for _ in range(len(q)):
                a = q.popleft()
                ans.append(a)
                for b in g[a]:
                    degree[b] -= 1
                    if degree[b] == 1:
                        q.append(b)
        return ans
```

This solution implements the algorithm to find the Minimum Height Trees (MHTs) in a given tree by iteratively removing leaves until 1 or 2 nodes are left. These remaining nodes are the roots of the MHTs. The use of a deque allows efficient popping from the front of the queue, which is essential for the BFS-like approach used in this solution.

Given two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2. You may assume that multiplication is always possible.
 
Example 1:


Input: mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]]
Output: [[7,0,0],[-7,0,3]]

Example 2:

Input: mat1 = [[0]], mat2 = [[0]]
Output: [[0]]

 
Constraints:

m == mat1.length
k == mat1[i].length == mat2.length
n == mat2[i].length
1 <= m, n, k <= 100
-100 <= mat1[i][j], mat2[i][j] <= 100



```python
from typing import List

class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
        m, k = len(mat1), len(mat1[0])
        n = len(mat2[0])
        result = [[0] * n for _ in range(m)]
        
        # Convert mat1 to a list of lists of non-zero elements
        non_zero_mat1 = []
        for i in range(m):
            row = [(j, mat1[i][j]) for j in range(k) if mat1[i][j] != 0]
            non_zero_mat1.append(row)
        
        # Convert mat2 to a list of lists of non-zero elements (transpose for easier column access)
        non_zero_mat2 = []
        for j in range(n):
            col = [(i, mat2[i][j]) for i in range(k) if mat2[i][j] != 0]
            non_zero_mat2.append(col)
        
        # Perform the multiplication using the non-zero elements
        for i in range(m):
            for j in range(n):
                if non_zero_mat1[i] and non_zero_mat2[j]:
                    for col_index, val1 in non_zero_mat1[i]:
                        for row_index, val2 in non_zero_mat2[j]:
                            if col_index == row_index:
                                result[i][j] += val1 * val2
        
        return result
```

This solution takes advantage of the sparsity of the matrices by only considering non-zero elements during the multiplication process. This can significantly reduce the number of operations compared to a naive implementation that multiplies all elements.

You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.
If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.
Return the maximum coins you can collect by bursting the balloons wisely.
 
Example 1:

Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
Example 2:

Input: nums = [1,5]
Output: 10

 
Constraints:

n == nums.length
1 <= n <= 300
0 <= nums[i] <= 100



```python
from typing import List

class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        # Add 1 to both ends of nums to handle edge cases
        nums = [1] + nums + [1]
        n = len(nums)
        
        # dp[i][j] will store the maximum coins obtained by bursting all the balloons between i and j
        dp = [[0] * n for _ in range(n)]
        
        # We will solve this problem by considering all possible lengths of subarrays
        for length in range(2, n):  # length is at least 2 because we added 1 to both ends
            for i in range(n - length):
                j = i + length
                # Now, consider each balloon between i and j as the last balloon to burst
                for k in range(i + 1, j):
                    # Calculate coins obtained by bursting the k-th balloon last
                    coins = nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j]
                    # Update dp[i][j] to be the maximum coins obtained
                    dp[i][j] = max(dp[i][j], coins)
        
        # The result is the maximum coins obtained by bursting all the balloons between the two added 1s
        return dp[0][n - 1]
```

This solution uses dynamic programming to solve the problem efficiently. The idea is to consider all possible subarrays of the `nums` array (with added boundary 1s) and calculate the maximum coins that can be obtained by bursting the balloons in that subarray optimally. The `dp` table is used to store the results of subproblems, and the final result is found in `dp[0][n-1]`, where `n` is the length of the modified `nums` array.

A super ugly number is a positive integer whose prime factors are in the array primes.
Given an integer n and an array of integers primes, return the nth super ugly number.
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
 
Example 1:

Input: n = 12, primes = [2,7,13,19]
Output: 32
Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].

Example 2:

Input: n = 1, primes = [2,3,5]
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].

 
Constraints:

1 <= n <= 105
1 <= primes.length <= 100
2 <= primes[i] <= 1000
primes[i] is guaranteed to be a prime number.
All the values of primes are unique and sorted in ascending order.



```python
from typing import List
import heapq

class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        # Initialize the heap with the first super ugly number
        heap = [1]
        # Set to keep track of the numbers we have already seen
        seen = {1}
        # Variable to store the current super ugly number
        current_ugly = 1
        
        # Extract the smallest element from the heap n times
        for _ in range(n):
            current_ugly = heapq.heappop(heap)
            # For each prime, generate a new super ugly number
            for prime in primes:
                new_ugly = current_ugly * prime
                # If the new number has not been seen, add it to the heap and set
                if new_ugly not in seen:
                    seen.add(new_ugly)
                    heapq.heappush(heap, new_ugly)
        
        return current_ugly
```

This solution uses a min-heap to efficiently get the next super ugly number. We start with the number 1, which is the first super ugly number. For each number we extract from the heap, we multiply it by each prime in the `primes` list to generate new super ugly numbers. We use a set `seen` to avoid adding duplicate numbers to the heap. The process is repeated until we have found the nth super ugly number.

Given the root of a binary tree, return the vertical order traversal of its nodes' values. (i.e., from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]

Example 2:


Input: root = [3,9,8,4,0,1,7]
Output: [[4],[9],[3,0,1],[8],[7]]

Example 3:


Input: root = [1,2,3,4,10,9,11,null,5,null,null,null,null,null,null,null,6]
Output: [[4],[2,5],[1,10,9,6],[3],[11]]

 
Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque, defaultdict
from typing import Optional, List

class Solution:
    def verticalOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        
        # Dictionary to store nodes' values by their column index
        column_table = defaultdict(list)
        
        # Queue to perform BFS; each element is a tuple (node, column_index)
        queue = deque([(root, 0)])
        
        # Track the range of column indices
        min_col = max_col = 0
        
        while queue:
            node, column_index = queue.popleft()
            
            if node is not None:
                # Update the range of column indices
                min_col = min(min_col, column_index)
                max_col = max(max_col, column_index)
                
                # Append the node's value to the corresponding column
                column_table[column_index].append(node.val)
                
                # Add the node's children to the queue with updated column indices
                queue.append((node.left, column_index - 1))
                queue.append((node.right, column_index + 1))
        
        # Collect the results column by column, from min_col to max_col
        return [column_table[x] for x in range(min_col, max_col + 1)]
```

This solution performs a breadth-first search (BFS) on the binary tree while keeping track of the column index for each node. It uses a dictionary to collect node values by their column index and a queue to manage the nodes to be processed. After traversing the tree, it constructs the result by collecting values from the dictionary in the order of column indices.

Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].
 
Example 1:

Input: nums = [5,2,6,1]
Output: [2,1,1,0]
Explanation:
To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.

Example 2:

Input: nums = [-1]
Output: [0]

Example 3:

Input: nums = [-1,-1]
Output: [0,0]

 
Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104



```python
from typing import List
from bisect import bisect_left

class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        sorted_nums = []
        counts = []
        
        for num in reversed(nums):
            # Find the index where the number should be inserted to keep sorted_nums sorted
            index = bisect_left(sorted_nums, num)
            # The index is also the count of smaller elements to the right
            counts.append(index)
            # Insert the number into the sorted list
            sorted_nums.insert(index, num)
        
        # The counts are collected in reverse order, so reverse them back
        return counts[::-1]
```

This solution uses a binary search approach with a sorted list to efficiently determine the number of smaller elements to the right of each element in the input list. The `bisect_left` function is used to find the insertion point for each element in the sorted list, which corresponds to the count of smaller elements to its right. The sorted list is built in reverse order to facilitate this process.

Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.
 
Example 1:

Input: s = "bcabc"
Output: "abc"

Example 2:

Input: s = "cbacdcbc"
Output: "acdb"

 
Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.

 
Note: This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/


```python
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        # Dictionary to store the last occurrence of each character
        last_occurrence = {char: idx for idx, char in enumerate(s)}
        # Stack to build the result
        stack = []
        # Set to keep track of characters in the stack
        in_stack = set()
        
        for i, char in enumerate(s):
            # If the character is already in the stack, skip it
            if char in in_stack:
                continue
            
            # While the stack is not empty, and the current character is smaller than the last character in the stack
            # and the last character appears later in the string, pop it from the stack
            while stack and char < stack[-1] and i < last_occurrence[stack[-1]]:
                removed_char = stack.pop()
                in_stack.remove(removed_char)
            
            # Add the current character to the stack and mark it as in the stack
            stack.append(char)
            in_stack.add(char)
        
        # Join the characters in the stack to form the result
        return ''.join(stack)
```

This solution uses a stack to build the result string while maintaining the lexicographical order and ensuring that each character appears only once. It leverages a dictionary to keep track of the last occurrence of each character and a set to efficiently check if a character is already in the stack.

You are given an m x n grid grid of values 0, 1, or 2, where:

each 0 marks an empty land that you can pass by freely,
each 1 marks a building that you cannot pass through, and
each 2 marks an obstacle that you cannot pass through.

You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. You can only move up, down, left, and right.
Return the shortest travel distance for such a house. If it is not possible to build such a house according to the above rules, return -1.
The total travel distance is the sum of the distances between the houses of the friends and the meeting point.
The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.
 
Example 1:


Input: grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]
Output: 7
Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).
The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.
So return 7.

Example 2:

Input: grid = [[1,0]]
Output: 1

Example 3:

Input: grid = [[1]]
Output: -1

 
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
grid[i][j] is either 0, 1, or 2.
There will be at least one building in the grid.



```python
from typing import List
from collections import deque

class Solution:
    def shortestDistance(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return -1
        
        m, n = len(grid), len(grid[0])
        total_distances = [[0] * n for _ in range(m)]
        buildings_reached = [[0] * n for _ in range(m)]
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        total_buildings = 0
        
        def bfs(start_x, start_y):
            visited = [[False] * n for _ in range(m)]
            queue = deque([(start_x, start_y, 0)])
            visited[start_x][start_y] = True
            min_distance = float('inf')
            
            while queue:
                x, y, dist = queue.popleft()
                
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    
                    if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:
                        visited[nx][ny] = True
                        buildings_reached[nx][ny] += 1
                        total_distances[nx][ny] += dist + 1
                        queue.append((nx, ny, dist + 1))
                        if buildings_reached[nx][ny] == total_buildings:
                            min_distance = min(min_distance, total_distances[nx][ny])
            
            return min_distance
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    total_buildings += 1
                    min_distance = bfs(i, j)
                    if min_distance == float('inf'):
                        return -1
        
        min_dist = float('inf')
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0 and buildings_reached[i][j] == total_buildings:
                    min_dist = min(min_dist, total_distances[i][j])
        
        return min_dist if min_dist != float('inf') else -1
```

Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.
 
Example 1:

Input: words = ["abcw","baz","foo","bar","xtfn","abcdef"]
Output: 16
Explanation: The two words can be "abcw", "xtfn".

Example 2:

Input: words = ["a","ab","abc","d","cd","bcd","abcd"]
Output: 4
Explanation: The two words can be "ab", "cd".

Example 3:

Input: words = ["a","aa","aaa","aaaa"]
Output: 0
Explanation: No such pair of words.

 
Constraints:

2 <= words.length <= 1000
1 <= words[i].length <= 1000
words[i] consists only of lowercase English letters.



```python
from typing import List

class Solution:
    def maxProduct(self, words: List[str]) -> int:
        # Convert each word to a set of characters for quick comparison
        word_sets = [set(word) for word in words]
        max_product = 0
        
        # Iterate over each pair of words
        for i in range(len(words)):
            for j in range(i + 1, len(words)):
                # Check if the two words have no common letters
                if not (word_sets[i] & word_sets[j]):
                    # Calculate the product of their lengths
                    product = len(words[i]) * len(words[j])
                    # Update max_product if the current product is larger
                    max_product = max(max_product, product)
        
        return max_product
```

This solution first converts each word into a set of characters, which allows for efficient checking of common letters between any two words. It then iterates over all possible pairs of words, checking if they have any letters in common. If they do not, it calculates the product of their lengths and updates the maximum product found so far. Finally, it returns the maximum product.

There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.
On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.
Return the number of bulbs that are on after n rounds.
 
Example 1:


Input: n = 3
Output: 1
Explanation: At first, the three bulbs are [off, off, off].
After the first round, the three bulbs are [on, on, on].
After the second round, the three bulbs are [on, off, on].
After the third round, the three bulbs are [on, off, off]. 
So you should return 1 because there is only one bulb is on.
Example 2:

Input: n = 0
Output: 0

Example 3:

Input: n = 1
Output: 1

 
Constraints:

0 <= n <= 109



To solve this problem, we need to understand the pattern of toggling the bulbs. Each bulb will be toggled in rounds corresponding to its divisors. For example, bulb 6 will be toggled in rounds 1, 2, 3, and 6. A bulb ends up being on if it is toggled an odd number of times. This happens only if the bulb's position is a perfect square (since perfect squares have a middle divisor that is repeated, e.g., 9 has divisors 1, 3, 9).

Thus, the number of bulbs that remain on after `n` rounds is the number of perfect squares less than or equal to `n`. This is equivalent to the integer part of the square root of `n`.

Here is the Python code implementing this logic:

```python
import math

class Solution:
    def bulbSwitch(self, n: int) -> int:
        return int(math.sqrt(n))
```

This code uses the `math.sqrt` function to compute the square root of `n` and then converts it to an integer, which gives the count of perfect squares less than or equal to `n`. This solution is efficient and works within the given constraints (0 <= n <= 10^9).

A word's generalized abbreviation can be constructed by taking any number of non-overlapping and non-adjacent substrings and replacing them with their respective lengths.

For example, "abcde" can be abbreviated into:

	
"a3e" ("bcd" turned into "3")
"1bcd1" ("a" and "e" both turned into "1")
"5" ("abcde" turned into "5")
"abcde" (no substrings replaced)


However, these abbreviations are invalid:
	
"23" ("ab" turned into "2" and "cde" turned into "3") is invalid as the substrings chosen are adjacent.
"22de" ("ab" turned into "2" and "bc" turned into "2") is invalid as the substring chosen overlap.



Given a string word, return a list of all the possible generalized abbreviations of word. Return the answer in any order.
 
Example 1:
Input: word = "word"
Output: ["4","3d","2r1","2rd","1o2","1o1d","1or1","1ord","w3","w2d","w1r1","w1rd","wo2","wo1d","wor1","word"]
Example 2:
Input: word = "a"
Output: ["1","a"]

 
Constraints:

1 <= word.length <= 15
word consists of only lowercase English letters.



```python
from typing import List

class Solution:
    def generateAbbreviations(self, word: str) -> List[str]:
        def dfs(i: int) -> List[str]:
            if i >= n:
                return [""]
            ans = [word[i] + s for s in dfs(i + 1)]
            for j in range(i + 1, n + 1):
                for s in dfs(j + 1):
                    ans.append(str(j - i) + (word[j] if j < n else "") + s)
            return ans

        n = len(word)
        return dfs(0)
```

This solution uses a depth-first search (DFS) approach to generate all possible generalized abbreviations of the given word. The `dfs` function recursively builds abbreviations by either including the current character or replacing a sequence of characters with their count. The base case of the recursion is when the index `i` is greater than or equal to the length of the word, in which case it returns a list containing an empty string. The function then combines the current character with the results of the recursive call for the next index, and also considers abbreviations that replace subsequences with their lengths.

You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.
Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.
Return an array of the k digits representing the answer.
 
Example 1:

Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
Output: [9,8,6,5,3]

Example 2:

Input: nums1 = [6,7], nums2 = [6,0,4], k = 5
Output: [6,7,6,0,4]

Example 3:

Input: nums1 = [3,9], nums2 = [8,9], k = 3
Output: [9,8,9]

 
Constraints:

m == nums1.length
n == nums2.length
1 <= m, n <= 500
0 <= nums1[i], nums2[i] <= 9
1 <= k <= m + n
nums1 and nums2 do not have leading zeros.



```python
from typing import List

class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        def maxSingleArray(nums, k):
            drop = len(nums) - k
            stack = []
            for num in nums:
                while drop and stack and stack[-1] < num:
                    stack.pop()
                    drop -= 1
                stack.append(num)
            return stack[:k]
        
        def merge(arr1, arr2):
            res = []
            while arr1 or arr2:
                bigger = arr1 if arr1 > arr2 else arr2
                res.append(bigger[0])
                bigger.pop(0)
            return res
        
        max_number = []
        for i in range(k + 1):
            if i <= len(nums1) and k - i <= len(nums2):
                max_number = max(max_number, merge(maxSingleArray(nums1, i), maxSingleArray(nums2, k - i)))
        
        return max_number
```

This solution works as follows:

1. **maxSingleArray(nums, k)**: This helper function creates the maximum possible array of length `k` from the digits of `nums` while preserving the relative order. It uses a greedy approach with a stack to ensure that the digits are in descending order.

2. **merge(arr1, arr2)**: This helper function merges two arrays `arr1` and `arr2` to form the largest possible number. It compares the two arrays lexicographically and chooses the larger starting digit to ensure the merged array is the largest possible.

3. **main logic**: The main function iterates over all possible ways to split the `k` digits between `nums1` and `nums2` (i.e., `i` digits from `nums1` and `k-i` digits from `nums2`). For each split, it computes the maximum possible arrays from each part and merges them. The result is the largest number found across all splits.

This approach ensures that we consider all possible combinations of digits from both arrays while maintaining the relative order of digits within each array. The solution efficiently finds the maximum number of length `k` by leveraging the properties of lexicographical order and stack-based digit selection.

You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
You may assume that you have an infinite number of each kind of coin.
 
Example 1:

Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Example 2:

Input: coins = [2], amount = 3
Output: -1

Example 3:

Input: coins = [1], amount = 0
Output: 0

 
Constraints:

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104



```python
from typing import List

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # Initialize the dp array with a value greater than the maximum possible number of coins
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0  # Base case: 0 coins are needed to make amount 0
        
        # Iterate over each amount from 1 to the target amount
        for a in range(1, amount + 1):
            # Check each coin
            for coin in coins:
                if a - coin >= 0:
                    dp[a] = min(dp[a], dp[a - coin] + 1)
        
        # If dp[amount] is still amount + 1, it means it's not possible to form that amount
        return dp[amount] if dp[amount] != amount + 1 else -1
```

This solution uses dynamic programming to solve the coin change problem. The `dp` array is used to store the minimum number of coins needed to make each amount up to the target amount. The algorithm iterates through each amount and each coin, updating the `dp` array with the minimum number of coins needed. If the final value in `dp` is still greater than the target amount, it means the target amount cannot be formed with the given coins, and the function returns -1.

You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.
Return the number of connected components in the graph.
 
Example 1:


Input: n = 5, edges = [[0,1],[1,2],[3,4]]
Output: 2

Example 2:


Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]
Output: 1

 
Constraints:

1 <= n <= 2000
1 <= edges.length <= 5000
edges[i].length == 2
0 <= ai <= bi < n
ai != bi
There are no repeated edges.



```python
from typing import List

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        # Helper function to perform DFS
        def dfs(node):
            if visited[node]:
                return
            visited[node] = True
            for neighbor in graph[node]:
                dfs(neighbor)
        
        # Create adjacency list for the graph
        graph = {i: [] for i in range(n)}
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        
        # Initialize visited array
        visited = [False] * n
        components = 0
        
        # Iterate through each node
        for node in range(n):
            if not visited[node]:
                dfs(node)
                components += 1
        
        return components
```

This solution uses Depth-First Search (DFS) to explore the graph and count the number of connected components. It first constructs an adjacency list representation of the graph from the given edges. Then, it iterates through each node, and if a node has not been visited, it performs a DFS from that node, marking all reachable nodes as visited. Each DFS call corresponds to one connected component, and the number of such calls gives the number of connected components in the graph.

Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....
You may assume the input array always has a valid answer.
 
Example 1:

Input: nums = [1,5,1,1,6,4]
Output: [1,6,1,5,1,4]
Explanation: [1,4,1,5,1,6] is also accepted.

Example 2:

Input: nums = [1,3,2,2,3,1]
Output: [2,3,1,3,1,2]

 
Constraints:

1 <= nums.length <= 5 * 104
0 <= nums[i] <= 5000
It is guaranteed that there will be an answer for the given input nums.

 
Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?

To solve the problem of reordering the array such that it follows a wiggle pattern (nums[0] < nums[1] > nums[2] < nums[3]...), we can use a strategy that involves sorting the array and then interleaving the elements from the two halves in a specific order. This approach ensures that the wiggle property is maintained.

Here's the step-by-step plan:
1. Sort the array.
2. Split the sorted array into two halves.
3. Reverse both halves to ensure that we can interleave them in a way that maintains the wiggle property.
4. Interleave the elements from the two halves by placing elements from the first half at even indices and elements from the second half at odd indices.

This approach works in O(n log n) time due to the sorting step. However, it uses O(n) extra space for the two halves. To achieve the follow-up requirement of O(n) time and O(1) extra space, we can use a more complex in-place algorithm, but for simplicity and clarity, we'll first implement the O(n log n) solution.

Here's the implementation:

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # Step 1: Sort the array
        nums.sort()
        
        # Step 2: Create two halves
        mid = (len(nums) + 1) // 2
        first_half = nums[:mid]
        second_half = nums[mid:]
        
        # Step 3: Reverse both halves
        first_half.reverse()
        second_half.reverse()
        
        # Step 4: Interleave the elements
        idx = 0
        while first_half or second_half:
            if first_half:
                nums[idx] = first_half.pop()
                idx += 1
            if second_half:
                nums[idx] = second_half.pop()
                idx += 1
```

This code will modify the `nums` array in place to satisfy the wiggle property. The use of `pop()` from the ends of the lists effectively interleaves the elements without needing additional space for a new list.

For the follow-up requirement of achieving O(n) time and O(1) space, we can use a more advanced algorithm that involves finding the median in linear time and then rearranging the elements around the median in a specific pattern. However, this is significantly more complex and typically involves the "Virtual Indexing" technique. If you need the O(n) time and O(1) space solution, let me know, and I can provide that as well.

Given an integer array nums and an integer k, return the maximum length of a subarray that sums to k. If there is not one, return 0 instead.
 
Example 1:

Input: nums = [1,-1,5,-2,3], k = 3
Output: 4
Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.

Example 2:

Input: nums = [-2,-1,2,1], k = 1
Output: 2
Explanation: The subarray [-1, 2] sums to 1 and is the longest.

 
Constraints:

1 <= nums.length <= 2 * 105
-104 <= nums[i] <= 104
-109 <= k <= 109



```python
from typing import List

class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -> int:
        # Dictionary to store the first occurrence of each prefix sum
        prefix_sum_indices = {0: -1}
        max_length = 0
        current_sum = 0
        
        for i, num in enumerate(nums):
            current_sum += num
            
            # Check if there is a prefix sum that, when subtracted from current_sum, equals k
            if (current_sum - k) in prefix_sum_indices:
                max_length = max(max_length, i - prefix_sum_indices[current_sum - k])
            
            # Store the first occurrence of the current_sum
            if current_sum not in prefix_sum_indices:
                prefix_sum_indices[current_sum] = i
        
        return max_length
```

This solution uses a hash map to keep track of the first occurrence of each prefix sum. As we iterate through the array, we calculate the current sum and check if there is a prefix sum that, when subtracted from the current sum, equals `k`. If such a prefix sum exists, we update the maximum length of the subarray. The time complexity of this solution is O(n), where n is the length of the input array, and the space complexity is also O(n) due to the hash map.

Given an integer n, return true if it is a power of three. Otherwise, return false.
An integer n is a power of three, if there exists an integer x such that n == 3x.
 
Example 1:

Input: n = 27
Output: true
Explanation: 27 = 33

Example 2:

Input: n = 0
Output: false
Explanation: There is no x where 3x = 0.

Example 3:

Input: n = -1
Output: false
Explanation: There is no x where 3x = (-1).

 
Constraints:

-231 <= n <= 231 - 1

 
Follow up: Could you solve it without loops/recursion?

To solve the problem of determining if a given integer `n` is a power of three without using loops or recursion, we can leverage the properties of logarithms. Specifically, we can use the change of base formula for logarithms to check if `n` can be expressed as `3^x`.

Here's the approach:

1. If `n` is less than or equal to 0, it cannot be a power of three.
2. Calculate the logarithm of `n` to the base 3.
3. Check if the result is an integer. If it is, then `n` is a power of three.

Since floating-point arithmetic can introduce precision issues, we can multiply the logarithm result by a large number, convert it to an integer, and then check if the rounded value raised to the power of 3 equals `n`.

Here's the implementation:

```python
import math

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        log_value = math.log(n, 3)
        rounded_log_value = round(log_value)
        return 3 ** rounded_log_value == n
```

This code will correctly determine if `n` is a power of three without using loops or recursion. Let's wrap the final answer within the provided delimiters:

```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        log_value = math.log(n, 3)
        rounded_log_value = round(log_value)
        return 3 ** rounded_log_value == n
```

Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.
Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.
 
Example 1:

Input: nums = [-2,5,-1], lower = -2, upper = 2
Output: 3
Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.

Example 2:

Input: nums = [0], lower = 0, upper = 0
Output: 1

 
Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
-105 <= lower <= upper <= 105
The answer is guaranteed to fit in a 32-bit integer.



```python
from typing import List
import bisect

class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        # Initialize prefix sums array with 0 to handle prefix starting from index 0
        prefix_sums = [0]
        current_sum = 0
        count = 0
        
        for num in nums:
            current_sum += num
            # We need to find the range of prefix sums that would result in a valid range sum with current_sum
            # Such that lower <= current_sum - prefix_sum <= upper
            # This can be rewritten as current_sum - upper <= prefix_sum <= current_sum - lower
            lower_bound = current_sum - upper
            upper_bound = current_sum - lower
            
            # Use binary search to find the number of valid prefix sums
            count += bisect.bisect_right(prefix_sums, upper_bound) - bisect.bisect_left(prefix_sums, lower_bound)
            
            # Insert the current prefix sum into the sorted list of prefix sums
            bisect.insort(prefix_sums, current_sum)
        
        return count
```

### Explanation:
The solution uses a combination of prefix sums and binary search to efficiently count the number of valid range sums. The prefix sum array helps in quickly calculating the sum of any subarray. For each element in the input array, we update the current prefix sum and then use binary search to count how many previous prefix sums would result in a valid range sum when subtracted from the current prefix sum. This approach ensures that the solution is efficient even for large input sizes, adhering to the constraints provided.

Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.
You must solve the problem in O(1) extra space complexity and O(n) time complexity.
 
Example 1:


Input: head = [1,2,3,4,5]
Output: [1,3,5,2,4]

Example 2:


Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]

 
Constraints:

The number of nodes in the linked list is in the range [0, 104].
-106 <= Node.val <= 106



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next or not head.next.next:
            return head
        
        # Initialize pointers for odd and even nodes
        odd_head = head
        even_head = head.next
        odd = odd_head
        even = even_head
        
        # Iterate through the list, rearranging nodes
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        
        # Connect the end of odd list to the head of even list
        odd.next = even_head
        
        return odd_head
```

This solution maintains the relative order of nodes with odd and even indices while ensuring O(1) extra space complexity and O(n) time complexity. The key idea is to rearrange the pointers in place, separating odd and even indexed nodes and then joining them at the end.

Given an m x n integers matrix, return the length of the longest increasing path in matrix.
From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).
 
Example 1:


Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].

Example 2:


Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

Example 3:

Input: matrix = [[1]]
Output: 1

 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
0 <= matrix[i][j] <= 231 - 1



```python
from typing import List

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        
        m, n = len(matrix), len(matrix[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        dp = [[-1] * n for _ in range(m)]
        
        def dfs(x, y):
            if dp[x][y] != -1:
                return dp[x][y]
            
            max_length = 1
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]:
                    max_length = max(max_length, 1 + dfs(nx, ny))
            
            dp[x][y] = max_length
            return max_length
        
        longest_path = 0
        for i in range(m):
            for j in range(n):
                longest_path = max(longest_path, dfs(i, j))
        
        return longest_path
```

This solution uses Depth-First Search (DFS) with memoization (dynamic programming) to find the longest increasing path in the matrix. The `dfs` function is used to explore all possible paths starting from a given cell, and the results are stored in the `dp` table to avoid redundant calculations. The `longest_path` variable keeps track of the maximum path length found during the exploration.

Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.
Return the minimum number of patches required.
 
Example 1:

Input: nums = [1,3], n = 6
Output: 1
Explanation:
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
So we only need 1 patch.

Example 2:

Input: nums = [1,5,10], n = 20
Output: 2
Explanation: The two patches can be [2, 4].

Example 3:

Input: nums = [1,2,2], n = 5
Output: 0

 
Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 104
nums is sorted in ascending order.
1 <= n <= 231 - 1



```python
from typing import List

class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        miss = 1
        patches = 0
        i = 0
        
        while miss <= n:
            if i < len(nums) and nums[i] <= miss:
                miss += nums[i]
                i += 1
            else:
                miss += miss
                patches += 1
        
        return patches
```

This solution uses a greedy algorithm to solve the problem. The idea is to keep track of the smallest number (`miss`) that we cannot form with the current set of numbers. If the current number in `nums` can help us form `miss`, we add it to `miss`. If not, we add `miss` itself to the set of numbers we can form (as a patch) and double `miss`. This ensures that we are always extending the range of numbers we can form in the most efficient way. The process continues until `miss` exceeds `n`, meaning we can form all numbers up to `n`.

One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'.

For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where '#' represents a null node.
Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.
It is guaranteed that each comma-separated value in the string must be either an integer or a character '#' representing null pointer.
You may assume that the input format is always valid.

For example, it could never contain two consecutive commas, such as "1,,3".

Note: You are not allowed to reconstruct the tree.
 
Example 1:
Input: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
Output: true
Example 2:
Input: preorder = "1,#"
Output: false
Example 3:
Input: preorder = "9,#,#,1"
Output: false

 
Constraints:

1 <= preorder.length <= 104
preorder consist of integers in the range [0, 100] and '#' separated by commas ','.



```python
class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        # Split the input string by commas to get the list of nodes
        nodes = preorder.split(',')
        
        # Initialize a stack to keep track of the number of available slots
        stack = [1]  # We start with one slot for the root node
        
        for node in nodes:
            if not stack:
                # If there are no available slots, the serialization is invalid
                return False
            
            # Use up one slot
            stack[-1] -= 1
            
            if stack[-1] == 0:
                # If the current node uses up the last slot of its parent, pop the stack
                stack.pop()
            
            if node != '#':
                # If the current node is not null, it creates two new slots
                stack.append(2)
        
        # In the end, there should be no available slots left
        return not stack
```

This solution uses a stack to keep track of the number of available slots for nodes. It processes each node in the preorder traversal and updates the stack accordingly. If there are no slots available when a node is processed, or if there are slots left after processing all nodes, the serialization is invalid.

You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.
All of the tickets belong to a man who departs from "JFK", thus, the itinerary must begin with "JFK". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].

You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.
 
Example 1:


Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]

Example 2:


Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.

 
Constraints:

1 <= tickets.length <= 300
tickets[i].length == 2
fromi.length == 3
toi.length == 3
fromi and toi consist of uppercase English letters.
fromi != toi



```python
from typing import List
from collections import defaultdict

class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        # Create a graph from the tickets
        graph = defaultdict(list)
        for u, v in tickets:
            graph[u].append(v)
        
        # Sort the destinations in lexical order
        for u in graph:
            graph[u].sort()
        
        # Result itinerary
        itinerary = []
        
        # Depth-first search function
        def dfs(city):
            # Visit all the neighbors of the current city
            while graph[city]:
                neighbor = graph[city].pop(0)
                dfs(neighbor)
            # Append the city to the itinerary
            itinerary.append(city)
        
        # Start the DFS from "JFK"
        dfs("JFK")
        
        # The itinerary is constructed in reverse order
        return itinerary[::-1]
```

This code constructs the itinerary by using a depth-first search (DFS) approach to traverse the graph formed by the tickets. The graph is represented as an adjacency list, and the destinations are sorted in lexical order to ensure the smallest lexical order for the itinerary. The DFS function visits all the neighbors of the current city, and once all neighbors are visited, the city is added to the itinerary. Since the cities are added in reverse order, the itinerary is reversed before being returned.

Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.
A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties:

The left subtree values are less than the value of their parent (root) node's value.
The right subtree values are greater than the value of their parent (root) node's value.

Note: A subtree must include all of its descendants.
 
Example 1:


Input: root = [10,5,15,1,8,null,7]
Output: 3
Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3.
Example 2:

Input: root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1]
Output: 2

 
Constraints:

The number of nodes in the tree is in the range [0, 104].
-104 <= Node.val <= 104

 
Follow up: Can you figure out ways to solve it with O(n) time complexity?


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestBSTSubtree(self, root: Optional[TreeNode]) -> int:
        def helper(node):
            if not node:
                return float('inf'), float('-inf'), 0  # min, max, size
            
            left_min, left_max, left_size = helper(node.left)
            right_min, right_max, right_size = helper(node.right)
            
            if left_max < node.val < right_min:
                return min(node.val, left_min), max(node.val, right_max), left_size + right_size + 1
            
            return float('-inf'), float('inf'), max(left_size, right_size)
        
        return helper(root)[2]
```

This solution works by performing a post-order traversal of the tree. For each node, it returns a tuple containing the minimum value, maximum value, and size of the largest BST subtree rooted at that node. The solution ensures that the left subtree values are less than the current node's value and the right subtree values are greater than the current node's value, which are the properties of a BST. The function then returns the size of the largest BST subtree found in the entire tree. This approach runs in O(n) time complexity, where n is the number of nodes in the tree, as it visits each node exactly once.

Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.
 
Example 1:

Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.

Example 2:

Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.

Example 3:

Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.

 
Constraints:

1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1

 
Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity?

```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        first = second = float('inf')
        for num in nums:
            if num <= first:
                first = num
            elif num <= second:
                second = num
            else:
                return True
        return False
```

This solution iterates through the list `nums` once, maintaining two variables `first` and `second` to track the smallest and the second smallest numbers found so far. If a number greater than both `first` and `second` is found, it means there is an increasing triplet subsequence, and the function returns `True`. If the loop completes without finding such a triplet, the function returns `False`. This approach ensures O(n) time complexity and O(1) space complexity.

You are given an array of integers distance.
You start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.
Return true if your path crosses itself or false if it does not.
 
Example 1:


Input: distance = [2,1,1,2]
Output: true
Explanation: The path crosses itself at the point (0, 1).

Example 2:


Input: distance = [1,2,3,4]
Output: false
Explanation: The path does not cross itself at any point.

Example 3:


Input: distance = [1,1,1,2,1]
Output: true
Explanation: The path crosses itself at the point (0, 0).

 
Constraints:

1 <= distance.length <= 105
1 <= distance[i] <= 105



```python
from typing import List

class Solution:
    def isSelfCrossing(self, distance: List[int]) -> bool:
        # If there are less than 4 lines, it cannot cross itself
        if len(distance) < 4:
            return False
        
        # Iterate through the distance array starting from the 4th element
        for i in range(3, len(distance)):
            # Case 1: The current line crosses the line 3 steps ahead
            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:
                return True
            # Case 2: The current line crosses the line 4 steps ahead
            if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:
                return True
            # Case 3: The current line crosses the line 5 steps ahead
            if i >= 5 and distance[i - 2] >= distance[i - 4] and distance[i - 3] >= distance[i - 1] and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3]:
                return True
        
        return False
```

This solution checks for three specific cases where the path can cross itself:

1. **Case 1**: The current line crosses the line 3 steps ahead.
2. **Case 2**: The current line crosses the line 4 steps ahead.
3. **Case 3**: The current line crosses the line 5 steps ahead.

By iterating through the distance array and checking these conditions, the function determines if the path crosses itself.

You are given a 0-indexed array of unique strings words.
A palindrome pair is a pair of integers (i, j) such that:

0 <= i, j < words.length,
i != j, and
words[i] + words[j] (the concatenation of the two strings) is a palindrome.

Return an array of all the palindrome pairs of words.
You must write an algorithm with O(sum of words[i].length) runtime complexity.
 
Example 1:

Input: words = ["abcd","dcba","lls","s","sssll"]
Output: [[0,1],[1,0],[3,2],[2,4]]
Explanation: The palindromes are ["abcddcba","dcbaabcd","slls","llssssll"]

Example 2:

Input: words = ["bat","tab","cat"]
Output: [[0,1],[1,0]]
Explanation: The palindromes are ["battab","tabbat"]

Example 3:

Input: words = ["a",""]
Output: [[0,1],[1,0]]
Explanation: The palindromes are ["a","a"]

 
Constraints:

1 <= words.length <= 5000
0 <= words[i].length <= 300
words[i] consists of lowercase English letters.



```python
from typing import List

class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        def is_palindrome(s):
            return s == s[::-1]
        
        word_dict = {word: i for i, word in enumerate(words)}
        result = []
        
        for i, word in enumerate(words):
            for j in range(len(word) + 1):
                prefix = word[:j]
                suffix = word[j:]
                
                # Check if reverse prefix is in the dictionary and suffix is a palindrome
                if prefix[::-1] in word_dict and is_palindrome(suffix) and word_dict[prefix[::-1]] != i:
                    result.append([i, word_dict[prefix[::-1]]])
                
                # Check if reverse suffix is in the dictionary and prefix is a palindrome
                if j > 0 and suffix[::-1] in word_dict and is_palindrome(prefix) and word_dict[suffix[::-1]] != i:
                    result.append([word_dict[suffix[::-1]], i])
        
        return result
```

This solution efficiently finds all palindrome pairs by leveraging a dictionary to quickly look up reversed strings and checking if the remaining parts of the strings are palindromes. The time complexity is O(sum of words[i].length) because each string is processed in linear time relative to its length, and dictionary operations are average O(1).

The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.
Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.
Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.
 
Example 1:


Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.

Example 2:


Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.

 
Constraints:

The number of nodes in the tree is in the range [1, 104].
0 <= Node.val <= 104



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if not node:
                return 0, 0  # (rob this node, not rob this node)
            
            left_rob, left_not_rob = dfs(node.left)
            right_rob, right_not_rob = dfs(node.right)
            
            # If we rob this node, we cannot rob its children
            rob_this = node.val + left_not_rob + right_not_rob
            
            # If we do not rob this node, we take the max of robbing or not robbing its children
            not_rob_this = max(left_rob, left_not_rob) + max(right_rob, right_not_rob)
            
            return rob_this, not_rob_this
        
        return max(dfs(root))
```

This solution uses a depth-first search (DFS) approach to traverse the binary tree. For each node, it calculates two values:
1. The maximum amount of money that can be robbed if this node is robbed.
2. The maximum amount of money that can be robbed if this node is not robbed.

The final result is the maximum of these two values for the root node.

Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.
 
Example 1:

Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10

Example 2:

Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101

 
Constraints:

0 <= n <= 105

 
Follow up:

It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?
Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?



```python
from typing import List

class Solution:
    def countBits(self, n: int) -> List[int]:
        # Initialize the result array with zeros
        ans = [0] * (n + 1)
        
        # Iterate through each number from 1 to n
        for i in range(1, n + 1):
            # Use the relationship between i and i >> 1 to count bits
            ans[i] = ans[i >> 1] + (i & 1)
        
        return ans
```

### Explanation:
The solution leverages the fact that the number of 1's in the binary representation of a number `i` can be derived from the number of 1's in `i >> 1` (which is `i` right-shifted by 1 bit, effectively dividing `i` by 2) plus 1 if the least significant bit of `i` is 1 (which is checked using `i & 1`).

- For even numbers, `i & 1` is 0, so `ans[i] = ans[i >> 1]`.
- For odd numbers, `i & 1` is 1, so `ans[i] = ans[i >> 1] + 1`.

This approach ensures that the solution runs in O(n) time and uses a single pass through the numbers from 0 to n.

Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.
 
Example 1:

Input: s = "eceba", k = 2
Output: 3
Explanation: The substring is "ece" with length 3.
Example 2:

Input: s = "aa", k = 1
Output: 2
Explanation: The substring is "aa" with length 2.

 
Constraints:

1 <= s.length <= 5 * 104
0 <= k <= 50



```python
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        if k == 0:
            return 0
        
        char_map = {}
        left = 0
        max_length = 0
        
        for right in range(len(s)):
            char_map[s[right]] = right
            
            if len(char_map) > k:
                # Find the leftmost character to remove
                leftmost_char = min(char_map, key=char_map.get)
                left = char_map.pop(leftmost_char) + 1
            
            max_length = max(max_length, right - left + 1)
        
        return max_length
```

This solution uses a sliding window approach with a dictionary to keep track of the characters in the current window and their most recent positions. When the number of distinct characters exceeds `k`, it removes the leftmost character from the window to maintain at most `k` distinct characters. The maximum length of the window is updated accordingly.

Given an integer n, return true if it is a power of four. Otherwise, return false.
An integer n is a power of four, if there exists an integer x such that n == 4x.
 
Example 1:
Input: n = 16
Output: true
Example 2:
Input: n = 5
Output: false
Example 3:
Input: n = 1
Output: true

 
Constraints:

-231 <= n <= 231 - 1

 
Follow up: Could you solve it without loops/recursion?

```python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0xAAAAAAAA) == 0
```

This solution uses bitwise operations to determine if a number is a power of four. Here's a breakdown of how it works:

1. `n > 0`: Ensures that the number is positive, as powers of four are positive.
2. `(n & (n - 1)) == 0`: Checks if `n` is a power of two. This works because powers of two in binary representation have exactly one bit set (e.g., 1, 10, 100, 1000, etc.). Subtracting 1 from such a number flips all the bits after the set bit, including the set bit itself, resulting in a number with no bits in common with the original number, i.e., `n & (n - 1)` equals 0.
3. `(n & 0xAAAAAAAA) == 0`: Ensures that the set bit in the binary representation of `n` is in an odd position (1st, 3rd, 5th, etc.), which is required for powers of four. The hexadecimal number `0xAAAAAAAA` has 1s in all even positions (2nd, 4th, 6th, etc.) in a 32-bit integer, so performing a bitwise AND with this number will yield 0 if the set bit in `n` is in an odd position.

Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.
Return the maximum product you can get.
 
Example 1:

Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.

Example 2:

Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.

 
Constraints:

2 <= n <= 58



```python
class Solution:
    def integerBreak(self, n: int) -> int:
        # Base cases
        if n == 2:
            return 1
        if n == 3:
            return 2
        
        # Dynamic programming array to store the maximum product for each number up to n
        dp = [0] * (n + 1)
        dp[1] = 1
        
        # Fill the dp array
        for i in range(2, n + 1):
            max_product = 0
            for j in range(1, i):
                # We compare j * (i - j) and j * dp[i - j] to consider breaking i - j further or not
                max_product = max(max_product, j * (i - j), j * dp[i - j])
            dp[i] = max_product
        
        return dp[n]
```

This solution uses dynamic programming to solve the problem. The idea is to build up the solution for the number `n` by solving smaller subproblems. For each number `i`, we try breaking it into two parts `j` and `i - j` and calculate the product. We also consider the possibility of breaking `i - j` further by using the precomputed results stored in the `dp` array. The maximum product for each number is stored in the `dp` array, and the final result is `dp[n]`.

Write a function that reverses a string. The input string is given as an array of characters s.
You must do this by modifying the input array in-place with O(1) extra memory.
 
Example 1:
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
Example 2:
Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]

 
Constraints:

1 <= s.length <= 105
s[i] is a printable ascii character.



```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

Given a string s, reverse only all the vowels in the string and return it.
The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.
 
Example 1:

Input: s = "IceCreAm"
Output: "AceCreIm"
Explanation:
The vowels in s are ['I', 'e', 'e', 'A']. On reversing the vowels, s becomes "AceCreIm".

Example 2:

Input: s = "leetcode"
Output: "leotcede"

 
Constraints:

1 <= s.length <= 3 * 105
s consist of printable ASCII characters.



```python
class Solution:
    def reverseVowels(self, s: str) -> str:
        vowels = "aeiouAEIOU"
        s_list = list(s)
        i, j = 0, len(s) - 1
        
        while i < j:
            if s_list[i] not in vowels:
                i += 1
            elif s_list[j] not in vowels:
                j -= 1
            else:
                s_list[i], s_list[j] = s_list[j], s_list[i]
                i += 1
                j -= 1
        
        return ''.join(s_list)
```

This solution uses a two-pointer approach to reverse the vowels in the string. It initializes two pointers, one at the start (`i`) and one at the end (`j`) of the string. It then iterates through the string, moving the pointers towards each other and swapping the vowels when both pointers point to a vowel. The process continues until the two pointers meet or cross each other.

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
 
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
Example 2:
Input: nums = [1], k = 1
Output: [1]

 
Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104
k is in the range [1, the number of unique elements in the array].
It is guaranteed that the answer is unique.

 
Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.


To solve this problem efficiently with a time complexity better than O(n log n), we can use a combination of a hash map to count the frequencies of the elements and a bucket sort to collect the k most frequent elements. Here's the complete solution:

```python
from typing import List
from collections import defaultdict

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # Step 1: Count the frequency of each number in nums
        frequency_map = defaultdict(int)
        for num in nums:
            frequency_map[num] += 1
        
        # Step 2: Create a list of buckets where index is the frequency
        # and the value is a list of numbers with that frequency
        max_frequency = max(frequency_map.values())
        buckets = [[] for _ in range(max_frequency + 1)]
        
        for num, freq in frequency_map.items():
            buckets[freq].append(num)
        
        # Step 3: Collect the top k frequent elements
        top_k_frequent_elements = []
        for freq in range(max_frequency, 0, -1):
            for num in buckets[freq]:
                top_k_frequent_elements.append(num)
                if len(top_k_frequent_elements) == k:
                    return top_k_frequent_elements

# Example usage:
# sol = Solution()
# print(sol.topKFrequent([1,1,1,2,2,3], 2))  # Output: [1, 2]
# print(sol.topKFrequent([1], 1))            # Output: [1]
```

### Explanation:
1. **Frequency Counting**: We first use a `defaultdict` to count how many times each number appears in the input list `nums`.

2. **Bucket Sort**: We create a list of buckets where the index represents the frequency of elements, and the value at each index is a list of elements that have that frequency. The maximum possible frequency is the length of the input list, so we initialize `max_frequency + 1` buckets.

3. **Collect Results**: We iterate from the highest frequency to the lowest, collecting elements from the buckets until we have collected `k` elements.

This approach ensures that we achieve an average time complexity of O(n), which is more efficient than O(n log n) required for sorting-based solutions.

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
 
Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.

 
Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000



```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # Convert both lists to sets to remove duplicates and allow for set operations
        set1 = set(nums1)
        set2 = set(nums2)
        
        # Find the intersection of both sets
        intersection_set = set1.intersection(set2)
        
        # Convert the set back to a list and return
        return list(intersection_set)
```

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
 
Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]

Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.

 
Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

 
Follow up:

What if the given array is already sorted? How would you optimize your algorithm?
What if nums1's size is small compared to nums2's size? Which algorithm is better?
What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?



```python
from typing import List
from collections import Counter

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # Count the frequency of each number in nums1
        count1 = Counter(nums1)
        # Initialize the result list
        result = []
        
        # Iterate through each number in nums2
        for num in nums2:
            # If the number is in count1 and has a count greater than 0
            if count1[num] > 0:
                # Append the number to the result list
                result.append(num)
                # Decrease the count of the number in count1
                count1[num] -= 1
        
        return result
```

### Explanation:
1. **Counter Usage**: We use `Counter` from the `collections` module to count the occurrences of each element in `nums1`.
2. **Iteration**: We iterate through each element in `nums2`.
3. **Checking and Appending**: For each element in `nums2`, if it exists in `count1` and its count is greater than 0, we append it to the result list and decrement its count in `count1`.
4. **Return**: Finally, we return the result list which contains the intersection of `nums1` and `nums2` with the correct multiplicities.

### Follow-up Considerations:
- **Sorted Arrays**: If both arrays are sorted, we can use a two-pointer technique to find the intersection in O(n + m) time complexity.
- **Small `nums1`**: If `nums1` is significantly smaller than `nums2`, counting elements in `nums1` first and iterating through `nums2` is efficient.
- **Disk-stored `nums2`**: If `nums2` is too large to fit into memory, we could read it in chunks or use a database index if available. We would count elements in `nums1` as before, but check against elements of `nums2` incrementally.

Android devices have a special lock screen with a 3 x 3 grid of dots. Users can set an "unlock pattern" by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of k dots is a valid unlock pattern if both of the following are true:

All the dots in the sequence are distinct.
If the line segment connecting two consecutive dots in the sequence passes through the center of any other dot, the other dot must have previously appeared in the sequence. No jumps through the center non-selected dots are allowed.
	
For example, connecting dots 2 and 9 without dots 5 or 6 appearing beforehand is valid because the line from dot 2 to dot 9 does not pass through the center of either dot 5 or 6.
However, connecting dots 1 and 3 without dot 2 appearing beforehand is invalid because the line from dot 1 to dot 3 passes through the center of dot 2.



Here are some example valid and invalid unlock patterns:


The 1st pattern [4,1,3,6] is invalid because the line connecting dots 1 and 3 pass through dot 2, but dot 2 did not previously appear in the sequence.
The 2nd pattern [4,1,9,2] is invalid because the line connecting dots 1 and 9 pass through dot 5, but dot 5 did not previously appear in the sequence.
The 3rd pattern [2,4,1,3,6] is valid because it follows the conditions. The line connecting dots 1 and 3 meets the condition because dot 2 previously appeared in the sequence.
The 4th pattern [6,5,4,1,9,2] is valid because it follows the conditions. The line connecting dots 1 and 9 meets the condition because dot 5 previously appeared in the sequence.

Given two integers m and n, return the number of unique and valid unlock patterns of the Android grid lock screen that consist of at least m keys and at most n keys.
Two unlock patterns are considered unique if there is a dot in one sequence that is not in the other, or the order of the dots is different.
 
Example 1:

Input: m = 1, n = 1
Output: 9

Example 2:

Input: m = 1, n = 2
Output: 65

 
Constraints:

1 <= m, n <= 9



```python
class Solution:
    def numberOfPatterns(self, m: int, n: int) -> int:
        # Define the jump requirements for the 3x3 grid
        jumps = {
            1: {3: 2, 7: 4, 9: 5},
            2: {8: 5},
            3: {1: 2, 7: 5, 9: 6},
            4: {6: 5},
            5: {},
            6: {4: 5},
            7: {1: 4, 3: 5, 9: 8},
            8: {2: 5},
            9: {1: 5, 3: 6, 7: 8}
        }
        
        def dfs(current, visited, length):
            if length == n:
                return 1
            count = 1 if length >= m else 0
            for next in range(1, 10):
                if next not in visited:
                    jump = jumps[current].get(next)
                    if jump is None or jump in visited:
                        visited.add(next)
                        count += dfs(next, visited, length + 1)
                        visited.remove(next)
            return count
        
        # Start from each of the 9 keys and calculate the number of patterns
        return dfs(1, {1}, 1) * 4 + dfs(2, {2}, 1) * 4 + dfs(5, {5}, 1)
```

This solution uses depth-first search (DFS) to explore all possible unlock patterns starting from each dot on the 3x3 grid. It keeps track of visited dots and ensures that any dot that is required to be jumped over has been visited previously. The solution accounts for symmetry to reduce the number of starting points, multiplying the counts from the symmetrically equivalent starting points.

You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.
One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.
Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
Note: You cannot rotate an envelope.
 
Example 1:

Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).

Example 2:

Input: envelopes = [[1,1],[1,1],[1,1]]
Output: 1

 
Constraints:

1 <= envelopes.length <= 105
envelopes[i].length == 2
1 <= wi, hi <= 105



To solve the problem of finding the maximum number of envelopes you can Russian doll, we can use a combination of sorting and dynamic programming. Here's a step-by-step explanation of the approach:

1. **Sorting**: First, we sort the envelopes. We sort primarily by width in ascending order and secondarily by height in descending order. This ensures that if two envelopes have the same width, the one with the larger height comes first. This step is crucial because it allows us to focus on the heights while ensuring that we don't mistakenly consider envelopes with the same width for Russian dolling.

2. **Dynamic Programming**: After sorting, we can focus on the heights of the envelopes. The problem now reduces to finding the longest increasing subsequence (LIS) in the heights. We use dynamic programming to find this LIS.

3. **DP Array**: We maintain a DP array where `dp[i]` represents the length of the longest increasing subsequence that ends with the `i-th` envelope's height.

4. **Filling the DP Array**: For each envelope, we check all previous envelopes to see if their heights are less than the current envelope's height. If they are, we update the DP value for the current envelope.

5. **Result**: The length of the longest increasing subsequence found in the heights will be the answer.

Here's the implementation of the solution:

```python
from typing import List

class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        # Sort the envelopes by width in ascending order and by height in descending order
        envelopes.sort(key=lambda x: (x[0], -x[1]))
        
        # Extract the heights into a separate list
        heights = [envelope[1] for envelope in envelopes]
        
        # Initialize the dp array where dp[i] is the length of the LIS ending at index i
        dp = [1] * len(heights)
        
        # Fill the dp array
        for i in range(1, len(heights)):
            for j in range(i):
                if heights[j] < heights[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        
        # The result is the maximum value in the dp array
        return max(dp)
```

This solution has a time complexity of \(O(n^2)\) due to the nested loops used to fill the DP array. Given the constraints, this approach is feasible for the maximum input size of \(10^5\) envelopes. However, for even larger inputs, a more efficient approach using binary search to achieve \(O(n \log n)\) complexity could be considered.

Given n points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.
In other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.
Note that there can be repeated points.
 
Example 1:


Input: points = [[1,1],[-1,1]]
Output: true
Explanation: We can choose the line x = 0.

Example 2:


Input: points = [[1,1],[-1,-1]]
Output: false
Explanation: We can't choose a line.

 
Constraints:

n == points.length
1 <= n <= 104
-108 <= points[i][j] <= 108

 
Follow up: Could you do better than O(n2)?


To solve this problem efficiently, we need to find a vertical line that reflects all the given points symmetrically. The key insight is that if such a line exists, the sum of the x-coordinates of any pair of points that have the same y-coordinate should be constant and equal to twice the x-coordinate of the reflection line.

Here's a step-by-step approach to solve the problem:

1. Use a set to store the points for quick lookup and to handle duplicates.
2. Find the minimum and maximum x-coordinates among all points.
3. Calculate the potential x-coordinate of the reflection line as the average of the minimum and maximum x-coordinates.
4. For each point, check if its reflected counterpart (with respect to the calculated line) exists in the set of points.
5. If all points have their reflected counterparts, return `True`. Otherwise, return `False`.

This approach ensures that we only traverse the list of points a couple of times, resulting in an O(n) time complexity.

Here's the implementation:

```python
from typing import List

class Solution:
    def isReflected(self, points: List[List[int]]) -> bool:
        if not points:
            return True
        
        # Use a set to store unique points
        point_set = set(tuple(point) for point in points)
        
        # Find the minimum and maximum x-coordinates
        min_x = min(point[0] for point in points)
        max_x = max(point[0] for point in points)
        
        # Calculate the potential reflection line x-coordinate
        reflection_line = min_x + max_x
        
        # Check for each point if its reflected counterpart exists
        for x, y in point_set:
            reflected_x = reflection_line - x
            if (reflected_x, y) not in point_set:
                return False
        
        return True
```

This solution efficiently checks for the existence of a reflective line by leveraging the properties of sets for quick lookups and ensuring that each point has its symmetric counterpart with respect to the calculated reflection line.

Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.
 
Example 1:

Input: n = 2
Output: 91
Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100, excluding 11,22,33,44,55,66,77,88,99

Example 2:

Input: n = 0
Output: 1

 
Constraints:

0 <= n <= 8



```python
class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        if n == 0:
            return 1
        if n == 1:
            return 10
        
        # Start with numbers from 0 to 9
        count = 10
        # For the first digit, we have 9 options (1-9)
        # For the second digit, we have 9 options (0-9 except the first digit)
        # For the third digit, we have 8 options (0-9 except the first two digits)
        # And so on...
        unique_digits_count = 9
        available_digits = 9
        
        for i in range(2, n + 1):
            unique_digits_count *= available_digits
            count += unique_digits_count
            available_digits -= 1
        
        return count
```

This solution calculates the count of numbers with unique digits for a given `n` by considering the number of choices for each digit position. It starts with the base cases for `n = 0` and `n = 1`, and then iteratively calculates the count for larger values of `n` by reducing the number of available digits for each subsequent position.

Given a string s and an integer k, rearrange s such that the same characters are at least distance k from each other. If it is not possible to rearrange the string, return an empty string "".
 
Example 1:

Input: s = "aabbcc", k = 3
Output: "abcabc"
Explanation: The same letters are at least a distance of 3 from each other.

Example 2:

Input: s = "aaabc", k = 3
Output: ""
Explanation: It is not possible to rearrange the string.

Example 3:

Input: s = "aaadbbcc", k = 2
Output: "abacabcd"
Explanation: The same letters are at least a distance of 2 from each other.

 
Constraints:

1 <= s.length <= 3 * 105
s consists of only lowercase English letters.
0 <= k <= s.length



```python
from collections import Counter, deque
from heapq import heapify, heappop, heappush

class Solution:
    def rearrangeString(self, s: str, k: int) -> str:
        h = [(-v, c) for c, v in Counter(s).items()]
        heapify(h)
        q = deque()
        ans = []
        while h:
            v, c = heappop(h)
            v *= -1
            ans.append(c)
            q.append((v - 1, c))
            if len(q) >= k:
                w, c = q.popleft()
                if w:
                    heappush(h, (-w, c))
        return "" if len(ans) != len(s) else "".join(ans)
```

This solution uses a max-heap to always try to place the most frequent character available, ensuring that the same characters are at least `k` distance apart. It uses a queue to keep track of characters that are on cooldown (i.e., cannot be placed yet to maintain the `k` distance requirement). If the final arrangement does not match the length of the original string, it means it's not possible to rearrange the string to meet the conditions, and an empty string is returned.

Given a sorted integer array nums and three integers a, b and c, apply a quadratic function of the form f(x) = ax2 + bx + c to each element nums[i] in the array, and return the array in a sorted order.
 
Example 1:
Input: nums = [-4,-2,2,4], a = 1, b = 3, c = 5
Output: [3,9,15,33]
Example 2:
Input: nums = [-4,-2,2,4], a = -1, b = 3, c = 5
Output: [-23,-5,1,7]

 
Constraints:

1 <= nums.length <= 200
-100 <= nums[i], a, b, c <= 100
nums is sorted in ascending order.

 
Follow up: Could you solve it in O(n) time?


To solve this problem in O(n) time, we can take advantage of the properties of quadratic functions and the fact that the input array is already sorted. The key observation is that the quadratic function can either be convex (if `a > 0`) or concave (if `a < 0`). In both cases, the function values will be either largest at the ends or at the center, depending on the sign of `a`.

Here's the step-by-step approach:
1. If `a == 0`, the function is linear. The sorted order will depend on the sign of `b`.
2. If `a > 0` (convex), the parabola opens upwards, and the largest values will be at the ends of the array. We can fill the result array from the end towards the beginning.
3. If `a < 0` (concave), the parabola opens downwards, and the smallest values will be at the ends of the array. We can fill the result array from the beginning towards the end.

Let's implement this approach in the provided starter code:
```python
from typing import List

class Solution:
    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -> List[int]:
        def quadratic(x):
            return a * x * x + b * x + c
        
        n = len(nums)
        result = [0] * n
        left, right = 0, n - 1
        fill_index = n - 1 if a >= 0 else 0
        
        while left <= right:
            left_val = quadratic(nums[left])
            right_val = quadratic(nums[right])
            
            if (a >= 0 and left_val > right_val) or (a < 0 and left_val < right_val):
                result[fill_index] = left_val
                left += 1
            else:
                result[fill_index] = right_val
                right -= 1
            
            fill_index += 1 if a < 0 else -1
        
        return result
```

This solution works as follows:
- We define a helper function `quadratic` to compute the value of the quadratic function for a given input `x`.
- We initialize two pointers, `left` and `right`, to the start and end of the array, respectively.
- We determine the fill direction (`fill_index`) based on the sign of `a`.
- We iterate through the array, comparing the transformed values at the `left` and `right` pointers.
- Depending on the sign of `a`, we place the larger or smaller value at the current `fill_index` and adjust the pointers accordingly.
- Finally, we return the sorted result array.

Given an m x n matrix grid where each cell is either a wall 'W', an enemy 'E' or empty '0', return the maximum enemies you can kill using one bomb. You can only place the bomb in an empty cell.
The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.
 
Example 1:


Input: grid = [["0","E","0","0"],["E","0","W","E"],["0","E","0","0"]]
Output: 3

Example 2:


Input: grid = [["W","W","W"],["0","0","0"],["E","E","E"]]
Output: 1

 
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid[i][j] is either 'W', 'E', or '0'.



```python
from typing import List

class Solution:
    def maxKilledEnemies(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        max_kills = 0
        
        # Create a 3D array to store the number of enemies killed in each direction
        # dp[i][j][0] -> left, dp[i][j][1] -> right, dp[i][j][2] -> up, dp[i][j][3] -> down
        dp = [[[0] * 4 for _ in range(n)] for _ in range(m)]
        
        # Fill the dp array for left and up directions
        for i in range(m):
            for j in range(n):
                if grid[i][j] != 'W':
                    if j > 0:
                        dp[i][j][0] = dp[i][j-1][0] + (1 if grid[i][j-1] == 'E' else 0)
                    if i > 0:
                        dp[i][j][2] = dp[i-1][j][2] + (1 if grid[i-1][j] == 'E' else 0)
        
        # Fill the dp array for right and down directions and calculate the maximum kills
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                if grid[i][j] != 'W':
                    if j < n - 1:
                        dp[i][j][1] = dp[i][j+1][1] + (1 if grid[i][j+1] == 'E' else 0)
                    if i < m - 1:
                        dp[i][j][3] = dp[i+1][j][3] + (1 if grid[i+1][j] == 'E' else 0)
                
                if grid[i][j] == '0':
                    max_kills = max(max_kills, sum(dp[i][j]))
        
        return max_kills
```

This solution efficiently calculates the maximum number of enemies that can be killed by placing a bomb in an empty cell. It uses dynamic programming to store the number of enemies that can be killed in each direction (left, right, up, down) from each cell. The solution then iterates through the grid to find the empty cell with the maximum possible kills.

Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.
It is guaranteed that there will be a rectangle with a sum no larger than k.
 
Example 1:


Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2
Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).

Example 2:

Input: matrix = [[2,2,-1]], k = 3
Output: 3

 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-100 <= matrix[i][j] <= 100
-105 <= k <= 105

 
Follow up: What if the number of rows is much larger than the number of columns?


To solve this problem, we need to find the maximum sum of a submatrix within a given matrix such that the sum is no larger than a specified integer \( k \). The approach involves using a combination of prefix sums and binary search.

Here's a step-by-step breakdown of the solution:

1. **Prefix Sum for Rows**: For each pair of rows, compute the prefix sum for each column between these two rows. This helps in reducing the 2D problem into a 1D problem.

2. **Find Maximum Subarray Sum ≤ k**: For each pair of rows, treat the column sums as a 1D array and find the maximum subarray sum that is no larger than \( k \). This can be efficiently done using a combination of prefix sums and a sorted list to perform binary search.

3. **Use Sorted List for Binary Search**: As we compute the prefix sums for columns, we maintain a sorted list of these sums. This allows us to quickly find the smallest prefix sum that, when subtracted from the current prefix sum, gives a value no larger than \( k \).

4. **Iterate Over All Row Pairs**: Repeat the above steps for all possible pairs of rows to ensure we consider all possible submatrices.

Here is the complete solution:

```python
from typing import List
import bisect

class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        if not matrix or not matrix[0]:
            return 0
        
        m, n = len(matrix), len(matrix[0])
        max_sum = float('-inf')
        
        for top in range(m):
            row_sums = [0] * n
            for bottom in range(top, m):
                for col in range(n):
                    row_sums[col] += matrix[bottom][col]
                
                # Now we need to find the max subarray sum no larger than k
                # Using prefix sum and binary search
                curr_sum, prefix_sums = 0, [0]
                for num in row_sums:
                    curr_sum += num
                    # We want to find the smallest prefix sum such that curr_sum - prefix_sum <= k
                    # This is equivalent to finding the smallest prefix_sum such that prefix_sum >= curr_sum - k
                    idx = bisect.bisect_left(prefix_sums, curr_sum - k)
                    if idx < len(prefix_sums):
                        max_sum = max(max_sum, curr_sum - prefix_sums[idx])
                    # Insert the current prefix sum into the sorted list
                    bisect.insort(prefix_sums, curr_sum)
        
        return max_sum
```

### Explanation:
- **Prefix Sum Calculation**: For each pair of rows (from `top` to `bottom`), we calculate the sum of elements in each column. This reduces the problem to finding a maximum subarray sum in a 1D array.
- **Binary Search for Subarray Sum**: We use a sorted list `prefix_sums` to keep track of the prefix sums we've seen so far. For each prefix sum `curr_sum`, we binary search for the smallest prefix sum `prefix_sums[idx]` such that `curr_sum - prefix_sums[idx] <= k`. This gives us the maximum subarray sum no larger than \( k \) efficiently.
- **Insertion and Maintenance**: We insert each `curr_sum` into the sorted list `prefix_sums` to maintain the sorted order, which allows us to perform binary search efficiently.

This approach ensures that we consider all possible submatrices and find the one with the maximum sum no larger than \( k \). The time complexity is \( O(m^2 \cdot n \cdot \log n) \), which is efficient given the constraints.

You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach target using the following operations:

Fill either jug completely with water.
Completely empty either jug.
Pour water from one jug into another until the receiving jug is full, or the transferring jug is empty.

 
Example 1: 

Input:   x = 3, y = 5, target = 4 
Output:   true 
Explanation:
Follow these steps to reach a total of 4 liters:

Fill the 5-liter jug (0, 5).
Pour from the 5-liter jug into the 3-liter jug, leaving 2 liters (3, 2).
Empty the 3-liter jug (0, 2).
Transfer the 2 liters from the 5-liter jug to the 3-liter jug (2, 0).
Fill the 5-liter jug again (2, 5).
Pour from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. This leaves 4 liters in the 5-liter jug (3, 4).
Empty the 3-liter jug. Now, you have exactly 4 liters in the 5-liter jug (0, 4).

Reference: The Die Hard example.

Example 2: 

Input:   x = 2, y = 6, target = 5 
Output:   false 

Example 3: 

Input:   x = 1, y = 2, target = 3 
Output:   true 
Explanation: Fill both jugs. The total amount of water in both jugs is equal to 3 now.

 
Constraints:

1 <= x, y, target <= 103



```python
class Solution:
    def canMeasureWater(self, x: int, y: int, target: int) -> bool:
        # Edge cases
        if target == 0:
            return True
        if target > x + y:
            return False
        
        # The idea is to use the properties of the GCD (Greatest Common Divisor)
        # We can measure target liters if and only if target is a multiple of GCD(x, y)
        # and target is less than or equal to x + y
        
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a
        
        return target % gcd(x, y) == 0
```

This solution leverages the mathematical property that the target amount of water can be measured if and only if it is a multiple of the greatest common divisor (GCD) of the capacities of the two jugs, and the target is less than or equal to the sum of the capacities of the two jugs. This approach is efficient and works within the given constraints.

Given the root of a binary tree, collect a tree's nodes as if you were doing this:

Collect all the leaf nodes.
Remove all the leaf nodes.
Repeat until the tree is empty.

 
Example 1:


Input: root = [1,2,3,4,5]
Output: [[4,5,3],[2],[1]]
Explanation:
[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned.

Example 2:

Input: root = [1]
Output: [[1]]

 
Constraints:

The number of nodes in the tree is in the range [1, 100].
-100 <= Node.val <= 100



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findLeaves(self, root: Optional[TreeNode]) -> List[List[int]]:
        def collectLeaves(node):
            if not node:
                return -1
            
            # Recursively collect leaves from the left and right subtrees
            left_height = collectLeaves(node.left)
            right_height = collectLeaves(node.right)
            
            # Current node's height is the max of its subtrees' heights plus one
            current_height = max(left_height, right_height) + 1
            
            # Ensure the result list has a list for the current height
            if current_height >= len(result):
                result.append([])
            
            # Add the current node's value to the list corresponding to its height
            result[current_height].append(node.val)
            
            return current_height
        
        result = []
        collectLeaves(root)
        return result
```

This solution uses a helper function `collectLeaves` that performs a post-order traversal of the tree. The height of each node is determined by the height of its tallest subtree plus one. Nodes with the same height (i.e., nodes that are leaves at the same level of removal) are grouped together in the `result` list. The function returns the height of the node, which helps in determining the correct list to append the node's value to.

Given a positive integer num, return true if num is a perfect square or false otherwise.
A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.
You must not use any built-in library function, such as sqrt.
 
Example 1:

Input: num = 16
Output: true
Explanation: We return true because 4 * 4 = 16 and 4 is an integer.

Example 2:

Input: num = 14
Output: false
Explanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.

 
Constraints:

1 <= num <= 231 - 1



```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num == 1:
            return True
        
        left, right = 1, num // 2
        
        while left <= right:
            mid = (left + right) // 2
            mid_squared = mid * mid
            
            if mid_squared == num:
                return True
            elif mid_squared < num:
                left = mid + 1
            else:
                right = mid - 1
        
        return False
```

This solution uses a binary search approach to determine if a given number is a perfect square without using any built-in library functions like `sqrt`. The binary search is performed between 1 and `num // 2` (since no number greater than `num // 2` squared can equal `num` for `num > 1`). If a `mid` value squared equals `num`, then `num` is a perfect square. If `mid_squared` is less than `num`, the search continues in the higher half; otherwise, it continues in the lower half. If no perfect square root is found, the function returns `False`.

Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:

answer[i] % answer[j] == 0, or
answer[j] % answer[i] == 0

If there are multiple solutions, return any of them.
 
Example 1:

Input: nums = [1,2,3]
Output: [1,2]
Explanation: [1,3] is also accepted.

Example 2:

Input: nums = [1,2,4,8]
Output: [1,2,4,8]

 
Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 2 * 109
All the integers in nums are unique.



```python
from typing import List

class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        f = [1] * n
        k = 0
        for i in range(n):
            for j in range(i):
                if nums[i] % nums[j] == 0:
                    f[i] = max(f[i], f[j] + 1)
            if f[k] < f[i]:
                k = i
        m = f[k]
        i = k
        ans = []
        while m:
            if nums[k] % nums[i] == 0 and f[i] == m:
                ans.append(nums[i])
                k, m = i, m - 1
            i -= 1
        return ans
```

This code implements the solution using dynamic programming. It first sorts the input list `nums`. It then uses a list `f` to keep track of the size of the largest divisible subset ending at each index. The variable `k` keeps track of the index of the last element of the largest subset found. Finally, it reconstructs the largest subset by backtracking from the last element of the subset.

Given a non-negative integer represented as a linked list of digits, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list.
 
Example 1:
Input: head = [1,2,3]
Output: [1,2,4]
Example 2:
Input: head = [0]
Output: [1]

 
Constraints:

The number of nodes in the linked list is in the range [1, 100].
0 <= Node.val <= 9
The number represented by the linked list does not contain leading zeros except for the zero itself. 



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def plusOne(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Helper function to reverse the linked list
        def reverseList(node):
            prev = None
            current = node
            while current:
                next_node = current.next
                current.next = prev
                prev = current
                current = next_node
            return prev
        
        # Reverse the linked list to make it easier to add one
        reversed_head = reverseList(head)
        
        # Traverse the reversed list and add one
        carry = 1
        current = reversed_head
        prev = None
        while current and carry:
            current.val += carry
            carry = current.val // 10
            current.val %= 10
            prev = current
            current = current.next
        
        # If there's still a carry, add a new node
        if carry:
            prev.next = ListNode(carry)
        
        # Reverse the list back to its original order
        return reverseList(reversed_head)
```

You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].
You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi] by inci.
Return arr after applying all the updates.
 
Example 1:


Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
Output: [-2,0,3,5,3]

Example 2:

Input: length = 10, updates = [[2,4,6],[5,6,8],[1,9,-4]]
Output: [0,-4,2,2,2,4,4,-4,-4,-4]

 
Constraints:

1 <= length <= 105
0 <= updates.length <= 104
0 <= startIdxi <= endIdxi < length
-1000 <= inci <= 1000



```python
from typing import List

class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -> List[int]:
        # Initialize the array with zeros
        arr = [0] * length
        
        # Apply the difference array technique
        for startIdx, endIdx, inc in updates:
            arr[startIdx] += inc
            if endIdx + 1 < length:
                arr[endIdx + 1] -= inc
        
        # Convert the difference array to the final array
        for i in range(1, length):
            arr[i] += arr[i - 1]
        
        return arr
```

This solution uses the difference array technique to efficiently apply the range updates. Instead of updating each element in the range `[startIdx, endIdx]` directly, which would be inefficient for large arrays and many updates, we only update the start and end+1 positions. After processing all updates, we convert the difference array back to the final array by taking cumulative sums. This approach ensures that the solution is efficient with a time complexity of O(length + updates.length).

Given two integers a and b, return the sum of the two integers without using the operators + and -.
 
Example 1:
Input: a = 1, b = 2
Output: 3
Example 2:
Input: a = 2, b = 3
Output: 5

 
Constraints:

-1000 <= a, b <= 1000



```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        # 32 bits integer max
        MAX = 0x7FFFFFFF
        # Mask to get 32 bits
        mask = 0xFFFFFFFF
        
        while b != 0:
            # Calculate carry
            carry = (a & b) << 1
            # Sum without carry
            a = (a ^ b) & mask
            # Update b to carry
            b = carry & mask
        
        # If a is negative, get a's 32 bits complement positive first
        # then get 32-bit positive's Python complement negative
        return a if a <= MAX else ~(a ^ mask)
```

This solution uses bitwise operations to simulate the addition of two integers without using the `+` or `-` operators. It handles both positive and negative integers within the given constraints.

You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.
Define a pair (u, v) which consists of one element from the first array and one element from the second array.
Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.
 
Example 1:

Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

Example 2:

Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

 
Constraints:

1 <= nums1.length, nums2.length <= 105
-109 <= nums1[i], nums2[i] <= 109
nums1 and nums2 both are sorted in non-decreasing order.
1 <= k <= 104
k <= nums1.length * nums2.length



```python
from typing import List
import heapq

class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2 or k <= 0:
            return []
        
        min_heap = []
        # Initialize the heap with the first pair from nums1 and each element from nums2
        for i in range(min(k, len(nums1))):
            heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
        
        result = []
        # Extract the smallest pairs from the heap
        while k > 0 and min_heap:
            sum_val, i, j = heapq.heappop(min_heap)
            result.append([nums1[i], nums2[j]])
            k -= 1
            # If there are more elements in nums2, push the next pair from nums1[i] and nums2[j+1]
            if j + 1 < len(nums2):
                heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        
        return result
```

This solution uses a min-heap to efficiently find the k pairs with the smallest sums. The heap is initialized with pairs consisting of elements from `nums1` and the first element of `nums2`. As elements are popped from the heap, the next possible pair from the same element in `nums1` and the next element in `nums2` is pushed onto the heap. This ensures that the smallest sums are always considered first. The process continues until k pairs are found or the heap is exhausted.

We are playing the Guessing Game. The game will work as follows:

I pick a number between 1 and n.
You guess a number.
If you guess the right number, you win the game.
If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.
Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.

Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.
 
Example 1:


Input: n = 10
Output: 16
Explanation: The winning strategy is as follows:
- The range is [1,10]. Guess 7.
    - If this is my number, your total is $0. Otherwise, you pay $7.
    - If my number is higher, the range is [8,10]. Guess 9.
        - If this is my number, your total is $7. Otherwise, you pay $9.
        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.
        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.
    - If my number is lower, the range is [1,6]. Guess 3.
        - If this is my number, your total is $7. Otherwise, you pay $3.
        - If my number is higher, the range is [4,6]. Guess 5.
            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.
            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.
            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.
        - If my number is lower, the range is [1,2]. Guess 1.
            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.
            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.
The worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.

Example 2:

Input: n = 1
Output: 0
Explanation: There is only one possible number, so you can guess 1 and not have to pay anything.

Example 3:

Input: n = 2
Output: 1
Explanation: There are two possible numbers, 1 and 2.
- Guess 1.
    - If this is my number, your total is $0. Otherwise, you pay $1.
    - If my number is higher, it must be 2. Guess 2. Your total is $1.
The worst case is that you pay $1.

 
Constraints:

1 <= n <= 200



To solve this problem, we can use dynamic programming to minimize the maximum cost in the worst-case scenario. The idea is to use a 2D table `dp` where `dp[i][j]` represents the minimum amount of money required to guarantee a win for the range of numbers from `i` to `j`.

Here's the step-by-step approach:

1. **Initialize the DP Table**: Create a 2D list `dp` with dimensions `(n+1) x (n+1)` and initialize all values to 0.

2. **Fill the DP Table**: We will fill the table for subproblems starting from smaller ranges to larger ranges. For each range `[i, j]`, we will consider each possible guess `k` in the range and calculate the cost as `k + max(dp[i][k-1], dp[k+1][j])`. We will take the minimum of these costs to ensure we are minimizing the maximum cost in the worst case.

3. **Iterate Over All Ranges**: Use nested loops to iterate over all possible ranges `[i, j]` and fill the table accordingly.

4. **Result**: The value `dp[1][n]` will give us the minimum amount of money required to guarantee a win for the range from 1 to `n`.

Here is the implementation of the above approach:

```python
class Solution:
    def getMoneyAmount(self, n: int) -> int:
        # Create a 2D list dp with dimensions (n+1) x (n+1) initialized to 0
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        
        # Fill the dp table for all ranges [i, j]
        for length in range(2, n + 1):  # length of the range
            for i in range(1, n - length + 2):  # start of the range
                j = i + length - 1  # end of the range
                dp[i][j] = float('inf')  # Initialize to infinity
                for k in range(i, j + 1):  # possible guesses
                    cost = k + max(dp[i][k - 1] if k > i else 0, dp[k + 1][j] if k < j else 0)
                    dp[i][j] = min(dp[i][j], cost)
        
        # The result is the minimum amount of money required to guarantee a win for the range [1, n]
        return dp[1][n]
```

This solution uses dynamic programming to efficiently compute the minimum cost required to guarantee a win in the worst-case scenario. The time complexity is \(O(n^3)\) due to the three nested loops, and the space complexity is \(O(n^2)\) for the `dp` table. This is efficient enough given the constraint \(1 \leq n \leq 200\).

A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.

For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.

A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.
Given an integer array nums, return the length of the longest wiggle subsequence of nums.
 
Example 1:

Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).

Example 2:

Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).

Example 3:

Input: nums = [1,2,3,4,5,6,7,8,9]
Output: 2

 
Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 1000

 
Follow up: Could you solve this in O(n) time?


```python
from typing import List

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return len(nums)
        
        # Initialize the direction of the first wiggle
        up = None
        max_length = 1
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                if up is False or up is None:
                    up = True
                    max_length += 1
            elif nums[i] < nums[i - 1]:
                if up is True or up is None:
                    up = False
                    max_length += 1
        
        return max_length
```

This solution iterates through the list of numbers once, maintaining a variable `up` to track the direction of the last wiggle. It updates the `max_length` whenever a valid wiggle is found. The time complexity of this solution is O(n), where n is the length of the input list `nums`.

Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.
The test cases are generated so that the answer can fit in a 32-bit integer.
 
Example 1:

Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.

Example 2:

Input: nums = [9], target = 3
Output: 0

 
Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 1000
All the elements of nums are unique.
1 <= target <= 1000

 
Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?


To solve the problem of finding the number of possible combinations that add up to a given target using an array of distinct integers, we can use dynamic programming. The idea is to build up a solution by solving smaller subproblems.

Here's the step-by-step approach:

1. **Define the DP Array**: Create an array `dp` where `dp[i]` represents the number of ways to get the sum `i` using the numbers in `nums`.
2. **Initialize the DP Array**: Set `dp[0]` to 1 because there's exactly one way to make the sum 0, which is by choosing no elements.
3. **Fill the DP Array**: For each sum from 1 to `target`, determine the number of ways to form that sum by iterating over each number in `nums`. If the current number can be subtracted from the current sum (i.e., `i - num >= 0`), then add the number of ways to form the sum `i - num` to `dp[i]`.
4. **Return the Result**: The value of `dp[target]` will be the number of ways to form the sum `target`.

Here's the implementation:

```python
from typing import List

class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # Initialize the dp array with zeros
        dp = [0] * (target + 1)
        # There is one way to make the sum 0, which is by choosing no elements
        dp[0] = 1
        
        # Fill the dp array
        for i in range(1, target + 1):
            for num in nums:
                if i - num >= 0:
                    dp[i] += dp[i - num]
        
        return dp[target]
```

### Follow-up Question:
If negative numbers are allowed in the given array, the problem changes significantly because it can lead to infinite combinations. For example, if `nums` contains `-1` and `1`, you can keep adding `-1` and `1` to get any sum indefinitely.

To handle negative numbers, we would need to add constraints to avoid infinite loops, such as limiting the number of times a number can be used or restricting the problem to a finite number of operations. One way to handle this is to impose a maximum number of elements that can be used in the combination or to use a different approach that inherently avoids cycles, such as backtracking with memoization and a depth limit. However, these changes would alter the problem significantly from the original one.

Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
You must find a solution with a memory complexity better than O(n2).
 
Example 1:

Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13

Example 2:

Input: matrix = [[-5]], k = 1
Output: -5

 
Constraints:

n == matrix.length == matrix[i].length
1 <= n <= 300
-109 <= matrix[i][j] <= 109
All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.
1 <= k <= n2

 
Follow up:

Could you solve the problem with a constant memory (i.e., O(1) memory complexity)?
Could you solve the problem in O(n) time complexity? The solution may be too advanced for an interview but you may find reading this paper fun.



To solve the problem of finding the kth smallest element in a sorted n x n matrix, we can use a binary search approach. The idea is to leverage the sorted property of the matrix to efficiently narrow down the potential candidates for the kth smallest element.

Here's the step-by-step plan:

1. **Binary Search Initialization**: 
   - Initialize the lower bound (`low`) to the smallest element in the matrix, which is the top-left element (`matrix[0][0]`).
   - Initialize the upper bound (`high`) to the largest element in the matrix, which is the bottom-right element (`matrix[n-1][n-1]`).

2. **Binary Search Execution**:
   - While `low` is less than `high`:
     - Calculate the middle value `mid` as the average of `low` and `high`.
     - Count how many elements in the matrix are less than or equal to `mid`. This can be done efficiently by leveraging the sorted property of the rows and columns.
     - If the count of elements less than or equal to `mid` is less than `k`, it means the kth smallest element must be greater than `mid`, so set `low` to `mid + 1`.
     - Otherwise, the kth smallest element is `mid` or smaller, so set `high` to `mid`.

3. **Result**:
   - When `low` equals `high`, `low` (or `high`) will be the kth smallest element.

This approach ensures a time complexity of O(n log(max-min)), where `max` and `min` are the maximum and minimum elements in the matrix, respectively. The space complexity is O(1) as we are using a constant amount of extra space.

Here's the implementation:

```python
from typing import List

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        
        def countLessEqual(mid):
            count = 0
            row, col = n - 1, 0
            while row >= 0 and col < n:
                if matrix[row][col] > mid:
                    row -= 1
                else:
                    count += row + 1
                    col += 1
            return count
        
        low, high = matrix[0][0], matrix[n-1][n-1]
        
        while low < high:
            mid = (low + high) // 2
            if countLessEqual(mid) < k:
                low = mid + 1
            else:
                high = mid
        
        return low
```

### Explanation of `countLessEqual` Function:
- This function counts the number of elements in the matrix that are less than or equal to a given value `mid`.
- It starts from the bottom-left corner of the matrix and moves either up or right depending on the comparison between `matrix[row][col]` and `mid`.
- If `matrix[row][col]` is greater than `mid`, it moves up to check smaller elements.
- If `matrix[row][col]` is less than or equal to `mid`, it counts all elements in the current column up to the current row and moves right to check larger elements.
- This ensures that each element is checked at most once, making the function run in O(n) time.

Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote.
 
Example 1:
Input: ransomNote = "a", magazine = "b"
Output: false
Example 2:
Input: ransomNote = "aa", magazine = "ab"
Output: false
Example 3:
Input: ransomNote = "aa", magazine = "aab"
Output: true

 
Constraints:

1 <= ransomNote.length, magazine.length <= 105
ransomNote and magazine consist of lowercase English letters.



```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        from collections import Counter
        
        # Count the frequency of each character in ransomNote and magazine
        note_count = Counter(ransomNote)
        magazine_count = Counter(magazine)
        
        # Check if magazine has enough of each character to construct ransomNote
        for char, count in note_count.items():
            if magazine_count[char] < count:
                return False
        
        return True
```

Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.
You must write an algorithm that runs in O(n) time and uses O(1) extra space. 
 
Example 1:
Input: n = 13
Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]
Example 2:
Input: n = 2
Output: [1,2]

 
Constraints:

1 <= n <= 5 * 104



To solve this problem, we can use a depth-first search (DFS) approach to generate numbers in lexicographical order. The idea is to start from each number from 1 to 9 and recursively explore all numbers that can be formed by appending digits 0 through 9. This approach ensures that we generate numbers in the desired lexicographical order. 

The algorithm works as follows:
1. Start with numbers 1 through 9.
2. For each starting number, recursively append digits 0 through 9 to form new numbers.
3. If the new number exceeds n, stop the recursion.
4. Collect all valid numbers in the result list.

This method ensures that the numbers are generated in lexicographical order and the time complexity is O(n) because each number is processed exactly once. The space complexity is O(1) excluding the space used for the output list.

Here is the implementation:

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        result = []
        
        def dfs(current):
            if current > n:
                return
            result.append(current)
            for i in range(10):
                next_num = current * 10 + i
                if next_num > n:
                    return
                dfs(next_num)
        
        for i in range(1, 10):
            dfs(i)
        
        return result
```

This code defines a `dfs` helper function that performs the depth-first search starting from a given number. The main function iterates over starting numbers from 1 to 9 and calls the `dfs` function for each. The results are collected in the `result` list, which is returned at the end.

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
 
Example 1:

Input: s = "leetcode"
Output: 0
Explanation:
The character 'l' at index 0 is the first character that does not occur at any other index.

Example 2:

Input: s = "loveleetcode"
Output: 2

Example 3:

Input: s = "aabb"
Output: -1

 
Constraints:

1 <= s.length <= 105
s consists of only lowercase English letters.



```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        # Create a dictionary to store the count of each character
        char_count = {}
        
        # Count the occurrences of each character in the string
        for char in s:
            if char in char_count:
                char_count[char] += 1
            else:
                char_count[char] = 1
        
        # Find the first character with a count of 1
        for index, char in enumerate(s):
            if char_count[char] == 1:
                return index
        
        # If no unique character is found, return -1
        return -1
```

Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:

Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.
In text form, it looks like this (with ⟶ representing the tab character):

dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext

If we were to write this representation in code, it will look like this: "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext". Note that the '\n' and '\t' are the new-line and tab characters.
Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is "dir/subdir2/subsubdir2/file2.ext". Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.
Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.
Note that the testcases are generated such that the file system is valid and no file or directory name has length 0.
 
Example 1:


Input: input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
Output: 20
Explanation: We have only one file, and the absolute path is "dir/subdir2/file.ext" of length 20.

Example 2:


Input: input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
Output: 32
Explanation: We have two files:
"dir/subdir1/file1.ext" of length 21
"dir/subdir2/subsubdir2/file2.ext" of length 32.
We return 32 since it is the longest absolute path to a file.

Example 3:

Input: input = "a"
Output: 0
Explanation: We do not have any files, just a single directory named "a".

 
Constraints:

1 <= input.length <= 104
input may contain lowercase or uppercase English letters, a new line character '\n', a tab character '\t', a dot '.', a space ' ', and digits.
All file and directory names have positive length.



```python
class Solution:
    def lengthLongestPath(self, input: str) -> int:
        # Split the input by new line to get each line
        lines = input.split('\n')
        # Dictionary to store the cumulative length of the path at each depth
        path_length = {0: 0}
        max_length = 0

        for line in lines:
            # Count the number of tabs to determine the depth
            depth = line.count('\t')
            # Remove the tabs to get the actual name
            name = line[depth:]
            
            # If it's a file, calculate the total length of the path
            if '.' in name:
                # Calculate the total path length including slashes
                total_length = path_length[depth] + len(name)
                # Update max_length if this path is longer
                max_length = max(max_length, total_length)
            else:
                # If it's a directory, update the path_length dictionary
                # +1 for the slash that would be added in the path
                path_length[depth + 1] = path_length[depth] + len(name) + 1
        
        return max_length
```

This solution processes each line of the input to determine the depth of the directory or file by counting the number of tab characters (`\t`). It maintains a dictionary to store the cumulative length of the path at each depth. When a file is encountered (determined by the presence of a dot `.`), it calculates the total path length and updates the maximum length if necessary. The solution efficiently handles the file system representation and computes the longest absolute path to a file.

You are given two strings s and t.
String t is generated by random shuffling string s and then add one more letter at a random position.
Return the letter that was added to t.
 
Example 1:

Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.

Example 2:

Input: s = "", t = "y"
Output: "y"

 
Constraints:

0 <= s.length <= 1000
t.length == s.length + 1
s and t consist of lowercase English letters.



```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        # Initialize a dictionary to count characters in s
        char_count = {}
        
        # Count each character in s
        for char in s:
            if char in char_count:
                char_count[char] += 1
            else:
                char_count[char] = 1
        
        # Check each character in t
        for char in t:
            if char in char_count and char_count[char] > 0:
                char_count[char] -= 1
            else:
                # If the character is not found or is extra, return it
                return char
```

This solution works by counting the occurrences of each character in string `s` and then checking against the characters in string `t`. The character that is either not found in the count or has an extra occurrence in `t` is returned as the result. This approach ensures that we correctly identify the added character even if there are duplicate characters in the strings.

You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:

Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.
Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.
Keep repeating the steps again, alternating left to right and right to left, until a single number remains.

Given the integer n, return the last number that remains in arr.
 
Example 1:

Input: n = 9
Output: 6
Explanation:
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr = [2, 4, 6, 8]
arr = [2, 6]
arr = [6]

Example 2:

Input: n = 1
Output: 1

 
Constraints:

1 <= n <= 109



To solve this problem efficiently, especially given the constraint \(1 \leq n \leq 10^9\), we need to avoid simulating the removal process directly on the list, as it would be computationally expensive. Instead, we can use a mathematical approach to determine the last remaining number.

The key observation is that the problem can be reduced to a smaller subproblem by understanding the pattern of elimination. Let's break it down:

1. **Initial Setup**: Start with the list `[1, 2, 3, ..., n]`.

2. **First Pass (Left to Right)**: Remove every other number starting from the left. This leaves us with `[2, 4, 6, ..., k]` where `k` is the largest even number less than or equal to `n`.

3. **Second Pass (Right to Left)**: The new list is now `[2, 4, 6, ..., k]`. When we remove every other number from right to left, the pattern is more complex, but it can be shown that the new list can be derived by considering the remaining indices in the previous list.

4. **Subproblem**: By reversing the list and adjusting indices, we can see that the problem reduces to finding the last remaining number in a smaller list of size `n/2` (or `(n-1)/2` if `n` is odd), but with a modified starting point and step.

5. **General Pattern**: By induction, we can derive a formula or recursive relation to find the last remaining number without explicitly constructing the list at each step.

Here's the implementation of the solution using this mathematical approach:

```python
class Solution:
    def lastRemaining(self, n: int) -> int:
        remaining = n
        step = 1
        left_to_right = True
        head = 1
        
        while remaining > 1:
            if left_to_right or remaining % 2 == 1:
                head += step
            step *= 2
            remaining //= 2
            left_to_right = not left_to_right
        
        return head
```

### Explanation:
- **`remaining`**: Keeps track of the number of elements left in the list.
- **`step`**: The step size, which doubles after each pass.
- **`left_to_right`**: A boolean to determine the direction of the pass.
- **`head`**: The first element of the current list.

In each iteration, we adjust the `head` if we are going left to right or if the number of elements remaining is odd (which affects the right-to-left pass). We then double the step size and halve the number of remaining elements, and toggle the direction.

This approach runs in \(O(\log n)\) time, making it efficient for large values of \(n\).

Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).
Return true if all the rectangles together form an exact cover of a rectangular region.
 
Example 1:


Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
Output: true
Explanation: All 5 rectangles together form an exact cover of a rectangular region.

Example 2:


Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]
Output: false
Explanation: Because there is a gap between the two rectangular regions.

Example 3:


Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]
Output: false
Explanation: Because two of the rectangles overlap with each other.

 
Constraints:

1 <= rectangles.length <= 2 * 104
rectangles[i].length == 4
-105 <= xi < ai <= 105
-105 <= yi < bi <= 105



```python
from typing import List

class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        # Initialize variables to track the bottom-left and top-right corners of the large rectangle
        min_x, min_y = float('inf'), float('inf')
        max_x, max_y = float('-inf'), float('-inf')
        
        # Dictionary to count the occurrences of each corner
        corner_count = {}
        
        # Total area of all small rectangles
        total_area = 0
        
        # Iterate through each rectangle
        for x1, y1, x2, y2 in rectangles:
            # Update the coordinates of the large rectangle
            min_x, min_y = min(min_x, x1), min(min_y, y1)
            max_x, max_y = max(max_x, x2), max(max_y, y2)
            
            # Calculate the area of the current rectangle
            total_area += (x2 - x1) * (y2 - y1)
            
            # Update the corner counts
            for corner in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:
                if corner in corner_count:
                    corner_count[corner] += 1
                else:
                    corner_count[corner] = 1
        
        # Check if the total area matches the area of the large rectangle
        if total_area != (max_x - min_x) * (max_y - min_y):
            return False
        
        # Check the corner points of the large rectangle
        large_corners = [(min_x, min_y), (min_x, max_y), (max_x, min_y), (max_x, max_y)]
        
        for corner in large_corners:
            if corner not in corner_count or corner_count[corner] != 1:
                return False
        
        # Check that all other corners appear an even number of times
        for corner, count in corner_count.items():
            if corner not in large_corners and count % 2 != 0:
                return False
        
        return True
```

Given two strings s and t, return true if s is a subsequence of t, or false otherwise.
A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).
 
Example 1:
Input: s = "abc", t = "ahbgdc"
Output: true
Example 2:
Input: s = "axc", t = "ahbgdc"
Output: false

 
Constraints:

0 <= s.length <= 100
0 <= t.length <= 104
s and t consist only of lowercase English letters.

 
Follow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k >= 109, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code?

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        s_index, t_index = 0, 0
        s_len, t_len = len(s), len(t)
        
        while s_index < s_len and t_index < t_len:
            if s[s_index] == t[t_index]:
                s_index += 1
            t_index += 1
        
        return s_index == s_len

# For the follow-up question, if there are lots of incoming s strings to check against a single t string,
# we can preprocess t to make the checks more efficient. One way is to use a dictionary to store the indices
# of each character in t. This allows us to perform binary search to find the next valid index for each character
# in s, reducing the time complexity for each s from O(n) to O(m log n), where m is the length of s and n is the length of t.
# Here's how you can implement it:

import collections
import bisect

class SolutionFollowUp:
    def __init__(self, t: str):
        self.t_index_map = collections.defaultdict(list)
        for index, char in enumerate(t):
            self.t_index_map[char].append(index)

    def isSubsequence(self, s: str) -> bool:
        current_index = -1
        for char in s:
            if char not in self.t_index_map:
                return False
            # Use binary search to find the smallest index in t which is larger than current_index
            positions = self.t_index_map[char]
            index = bisect.bisect_right(positions, current_index)
            if index == len(positions):
                return False
            current_index = positions[index]
        return True
```

This solution includes two parts:

1. The `isSubsequence` method in the `Solution` class checks if `s` is a subsequence of `t` using a two-pointer technique.
2. The `SolutionFollowUp` class preprocesses the string `t` to create a mapping of characters to their indices. It uses binary search to efficiently check if each `s` is a subsequence of `t`, which is more suitable for scenarios with many incoming `s` strings.

Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:

For a 1-byte character, the first bit is a 0, followed by its Unicode code.
For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.

This is how the UTF-8 encoding would work:

     Number of Bytes   |        UTF-8 Octet Sequence
                       |              (binary)
   --------------------+-----------------------------------------
            1          |   0xxxxxxx
            2          |   110xxxxx 10xxxxxx
            3          |   1110xxxx 10xxxxxx 10xxxxxx
            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

x denotes a bit in the binary form of a byte that may be either 0 or 1.
Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.
 
Example 1:

Input: data = [197,130,1]
Output: true
Explanation: data represents the octet sequence: 11000101 10000010 00000001.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.

Example 2:

Input: data = [235,140,4]
Output: false
Explanation: data represented the octet sequence: 11101011 10001100 00000100.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.

 
Constraints:

1 <= data.length <= 2 * 104
0 <= data[i] <= 255



```python
from typing import List

class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        # Helper function to count the number of leading 1s in the byte
        def count_leading_ones(byte):
            mask = 0b10000000
            count = 0
            while mask & byte:
                count += 1
                mask >>= 1
            return count
        
        i = 0
        while i < len(data):
            leading_ones = count_leading_ones(data[i])
            
            # Determine the number of bytes for the current character
            if leading_ones == 0:
                # 1-byte character
                i += 1
            elif 2 <= leading_ones <= 4:
                # n-byte character
                num_bytes = leading_ones
                # Check if there are enough bytes in the data
                if i + num_bytes > len(data):
                    return False
                # Check the following num_bytes - 1 bytes
                for j in range(i + 1, i + num_bytes):
                    if (data[j] & 0b11000000) != 0b10000000:
                        return False
                i += num_bytes
            else:
                # Invalid starting byte
                return False
        
        return True
```

This solution checks each byte in the `data` list to determine if it represents a valid UTF-8 encoding. It uses a helper function `count_leading_ones` to determine the number of leading 1s in the byte, which indicates the number of bytes in the character. It then verifies that the subsequent bytes (if any) start with `10` as required by the UTF-8 encoding rules.

Given an encoded string, return its decoded string.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].
The test cases are generated so that the length of the output will never exceed 105.
 
Example 1:

Input: s = "3[a]2[bc]"
Output: "aaabcbc"

Example 2:

Input: s = "3[a2[c]]"
Output: "accaccacc"

Example 3:

Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"

 
Constraints:

1 <= s.length <= 30
s consists of lowercase English letters, digits, and square brackets '[]'.
s is guaranteed to be a valid input.
All the integers in s are in the range [1, 300].



```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack = []
        current_num = 0
        current_string = ""
        
        for char in s:
            if char.isdigit():
                current_num = current_num * 10 + int(char)
            elif char == '[':
                stack.append((current_string, current_num))
                current_string = ""
                current_num = 0
            elif char == ']':
                prev_string, num = stack.pop()
                current_string = prev_string + num * current_string
            else:
                current_string += char
        
        return current_string
```

This solution uses a stack to keep track of the previous string and the number of times it should be repeated when encountering a closing bracket. It processes each character in the string, updating the current number, string, or stack as necessary.

Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.
if no such substring exists, return 0.
 
Example 1:

Input: s = "aaabb", k = 3
Output: 3
Explanation: The longest substring is "aaa", as 'a' is repeated 3 times.

Example 2:

Input: s = "ababbc", k = 2
Output: 5
Explanation: The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.

 
Constraints:

1 <= s.length <= 104
s consists of only lowercase English letters.
1 <= k <= 105



```python
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        if len(s) < k:
            return 0
        
        # Count the frequency of each character in the string
        char_count = {}
        for char in s:
            char_count[char] = char_count.get(char, 0) + 1
        
        # Find the first character that does not meet the frequency requirement
        for char in s:
            if char_count[char] < k:
                # Split the string by this character and check each substring
                return max(self.longestSubstring(substring, k) for substring in s.split(char))
        
        # If all characters meet the frequency requirement, return the length of the string
        return len(s)
```

This solution uses a recursive approach. It first checks if the length of the string is less than `k`, in which case it returns 0 because it's impossible to have a valid substring. It then counts the frequency of each character in the string. If any character's frequency is less than `k`, it splits the string by that character and recursively checks each substring for the longest valid substring. If all characters meet the frequency requirement, the entire string is valid, and its length is returned.

You are given an integer array nums of length n.
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:

F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].

Return the maximum value of F(0), F(1), ..., F(n-1).
The test cases are generated so that the answer fits in a 32-bit integer.
 
Example 1:

Input: nums = [4,3,2,6]
Output: 26
Explanation:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.

Example 2:

Input: nums = [100]
Output: 0

 
Constraints:

n == nums.length
1 <= n <= 105
-100 <= nums[i] <= 100



To solve this problem efficiently, we need to leverage the relationship between consecutive rotation functions. Instead of recalculating the rotation function from scratch for each rotation, we can use a mathematical approach to derive the next rotation function from the previous one.

Let's denote:
- \( F(0) = 0 \cdot nums[0] + 1 \cdot nums[1] + \ldots + (n-1) \cdot nums[n-1] \)
- \( F(1) = 0 \cdot nums[n-1] + 1 \cdot nums[0] + 2 \cdot nums[1] + \ldots + (n-1) \cdot nums[n-2] \)

We can express \( F(k) \) in terms of \( F(k-1) \) using the following relationship:
\[ F(k) = F(k-1) + \text{sum}(nums) - n \cdot nums[n-k] \]
where \(\text{sum}(nums)\) is the sum of all elements in the array \( nums \).

This relationship allows us to compute each rotation function in constant time, leading to an overall time complexity of \( O(n) \).

Here's the implementation of the solution:

```python
from typing import List

class Solution:
    def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        
        # Calculate F(0)
        F = sum(i * nums[i] for i in range(n))
        total_sum = sum(nums)
        
        # Initialize the maximum value with F(0)
        max_value = F
        
        # Calculate F(k) for k from 1 to n-1
        for k in range(1, n):
            F = F + total_sum - n * nums[n-k]
            max_value = max(max_value, F)
        
        return max_value
```

### Explanation:
1. **Initial Calculation of F(0):**
   - We compute the initial value of \( F(0) \) by iterating through the array and calculating the weighted sum.

2. **Sum of Array Elements:**
   - We compute the total sum of the array elements, which will be used in the calculation of subsequent \( F(k) \) values.

3. **Iterative Calculation of F(k):**
   - Using the relationship \( F(k) = F(k-1) + \text{sum}(nums) - n \cdot nums[n-k] \), we iteratively compute each \( F(k) \) and update the maximum value encountered.

This approach ensures that we efficiently compute the maximum rotation function value in linear time, which is optimal given the problem constraints.

Given a positive integer n, you can apply one of the following operations:

If n is even, replace n with n / 2.
If n is odd, replace n with either n + 1 or n - 1.

Return the minimum number of operations needed for n to become 1.
 
Example 1:

Input: n = 8
Output: 3
Explanation: 8 -> 4 -> 2 -> 1

Example 2:

Input: n = 7
Output: 4
Explanation: 7 -> 8 -> 4 -> 2 -> 1
or 7 -> 6 -> 3 -> 2 -> 1

Example 3:

Input: n = 4
Output: 2

 
Constraints:

1 <= n <= 231 - 1



```python
class Solution:
    def integerReplacement(self, n: int) -> int:
        count = 0
        while n > 1:
            if n % 2 == 0:
                n //= 2
            else:
                # If n is 3 or the last two bits are 01, it's better to subtract 1
                if n == 3 or (n & 3) == 1:
                    n -= 1
                else:
                    n += 1
            count += 1
        return count
```

This solution uses a greedy approach to minimize the number of operations needed to reduce `n` to 1. The key observation is that for an odd number, choosing between `n + 1` or `n - 1` can be decided by looking at the binary representation of `n`. If `n` is 3 or the last two bits are `01` (i.e., `n & 3 == 1`), subtracting 1 is better. Otherwise, adding 1 is preferred. This ensures that we avoid unnecessary operations and reach 1 in the minimum number of steps.

You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.
You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.
Return the answers to all queries. If a single answer cannot be determined, return -1.0.
Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.
Note: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.
 
Example 1:

Input: equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation: 
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined => -1.0
Example 2:

Input: equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
Output: [3.75000,0.40000,5.00000,0.20000]

Example 3:

Input: equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
Output: [0.50000,2.00000,-1.00000,-1.00000]

 
Constraints:

1 <= equations.length <= 20
equations[i].length == 2
1 <= Ai.length, Bi.length <= 5
values.length == equations.length
0.0 < values[i] <= 20.0
1 <= queries.length <= 20
queries[i].length == 2
1 <= Cj.length, Dj.length <= 5
Ai, Bi, Cj, Dj consist of lower case English letters and digits.



```python
from collections import defaultdict
from typing import List

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        def find(x):
            if p[x] != x:
                origin = p[x]
                p[x] = find(p[x])
                w[x] *= w[origin]
            return p[x]

        w = defaultdict(lambda: 1)
        p = defaultdict()
        for a, b in equations:
            p[a], p[b] = a, b
        for i, v in enumerate(values):
            a, b = equations[i]
            pa, pb = find(a), find(b)
            if pa == pb:
                continue
            p[pa] = pb
            w[pa] = w[b] * v / w[a]
        return [
            -1 if c not in p or d not in p or find(c) != find(d) else w[c] / w[d]
            for c, d in queries
        ]
```

This solution uses the Union-Find data structure with path compression and weighted edges to solve the problem. The `find` function is used to find the root of a variable while updating the path weights. The `w` dictionary keeps track of the weight from each node to its parent, and the `p` dictionary keeps track of the parent of each node. For each query, the solution checks if both variables exist and if they are connected in the same component before calculating the result.

Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].
 
Example 1:

Input: n = 3
Output: 3

Example 2:

Input: n = 11
Output: 0
Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.

 
Constraints:

1 <= n <= 231 - 1



```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        # Determine the number of digits in the number that contains the nth digit
        length = 1
        count = 9
        start = 1
        
        while n > length * count:
            n -= length * count
            length += 1
            count *= 10
            start *= 10
        
        # Find the actual number that contains the nth digit
        start += (n - 1) // length
        
        # Find the nth digit in the number
        return int(str(start)[(n - 1) % length])
```

This solution works by first determining the range of numbers (1-digit, 2-digit, etc.) that contains the nth digit. It then calculates the exact number within that range and extracts the specific digit. The approach is efficient and works within the given constraints.

A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.

For example, the below binary watch reads "4:51".


Given an integer turnedOn which represents the number of LEDs that are currently on (ignoring the PM), return all possible times the watch could represent. You may return the answer in any order.
The hour must not contain a leading zero.

For example, "01:00" is not valid. It should be "1:00".

The minute must consist of two digits and may contain a leading zero.

For example, "10:2" is not valid. It should be "10:02".

 
Example 1:
Input: turnedOn = 1
Output: ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
Example 2:
Input: turnedOn = 9
Output: []

 
Constraints:

0 <= turnedOn <= 10



```python
from typing import List

class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        def countBits(n):
            count = 0
            while n:
                count += n & 1
                n >>= 1
            return count
        
        result = []
        for hour in range(12):
            for minute in range(60):
                if countBits(hour) + countBits(minute) == turnedOn:
                    result.append(f"{hour}:{minute:02}")
        return result
```

This solution defines a helper function `countBits` to count the number of 1s in the binary representation of a number. It then iterates over all possible hours (0-11) and minutes (0-59), checking if the sum of the bits in the hour and minute equals `turnedOn`. If it does, it formats the time as a string and adds it to the result list.

Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.
 
Example 1:

Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.

Example 2:

Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.

Example 3:

Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.

 
Constraints:

1 <= k <= num.length <= 105
num consists of only digits.
num does not have any leading zeros except for the zero itself.



```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        if k == len(num):
            return "0"
        
        stack = []
        
        for digit in num:
            while k > 0 and stack and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)
        
        # If there are still digits to remove, remove them from the end
        final_stack = stack[:-k] if k else stack
        
        # Join the result and remove leading zeros
        result = ''.join(final_stack).lstrip('0')
        
        # If the result is empty, return "0"
        return result if result else "0"
```

This solution uses a stack to construct the smallest possible number by ensuring that each digit is as small as possible while maintaining the order of the remaining digits. It removes `k` digits in total by popping from the stack when a smaller digit is encountered. After processing all digits, it removes any remaining digits to be removed from the end of the stack. Finally, it removes any leading zeros from the result and handles the edge case where the result is an empty string by returning "0".

A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.
Given a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.
If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.
 
Example 1:

Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.

Example 2:

Input: stones = [0,1,2,3,4,8,9,11]
Output: false
Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.

 
Constraints:

2 <= stones.length <= 2000
0 <= stones[i] <= 231 - 1
stones[0] == 0
stones is sorted in a strictly increasing order.



```python
from typing import List
from functools import lru_cache

class Solution:
    def canCross(self, stones: List[int]) -> bool:
        stone_set = set(stones)
        
        @lru_cache(None)
        def can_jump(position, jump_size):
            if position == stones[-1]:
                return True
            if position not in stone_set or jump_size <= 0:
                return False
            
            # Try jumping k-1, k, or k+1 units
            return (can_jump(position + jump_size - 1, jump_size - 1) or
                    can_jump(position + jump_size, jump_size) or
                    can_jump(position + jump_size + 1, jump_size + 1))
        
        # The first jump must be 1 unit
        return can_jump(1, 1) if 1 in stone_set else False
```

This solution uses a recursive function with memoization to determine if the frog can reach the last stone. The function `can_jump` checks if the frog can jump to the last stone from a given position with a specific jump size. The memoization is achieved using the `lru_cache` decorator to store the results of subproblems and avoid redundant calculations. The initial check ensures that the first jump of 1 unit is possible before proceeding with the recursive calls.

Given the root of a binary tree, return the sum of all left leaves.
A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.
 
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.

Example 2:

Input: root = [1]
Output: 0

 
Constraints:

The number of nodes in the tree is in the range [1, 1000].
-1000 <= Node.val <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        def is_leaf(node):
            return node is not None and node.left is None and node.right is None
        
        def helper(node, is_left):
            if node is None:
                return 0
            if is_leaf(node) and is_left:
                return node.val
            return helper(node.left, True) + helper(node.right, False)
        
        return helper(root, False)
```

This solution defines a helper function that recursively traverses the tree, checking if each node is a left leaf. If it is, its value is added to the sum. The `is_leaf` function checks if a given node is a leaf node (i.e., it has no children). The `helper` function is used to traverse the tree, with a boolean flag `is_left` indicating whether the current node is a left child.

Given a 32-bit integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.
All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.
Note: You are not allowed to use any built-in library method to directly solve this problem.
 
Example 1:
Input: num = 26
Output: "1a"
Example 2:
Input: num = -1
Output: "ffffffff"

 
Constraints:

-231 <= num <= 231 - 1



```python
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return '0'
        chars = '0123456789abcdef'
        s = []
        # Handle negative numbers using two's complement
        if num < 0:
            num += 2**32
        for i in range(7, -1, -1):
            x = (num >> (4 * i)) & 0xF
            if s or x != 0:
                s.append(chars[x])
        return ''.join(s)
```

You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.
Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).
 
Example 1:

Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.

Example 2:

Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]

 
Constraints:

1 <= people.length <= 2000
0 <= hi <= 106
0 <= ki < people.length
It is guaranteed that the queue can be reconstructed.



```python
from typing import List

class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        # Sort people by height in descending order, and by k in ascending order
        people.sort(key=lambda x: (-x[0], x[1]))
        
        queue = []
        # Insert each person into the queue at the index specified by their k value
        for person in people:
            queue.insert(person[1], person)
        
        return queue
```

This solution works by first sorting the list of people. The sorting criteria is to order by height in descending order, and by the number of people in front (`k`) in ascending order for people of the same height. This ensures that when we insert each person into the queue, all the people already in the queue are either taller or of the same height, and we can place them directly at the index specified by their `k` value. This guarantees that the final queue meets the problem's requirements.

Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.
 
Example 1:


Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
Explanation: After the rain, water is trapped between the blocks.
We have two small ponds 1 and 3 units trapped.
The total volume of water trapped is 4.

Example 2:


Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
Output: 10

 
Constraints:

m == heightMap.length
n == heightMap[i].length
1 <= m, n <= 200
0 <= heightMap[i][j] <= 2 * 104



```python
from typing import List
import heapq

class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        if not heightMap or not heightMap[0]:
            return 0
        
        m, n = len(heightMap), len(heightMap[0])
        heap = []
        visited = set()
        
        # Push all the boundary cells into the heap
        for i in range(m):
            for j in range(n):
                if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    visited.add((i, j))
        
        # Directions for moving up, down, left, right
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        water_trapped = 0
        
        while heap:
            height, x, y = heapq.heappop(heap)
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    # Water can be trapped if the neighbor's height is less than the current boundary
                    water_trapped += max(0, height - heightMap[nx][ny])
                    # Push the neighbor into the heap with the higher boundary height
                    heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny))
        
        return water_trapped
```

This solution uses a priority queue (min-heap) to simulate the process of water filling up the lowest boundaries first. The algorithm starts by adding all boundary cells to the heap and marking them as visited. It then processes each cell by popping the smallest height from the heap, checking its neighbors, and calculating the trapped water if the neighbor's height is lower. The neighbor is then added to the heap with the updated boundary height. This process continues until all cells are processed, and the total trapped water is returned.

A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.
For example, a string such as "substitution" could be abbreviated as (but not limited to):

"s10n" ("s ubstitutio n")
"sub4u4" ("sub stit u tion")
"12" ("substitution")
"su3i1u2on" ("su bst i t u ti on")
"substitution" (no substrings replaced)

The following are not valid abbreviations:

"s55n" ("s ubsti tutio n", the replaced substrings are adjacent)
"s010n" (has leading zeros)
"s0ubstitution" (replaces an empty substring)

Given a string word and an abbreviation abbr, return whether the string matches the given abbreviation.
A substring is a contiguous non-empty sequence of characters within a string.
 
Example 1:

Input: word = "internationalization", abbr = "i12iz4n"
Output: true
Explanation: The word "internationalization" can be abbreviated as "i12iz4n" ("i nternational iz atio n").

Example 2:

Input: word = "apple", abbr = "a2e"
Output: false
Explanation: The word "apple" cannot be abbreviated as "a2e".

 
Constraints:

1 <= word.length <= 20
word consists of only lowercase English letters.
1 <= abbr.length <= 10
abbr consists of lowercase English letters and digits.
All the integers in abbr will fit in a 32-bit integer.



```python
class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -> bool:
        i, j = 0, 0
        while i < len(word) and j < len(abbr):
            if abbr[j].isdigit():
                if abbr[j] == '0':  # Leading zero check
                    return False
                shift = 0
                while j < len(abbr) and abbr[j].isdigit():
                    shift = shift * 10 + int(abbr[j])
                    j += 1
                i += shift
            else:
                if word[i] != abbr[j]:
                    return False
                i += 1
                j += 1
        
        return i == len(word) and j == len(abbr)
```

This solution iterates through both the `word` and the `abbr` strings. It handles digits in `abbr` by calculating the full number they represent and advancing the index `i` in `word` accordingly. If a non-digit character is encountered in `abbr`, it checks if it matches the current character in `word`. The function returns `True` if both indices reach the end of their respective strings, indicating a valid abbreviation.

Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.
Letters are case sensitive, for example, "Aa" is not considered a palindrome.
 
Example 1:

Input: s = "abccccdd"
Output: 7
Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.

Example 2:

Input: s = "a"
Output: 1
Explanation: The longest palindrome that can be built is "a", whose length is 1.

 
Constraints:

1 <= s.length <= 2000
s consists of lowercase and/or uppercase English letters only.



```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        from collections import Counter
        
        # Count the frequency of each character in the string
        char_count = Counter(s)
        
        # Initialize the length of the longest palindrome
        length = 0
        
        # Flag to check if we have added an odd count character in the middle
        odd_used = False
        
        # Iterate over the character counts
        for count in char_count.values():
            if count % 2 == 0:
                # If the count is even, we can add the whole count to the palindrome length
                length += count
            else:
                # If the count is odd, we can add count - 1 to the palindrome length
                length += count - 1
                # If we haven't used an odd count character in the middle yet, we can use one
                if not odd_used:
                    length += 1
                    odd_used = True
        
        return length
```

This solution uses a `Counter` to count the frequency of each character in the string. It then iterates over these counts to determine the length of the longest possible palindrome. Characters with even counts can be fully used, while characters with odd counts can contribute `count - 1` to the palindrome length. Additionally, one character with an odd count can be placed in the middle of the palindrome, if needed.

Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.
Return the minimized largest sum of the split.
A subarray is a contiguous part of the array.
 
Example 1:

Input: nums = [7,2,5,10,8], k = 2
Output: 18
Explanation: There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.

Example 2:

Input: nums = [1,2,3,4,5], k = 2
Output: 9
Explanation: There are four ways to split nums into two subarrays.
The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.

 
Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 106
1 <= k <= min(50, nums.length)



```python
from typing import List

class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        def canSplit(maxSum):
            currentSum = 0
            subarrays = 1
            for num in nums:
                if num > maxSum:
                    return False
                if currentSum + num > maxSum:
                    subarrays += 1
                    currentSum = num
                else:
                    currentSum += num
            return subarrays <= k

        left, right = max(nums), sum(nums)
        while left < right:
            mid = (left + right) // 2
            if canSplit(mid):
                right = mid
            else:
                left = mid + 1
        return left
```

This solution uses a binary search approach to find the minimized largest sum of the split. The `canSplit` function checks if it's possible to split the array into `k` or fewer subarrays with the largest sum not exceeding `maxSum`. The binary search is performed between the maximum number in the array (minimum possible largest sum) and the sum of all numbers in the array (maximum possible largest sum).

A string can be abbreviated by replacing any number of non-adjacent substrings with their lengths. For example, a string such as "substitution" could be abbreviated as (but not limited to):

"s10n" ("s ubstitutio n")
"sub4u4" ("sub stit u tion")
"12" ("substitution")
"su3i1u2on" ("su bst i t u ti on")
"substitution" (no substrings replaced)

Note that "s55n" ("s ubsti tutio n") is not a valid abbreviation of "substitution" because the replaced substrings are adjacent.
The length of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation "s10n" has a length of 3 (2 letters + 1 substring) and "su3i1u2on" has a length of 9 (6 letters + 3 substrings).
Given a target string target and an array of strings dictionary, return an abbreviation of target with the shortest possible length such that it is not an abbreviation of any string in dictionary. If there are multiple shortest abbreviations, return any of them.
 
Example 1:

Input: target = "apple", dictionary = ["blade"]
Output: "a4"
Explanation: The shortest abbreviation of "apple" is "5", but this is also an abbreviation of "blade".
The next shortest abbreviations are "a4" and "4e". "4e" is an abbreviation of blade while "a4" is not.
Hence, return "a4".

Example 2:

Input: target = "apple", dictionary = ["blade","plain","amber"]
Output: "1p3"
Explanation: "5" is an abbreviation of both "apple" but also every word in the dictionary.
"a4" is an abbreviation of "apple" but also "amber".
"4e" is an abbreviation of "apple" but also "blade".
"1p3", "2p2", and "3l1" are the next shortest abbreviations of "apple".
Since none of them are abbreviations of words in the dictionary, returning any of them is correct.

 
Constraints:

m == target.length
n == dictionary.length
1 <= m <= 21
0 <= n <= 1000
1 <= dictionary[i].length <= 100
log2(n) + m <= 21 if n > 0
target and dictionary[i] consist of lowercase English letters.
dictionary does not contain target.



```python
from typing import List

class Solution:
    def minAbbreviation(self, target: str, dictionary: List[str]) -> str:
        m = len(target)

        def getMask(word: str) -> int:
            # mask[i] = 0 := target[i] == word[i]
            # mask[i] = 1 := target[i] != word[i]
            # e.g. target = "apple"
            #        word = "blade"
            #        mask =  11110
            mask = 0
            for i, c in enumerate(word):
                if c != target[i]:
                    mask |= 1 << m - 1 - i
            return mask

        masks = [getMask(word) for word in dictionary if len(word) == m]
        if not masks:
            return str(m)

        abbrs = []

        def getAbbr(cand: int) -> str:
            abbr = []
            replacedCount = 0
            for i, c in enumerate(target):
                if cand >> m - 1 - i & 1:
                    # If cand[i] = 1, `abbr` should show the original character.
                    if replacedCount:
                        abbr.append(str(replacedCount))
                    abbr.append(c)
                    replacedCount = 0
                else:
                    # If cand[i] = 0, `abbr` can be replaced.
                    replacedCount += 1
            if replacedCount:
                abbr.append(str(replacedCount))
            return ''.join(abbr)

        # all the candidate representation of the target
        for cand in range(2**m):
            # All the masks have at least one bit different from the candidate.
            if all(cand & mask for mask in masks):
                abbr = getAbbr(cand)
                abbrs.append(abbr)

        def getAbbrLen(abbr: str) -> int:
            abbrLen = 0
            i = 0
            j = 0
            while i < len(abbr):
                if abbr[j].isalpha():
                    j += 1
                else:
                    while j < len(abbr) and abbr[j].isdigit():
                        j += 1
                abbrLen += 1
                i = j
            return abbrLen

        return min(abbrs, key=lambda x: getAbbrLen(x))
```

Given an integer n, return a string array answer (1-indexed) where:

answer[i] == "FizzBuzz" if i is divisible by 3 and 5.
answer[i] == "Fizz" if i is divisible by 3.
answer[i] == "Buzz" if i is divisible by 5.
answer[i] == i (as a string) if none of the above conditions are true.

 
Example 1:
Input: n = 3
Output: ["1","2","Fizz"]
Example 2:
Input: n = 5
Output: ["1","2","Fizz","4","Buzz"]
Example 3:
Input: n = 15
Output: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]

 
Constraints:

1 <= n <= 104



```python
from typing import List

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        answer = []
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                answer.append("FizzBuzz")
            elif i % 3 == 0:
                answer.append("Fizz")
            elif i % 5 == 0:
                answer.append("Buzz")
            else:
                answer.append(str(i))
        return answer
```

An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.

Given an integer array nums, return the number of arithmetic subarrays of nums.
A subarray is a contiguous subsequence of the array.
 
Example 1:

Input: nums = [1,2,3,4]
Output: 3
Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.

Example 2:

Input: nums = [1]
Output: 0

 
Constraints:

1 <= nums.length <= 5000
-1000 <= nums[i] <= 1000



```python
from typing import List

class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return 0
        
        total_slices = 0
        current_slices = 0
        
        for i in range(2, len(nums)):
            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:
                current_slices += 1
                total_slices += current_slices
            else:
                current_slices = 0
        
        return total_slices
```

This solution iterates through the list of numbers, checking if the current element, along with the two preceding elements, form an arithmetic slice. If they do, it increments the count of current slices and adds this to the total count. If not, it resets the current slices count. This approach ensures that all possible arithmetic subarrays are counted efficiently.

Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
 
Example 1:

Input: nums = [3,2,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2.
The third distinct maximum is 1.

Example 2:

Input: nums = [1,2]
Output: 2
Explanation:
The first distinct maximum is 2.
The second distinct maximum is 1.
The third distinct maximum does not exist, so the maximum (2) is returned instead.

Example 3:

Input: nums = [2,2,3,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2 (both 2's are counted together since they have the same value).
The third distinct maximum is 1.

 
Constraints:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

 
Follow up: Can you find an O(n) solution?

```python
class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        # Initialize three variables to store the first, second, and third maximums
        first = second = third = float('-inf')
        
        for num in nums:
            # Skip if the number is already one of the maximums
            if num in (first, second, third):
                continue
            
            # Update the maximums accordingly
            if num > first:
                third = second
                second = first
                first = num
            elif num > second:
                third = second
                second = num
            elif num > third:
                third = num
        
        # If third is still negative infinity, it means there were less than 3 distinct numbers
        return first if third == float('-inf') else third
```

This solution iterates through the list of numbers once, maintaining the three largest distinct numbers found so far. It updates these numbers as it encounters larger values, ensuring that by the end of the loop, `first` holds the maximum, `second` holds the second maximum, and `third` holds the third maximum if it exists. The function then returns the third maximum if it exists; otherwise, it returns the maximum number found. This approach runs in O(n) time complexity, meeting the follow-up requirement.

Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.
You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.
 
Example 1:

Input: num1 = "11", num2 = "123"
Output: "134"

Example 2:

Input: num1 = "456", num2 = "77"
Output: "533"

Example 3:

Input: num1 = "0", num2 = "0"
Output: "0"

 
Constraints:

1 <= num1.length, num2.length <= 104
num1 and num2 consist of only digits.
num1 and num2 don't have any leading zeros except for the zero itself.



```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # Initialize pointers for num1 and num2 from the end
        i, j = len(num1) - 1, len(num2) - 1
        carry = 0
        result = []
        
        # Loop until both strings are processed or there is a carry
        while i >= 0 or j >= 0 or carry:
            # Get the current digit from num1 and num2, or 0 if the pointer is out of bounds
            digit1 = int(num1[i]) if i >= 0 else 0
            digit2 = int(num2[j]) if j >= 0 else 0
            
            # Calculate the sum of the digits and the carry
            total = digit1 + digit2 + carry
            
            # Append the last digit of the total to the result
            result.append(str(total % 10))
            
            # Update the carry to be the first digit of the total
            carry = total // 10
            
            # Move to the next digits
            i -= 1
            j -= 1
        
        # The result is currently in reverse order, so reverse it and join to form the final string
        return ''.join(reversed(result))
```

This solution processes the input strings from the least significant digit to the most significant digit, simulating the manual addition process. It handles carries appropriately and constructs the result as a list of characters, which is then reversed and joined to form the final string.

Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.
 
Example 1:

Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].

Example 2:

Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.

 
Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 100



```python
from typing import List

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total_sum = sum(nums)
        
        # If the total sum is odd, it's not possible to partition it into two equal subsets
        if total_sum % 2 != 0:
            return False
        
        target = total_sum // 2
        n = len(nums)
        
        # Initialize a DP array to keep track of possible sums
        dp = [False] * (target + 1)
        dp[0] = True  # Base case: zero sum is always possible
        
        # Iterate over each number in the array
        for num in nums:
            # Traverse the dp array backwards
            for j in range(target, num - 1, -1):
                dp[j] = dp[j] or dp[j - num]
        
        return dp[target]
```

This solution uses dynamic programming to determine if we can partition the array into two subsets with equal sums. The idea is to use a boolean array `dp` where `dp[i]` indicates whether a subset with sum `i` can be formed from the elements of the array. We iterate through each number in the array and update the `dp` array accordingly. If `dp[target]` is true at the end, it means we can partition the array into two subsets with equal sums.

There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.
The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).
The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.
Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.
 
Example 1:


Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -> Pacific Ocean 
       [0,4] -> Atlantic Ocean
[1,3]: [1,3] -> [0,3] -> Pacific Ocean 
       [1,3] -> [1,4] -> Atlantic Ocean
[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean 
       [1,4] -> Atlantic Ocean
[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean 
       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean
[3,0]: [3,0] -> Pacific Ocean 
       [3,0] -> [4,0] -> Atlantic Ocean
[3,1]: [3,1] -> [3,0] -> Pacific Ocean 
       [3,1] -> [4,1] -> Atlantic Ocean
[4,0]: [4,0] -> Pacific Ocean 
       [4,0] -> Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.

Example 2:

Input: heights = [[1]]
Output: [[0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.

 
Constraints:

m == heights.length
n == heights[r].length
1 <= m, n <= 200
0 <= heights[r][c] <= 105



```python
from collections import deque
from typing import List

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        def bfs(q, vis):
            while q:
                for _ in range(len(q)):
                    i, j = q.popleft()
                    for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                        x, y = i + a, j + b
                        if (
                            0 <= x < m
                            and 0 <= y < n
                            and (x, y) not in vis
                            and heights[x][y] >= heights[i][j]
                        ):
                            vis.add((x, y))
                            q.append((x, y))

        m, n = len(heights), len(heights[0])
        vis1, vis2 = set(), set()
        q1 = deque()
        q2 = deque()
        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0:
                    vis1.add((i, j))
                    q1.append((i, j))
                if i == m - 1 or j == n - 1:
                    vis2.add((i, j))
                    q2.append((i, j))
        bfs(q1, vis1)
        bfs(q2, vis2)
        return [
            (i, j)
            for i in range(m)
            for j in range(n)
            if (i, j) in vis1 and (i, j) in vis2
        ]
```

Given a rows x cols screen and a sentence represented as a list of strings, return the number of times the given sentence can be fitted on the screen.
The order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.
 
Example 1:

Input: sentence = ["hello","world"], rows = 2, cols = 8
Output: 1
Explanation:
hello---
world---
The character '-' signifies an empty space on the screen.

Example 2:

Input: sentence = ["a", "bcd", "e"], rows = 3, cols = 6
Output: 2
Explanation:
a-bcd- 
e-a---
bcd-e-
The character '-' signifies an empty space on the screen.

Example 3:

Input: sentence = ["i","had","apple","pie"], rows = 4, cols = 5
Output: 1
Explanation:
i-had
apple
pie-i
had--
The character '-' signifies an empty space on the screen.

 
Constraints:

1 <= sentence.length <= 100
1 <= sentence[i].length <= 10
sentence[i] consists of lowercase English letters.
1 <= rows, cols <= 2 * 104



```python
from typing import List

class Solution:
    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -> int:
        # Join the sentence into a single string with spaces and add a final space
        s = ' '.join(sentence) + ' '
        s_len = len(s)
        
        # Current position in the string
        start = 0
        
        for _ in range(rows):
            # Move start to the end of the current row
            start += cols
            
            # If we can fit another word, move start to the next word
            if s[start % s_len] == ' ':
                start += 1
            else:
                # Otherwise, move back to the last space before the current position
                while start > 0 and s[(start - 1) % s_len] != ' ':
                    start -= 1
        
        # The number of times the sentence fits is the number of full cycles
        return start // s_len
```

This solution efficiently calculates how many times the sentence can fit on the screen by simulating the process of filling each row and using modular arithmetic to handle the cycling through the sentence string.

Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.
Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).
 
Example 1:


Input: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
Output: 2

Example 2:

Input: board = [["."]]
Output: 0

 
Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] is either '.' or 'X'.

 
Follow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the values board?


```python
from typing import List

class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        if not board:
            return 0
        
        count = 0
        rows, cols = len(board), len(board[0])
        
        for i in range(rows):
            for j in range(cols):
                if board[i][j] == 'X':
                    # Check if it's the start of a battleship
                    if (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):
                        count += 1
        
        return count
```

This solution iterates through each cell in the board exactly once (O(m * n) time complexity) and uses only a constant amount of extra space (O(1) space complexity). It checks if the current cell is the start of a battleship by ensuring that there are no 'X' cells directly above or to the left of it, which guarantees that we count each battleship exactly once.

A password is considered strong if the below conditions are all met:

It has at least 6 characters and at most 20 characters.
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.
It does not contain three repeating characters in a row (i.e., "Baaabb0" is weak, but "Baaba0" is strong).

Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.
In one step, you can:

Insert one character to password,
Delete one character from password, or
Replace one character of password with another character.

 
Example 1:
Input: password = "a"
Output: 5
Example 2:
Input: password = "aA1"
Output: 3
Example 3:
Input: password = "1337C0d3"
Output: 0

 
Constraints:

1 <= password.length <= 50
password consists of letters, digits, dot '.' or exclamation mark '!'.



```python
class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        n = len(password)
        
        # Check for lowercase, uppercase, and digit presence
        has_lower = any(c.islower() for c in password)
        has_upper = any(c.isupper() for c in password)
        has_digit = any(c.isdigit() for c in password)
        
        # Number of types of characters missing
        missing_types = 3 - (has_lower + has_upper + has_digit)
        
        # Find sequences of repeating characters
        change = 0
        one = two = 0
        i = 2
        while i < n:
            if password[i] == password[i - 1] == password[i - 2]:
                length = 2
                while i < n and password[i] == password[i - 1]:
                    length += 1
                    i += 1
                change += length // 3
                if length % 3 == 0:
                    one += 1
                elif length % 3 == 1:
                    two += 1
            else:
                i += 1
        
        if n < 6:
            return max(missing_types, 6 - n)
        elif n <= 20:
            return max(missing_types, change)
        else:
            delete = n - 20
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3
            return delete + max(missing_types, change)
```

This solution addresses the problem by checking the conditions for a strong password and calculating the minimum number of steps required to make the password strong. It handles the constraints and examples provided in the question.

Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.
 
Example 1:

Input: nums = [3,10,5,25,2,8]
Output: 28
Explanation: The maximum result is 5 XOR 25 = 28.

Example 2:

Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127

 
Constraints:

1 <= nums.length <= 2 * 105
0 <= nums[i] <= 231 - 1



```python
class Trie:
    __slots__ = ("children",)

    def __init__(self):
        self.children: List[Trie | None] = [None, None]

    def insert(self, x: int):
        node = self
        for i in range(30, -1, -1):
            v = x >> i & 1
            if node.children[v] is None:
                node.children[v] = Trie()
            node = node.children[v]

    def search(self, x: int) -> int:
        node = self
        ans = 0
        for i in range(30, -1, -1):
            v = x >> i & 1
            if node.children[v ^ 1]:
                ans |= 1 << i
                node = node.children[v ^ 1]
            else:
                node = node.children[v]
        return ans


class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        trie = Trie()
        for x in nums:
            trie.insert(x)
        return max(trie.search(x) for x in nums)
```

This solution uses a Trie (prefix tree) to efficiently find the maximum XOR of any two numbers in the list. The Trie is built with the binary representation of each number, and the search function finds the number that produces the maximum XOR with the current number by trying to take the opposite bit at each position if possible.

Given an array of strings words, return true if it forms a valid word square.
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 <= k < max(numRows, numColumns).
 
Example 1:


Input: words = ["abcd","bnrt","crmy","dtye"]
Output: true
Explanation:
The 1st row and 1st column both read "abcd".
The 2nd row and 2nd column both read "bnrt".
The 3rd row and 3rd column both read "crmy".
The 4th row and 4th column both read "dtye".
Therefore, it is a valid word square.

Example 2:


Input: words = ["abcd","bnrt","crm","dt"]
Output: true
Explanation:
The 1st row and 1st column both read "abcd".
The 2nd row and 2nd column both read "bnrt".
The 3rd row and 3rd column both read "crm".
The 4th row and 4th column both read "dt".
Therefore, it is a valid word square.

Example 3:


Input: words = ["ball","area","read","lady"]
Output: false
Explanation:
The 3rd row reads "read" while the 3rd column reads "lead".
Therefore, it is NOT a valid word square.

 
Constraints:

1 <= words.length <= 500
1 <= words[i].length <= 500
words[i] consists of only lowercase English letters.



```python
from typing import List

class Solution:
    def validWordSquare(self, words: List[str]) -> bool:
        # Get the number of rows
        numRows = len(words)
        
        # Iterate over each row
        for r in range(numRows):
            # Get the word at the current row
            rowWord = words[r]
            
            # Iterate over each character in the row word
            for c in range(len(rowWord)):
                # Check if the column index is within the number of rows
                if c >= numRows:
                    return False
                
                # Get the word at the current column
                colWord = words[c]
                
                # Check if the row index is within the length of the column word
                if r >= len(colWord):
                    return False
                
                # Compare the characters at the current position in the row and column words
                if rowWord[c] != colWord[r]:
                    return False
        
        return True
```

This solution iterates through each row and column of the given list of words, checking if the characters at corresponding positions in each row and column match. If any mismatch is found or if the indices are out of bounds, it returns `False`. If all checks pass, it returns `True`, indicating that the given list of words forms a valid word square.

Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.
 
Example 1:
Input: s = "owoztneoer"
Output: "012"
Example 2:
Input: s = "fviefuro"
Output: "45"

 
Constraints:

1 <= s.length <= 105
s[i] is one of the characters ["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"].
s is guaranteed to be valid.



```python
class Solution:
    def originalDigits(self, s: str) -> str:
        from collections import Counter
        
        # Count the frequency of each character in the input string
        count = Counter(s)
        
        # Initialize a list to keep track of the count of each digit
        digits = [0] * 10
        
        # Identify unique characters for specific digits
        digits[0] = count['z']  # 'z' is unique to "zero"
        digits[2] = count['w']  # 'w' is unique to "two"
        digits[4] = count['u']  # 'u' is unique to "four"
        digits[6] = count['x']  # 'x' is unique to "six"
        digits[8] = count['g']  # 'g' is unique to "eight"
        
        # Identify characters that can be determined after removing the unique ones
        digits[3] = count['h'] - digits[8]  # 'h' is unique to "three" after removing "eight"
        digits[5] = count['f'] - digits[4]  # 'f' is unique to "five" after removing "four"
        digits[7] = count['s'] - digits[6]  # 's' is unique to "seven" after removing "six"
        digits[1] = count['o'] - (digits[0] + digits[2] + digits[4])  # 'o' is unique to "one" after removing "zero", "two", "four"
        digits[9] = count['i'] - (digits[5] + digits[6] + digits[8])  # 'i' is unique to "nine" after removing "five", "six", "eight"
        
        # Construct the result string by repeating each digit according to its count
        result = []
        for i in range(10):
            result.append(str(i) * digits[i])
        
        return ''.join(result)
```

This solution uses the unique characters in the English words for each digit to determine the count of each digit in the input string. It then constructs the result string by repeating each digit according to its count.

You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.
Return the length of the longest substring containing the same letter you can get after performing the above operations.
 
Example 1:

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

Example 2:

Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achieve this answer too.
 
Constraints:

1 <= s.length <= 105
s consists of only uppercase English letters.
0 <= k <= s.length



```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        from collections import defaultdict
        
        # Dictionary to count the frequency of characters in the current window
        char_count = defaultdict(int)
        max_length = 0
        max_count = 0
        start = 0
        
        for end in range(len(s)):
            # Increment the count of the current character
            char_count[s[end]] += 1
            # Update the count of the most frequent character in the current window
            max_count = max(max_count, char_count[s[end]])
            
            # If the current window size minus the count of the most frequent character
            # is greater than k, it means we need more than k replacements,
            # so we shrink the window from the left
            if (end - start + 1) - max_count > k:
                char_count[s[start]] -= 1
                start += 1
            
            # Update the maximum length of the window
            max_length = max(max_length, end - start + 1)
        
        return max_length
```

This solution uses the sliding window technique to efficiently find the longest substring with the same letter after performing at most `k` replacements. The `char_count` dictionary keeps track of the frequency of each character in the current window, and `max_count` stores the highest frequency of any single character in that window. The window is adjusted as needed to ensure that the number of replacements does not exceed `k`.

Given an array of unique strings words, return all the word squares you can build from words. The same word from words can be used multiple times. You can return the answer in any order.
A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 <= k < max(numRows, numColumns).

For example, the word sequence ["ball","area","lead","lady"] forms a word square because each word reads the same both horizontally and vertically.

 
Example 1:

Input: words = ["area","lead","wall","lady","ball"]
Output: [["ball","area","lead","lady"],["wall","area","lead","lady"]]
Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).

Example 2:

Input: words = ["abat","baba","atan","atal"]
Output: [["baba","abat","baba","atal"],["baba","abat","baba","atan"]]
Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).

 
Constraints:

1 <= words.length <= 1000
1 <= words[i].length <= 4
All words[i] have the same length.
words[i] consists of only lowercase English letters.
All words[i] are unique.



```python
from typing import List
from collections import defaultdict

class Solution:
    def wordSquares(self, words: List[str]) -> List[List[str]]:
        # Build a prefix to words mapping
        prefix_to_words = defaultdict(list)
        for word in words:
            for i in range(len(word)):
                prefix = word[:i]
                prefix_to_words[prefix].append(word)
        
        # Backtracking to find all word squares
        def backtrack(step, current_square):
            if step == len(words[0]):
                result.append(list(current_square))
                return
            
            # Determine the prefix for the current step
            prefix = ''.join(word[step] for word in current_square)
            
            # Get all words that match the current prefix
            for candidate in prefix_to_words[prefix]:
                current_square.append(candidate)
                backtrack(step + 1, current_square)
                current_square.pop()
        
        result = []
        for word in words:
            backtrack(1, [word])
        
        return result
```

This solution uses a prefix trie (implemented as a dictionary) to efficiently find words that match a given prefix. It then uses backtracking to build all possible word squares, starting with each word in the list. The `backtrack` function attempts to build a word square one word at a time, ensuring that the prefix of each new word matches the appropriate column of the current square.

A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.
Suppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.

For example, "AACCGGTT" --> "AACCGGTA" is one mutation.

There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.
Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.
Note that the starting point is assumed to be valid, so it might not be included in the bank.
 
Example 1:

Input: startGene = "AACCGGTT", endGene = "AACCGGTA", bank = ["AACCGGTA"]
Output: 1

Example 2:

Input: startGene = "AACCGGTT", endGene = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
Output: 2

 
Constraints:

0 <= bank.length <= 10
startGene.length == endGene.length == bank[i].length == 8
startGene, endGene, and bank[i] consist of only the characters ['A', 'C', 'G', 'T'].



To solve this problem, we can use a Breadth-First Search (BFS) approach. BFS is suitable here because it explores all the nodes at the present "depth" (number of mutations) before moving on to nodes at the next depth level. This ensures that the first time we reach the `endGene`, we have done so with the minimum number of mutations.

Here's the step-by-step plan:

1. **Queue Initialization**: Use a queue to perform BFS. Start by adding the `startGene` to the queue with an initial mutation count of 0.
2. **Visited Set**: Keep track of visited genes to avoid processing the same gene multiple times.
3. **BFS Loop**: While there are genes in the queue:
   - Dequeue the front gene.
   - If this gene is the `endGene`, return the current mutation count.
   - Otherwise, generate all possible one-character mutations of this gene.
   - For each mutation, check if it is in the bank and has not been visited. If so, add it to the queue with an incremented mutation count.
4. **No Solution**: If the queue is exhausted and we haven't reached the `endGene`, return -1.

Here is the implementation:

```python
from collections import deque
from typing import List

class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        # Convert bank to a set for faster lookup
        bank_set = set(bank)
        
        # Possible mutations at each position
        possible_mutations = {'A': 'CGT', 'C': 'AGT', 'G': 'ACT', 'T': 'ACG'}
        
        # Queue for BFS (gene, number of mutations)
        queue = deque([(startGene, 0)])
        
        # Set to keep track of visited genes
        visited = set([startGene])
        
        while queue:
            current_gene, mutations = queue.popleft()
            
            # If we have reached the end gene, return the number of mutations
            if current_gene == endGene:
                return mutations
            
            # Try to change each character in the current gene
            for i in range(len(current_gene)):
                for mutation in possible_mutations[current_gene[i]]:
                    next_gene = current_gene[:i] + mutation + current_gene[i+1:]
                    if next_gene in bank_set and next_gene not in visited:
                        visited.add(next_gene)
                        queue.append((next_gene, mutations + 1))
        
        # If we exhaust the queue without finding the end gene, return -1
        return -1
```

This code efficiently finds the minimum number of mutations required to transform `startGene` into `endGene` using BFS, ensuring that each gene string is only processed once.

Given a string s, return the number of segments in the string.
A segment is defined to be a contiguous sequence of non-space characters.
 
Example 1:

Input: s = "Hello, my name is John"
Output: 5
Explanation: The five segments are ["Hello,", "my", "name", "is", "John"]

Example 2:

Input: s = "Hello"
Output: 1

 
Constraints:

0 <= s.length <= 300
s consists of lowercase and uppercase English letters, digits, or one of the following characters "!@#$%^&*()_+-=',.:".
The only space character in s is ' '.



```python
class Solution:
    def countSegments(self, s: str) -> int:
        # Split the string by spaces and filter out any empty strings
        segments = s.split()
        # Return the number of non-empty segments
        return len(segments)
```

This solution works by using the `split()` method, which splits the string `s` at each sequence of whitespace and returns a list of words (segments). By default, `split()` removes any leading or trailing whitespace and also handles multiple spaces between words by filtering them out. The length of the resulting list gives the number of segments in the string.

Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
Note that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.
 
Example 1:

Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.

Example 2:

Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.

Example 3:

Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.

 
Constraints:

1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104



To solve this problem, we can use a greedy algorithm. The idea is to always keep the interval with the earliest end time that doesn't overlap with the previous interval. This way, we can maximize the number of non-overlapping intervals, which in turn minimizes the number of intervals we need to remove.

Here's the step-by-step approach:

1. Sort the intervals based on their end times.
2. Initialize a counter for the number of intervals to remove.
3. Keep track of the end time of the last added non-overlapping interval.
4. Iterate through the sorted intervals:
   - If the current interval starts after or when the last added interval ends, it does not overlap, so update the last end time.
   - Otherwise, it overlaps, so increment the counter of intervals to remove.

This approach ensures that we are always making the locally optimal choice, which leads to a globally optimal solution.

Here's the implementation:

```python
from typing import List

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        # Sort intervals by their end time
        intervals.sort(key=lambda x: x[1])
        
        # Initialize the end time of the last added interval
        last_end = intervals[0][1]
        # Initialize the count of intervals to remove
        remove_count = 0
        
        # Iterate through the intervals starting from the second one
        for i in range(1, len(intervals)):
            start, end = intervals[i]
            if start >= last_end:
                # If the current interval does not overlap, update the last end time
                last_end = end
            else:
                # If the current interval overlaps, increment the remove count
                remove_count += 1
        
        return remove_count
```

This solution has a time complexity of O(n log n) due to the sorting step, and a space complexity of O(1) if we ignore the space used by the sorting algorithm. It efficiently handles the constraints provided in the problem.

You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.
The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.
Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.
 
Example 1:

Input: intervals = [[1,2]]
Output: [-1]
Explanation: There is only one interval in the collection, so it outputs -1.

Example 2:

Input: intervals = [[3,4],[2,3],[1,2]]
Output: [-1,0,1]
Explanation: There is no right interval for [3,4].
The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.
The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.

Example 3:

Input: intervals = [[1,4],[2,3],[3,4]]
Output: [-1,2,-1]
Explanation: There is no right interval for [1,4] and [3,4].
The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.

 
Constraints:

1 <= intervals.length <= 2 * 104
intervals[i].length == 2
-106 <= starti <= endi <= 106
The start point of each interval is unique.



```python
from typing import List
import bisect

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        # Create a list of tuples (start, original_index)
        start_intervals = sorted((interval[0], i) for i, interval in enumerate(intervals))
        
        result = []
        for interval in intervals:
            # Use bisect to find the smallest start that is >= end of the current interval
            idx = bisect.bisect_left(start_intervals, (interval[1],))
            if idx < len(start_intervals):
                result.append(start_intervals[idx][1])
            else:
                result.append(-1)
        
        return result
```

This solution works as follows:
1. We first create a list of tuples containing the start point of each interval and its original index. This list is then sorted based on the start points.
2. For each interval, we use binary search (via `bisect_left`) to find the smallest start point that is greater than or equal to the end point of the current interval.
3. If such a start point is found, we append the corresponding original index to the result list. If not, we append -1.
4. Finally, we return the result list containing the indices of the right intervals.

Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).
 
Example 1:


Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.

Example 2:

Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3

 
Constraints:

The number of nodes in the tree is in the range [0, 1000].
-109 <= Node.val <= 109
-1000 <= targetSum <= 1000



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import defaultdict
from typing import Optional

class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        # Dictionary to store prefix sums and their frequencies
        prefix_sum_count = defaultdict(int)
        prefix_sum_count[0] = 1  # Base case: a prefix sum of 0 has one count
        
        def dfs(node: Optional[TreeNode], current_sum: int) -> int:
            if not node:
                return 0
            
            # Update the current sum
            current_sum += node.val
            
            # Calculate the number of paths that end at the current node
            paths_ending_here = prefix_sum_count[current_sum - targetSum]
            
            # Update the prefix sum count
            prefix_sum_count[current_sum] += 1
            
            # Recurse on the left and right subtrees
            paths_from_left = dfs(node.left, current_sum)
            paths_from_right = dfs(node.right, current_sum)
            
            # Remove the current prefix sum count as we are backtracking
            prefix_sum_count[current_sum] -= 1
            
            # Return the total number of paths
            return paths_ending_here + paths_from_left + paths_from_right
        
        # Start the DFS from the root with an initial sum of 0
        return dfs(root, 0)
```

This solution uses a depth-first search (DFS) approach with a hash map to keep track of the prefix sums encountered along the path. It efficiently counts the number of paths that sum to the target value by leveraging the properties of prefix sums. The algorithm runs in O(n) time complexity, where n is the number of nodes in the tree, and uses O(h) space complexity for the recursion stack, where h is the height of the tree.

Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
 
Example 1:

Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Example 2:

Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

 
Constraints:

1 <= s.length, p.length <= 3 * 104
s and p consist of lowercase English letters.



```python
from typing import List
from collections import Counter

class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        # Count the frequency of each character in p
        p_count = Counter(p)
        # Initialize a counter for the current window in s
        s_count = Counter()
        result = []
        p_len = len(p)
        
        # Iterate over s with a sliding window of size len(p)
        for i in range(len(s)):
            # Add the current character to the window
            s_count[s[i]] += 1
            
            # Remove the character that is left out of the window
            if i >= p_len:
                if s_count[s[i - p_len]] == 1:
                    del s_count[s[i - p_len]]
                else:
                    s_count[s[i - p_len]] -= 1
            
            # Compare the window counter with the target counter
            if s_count == p_count:
                result.append(i - p_len + 1)
        
        return result
```

This solution uses a sliding window approach with two `Counter` objects to keep track of character frequencies. The `p_count` stores the frequency of each character in the string `p`, while `s_count` keeps track of the current window in `s`. As the window slides over `s`, the code checks if the current window's character frequency matches `p_count`. If they match, it means the current window is an anagram of `p`, and the starting index of this window is added to the result list.

Given a string expression representing arbitrarily nested ternary expressions, evaluate the expression, and return the result of it.
You can always assume that the given expression is valid and only contains digits, '?', ':', 'T', and 'F' where 'T' is true and 'F' is false. All the numbers in the expression are one-digit numbers (i.e., in the range [0, 9]).
The conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, 'T' or 'F'.
 
Example 1:

Input: expression = "T?2:3"
Output: "2"
Explanation: If true, then result is 2; otherwise result is 3.

Example 2:

Input: expression = "F?1:T?4:5"
Output: "4"
Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:
"(F ? 1 : (T ? 4 : 5))" --> "(F ? 1 : 4)" --> "4"
or "(F ? 1 : (T ? 4 : 5))" --> "(T ? 4 : 5)" --> "4"

Example 3:

Input: expression = "T?T?F:5:3"
Output: "F"
Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:
"(T ? (T ? F : 5) : 3)" --> "(T ? F : 3)" --> "F"
"(T ? (T ? F : 5) : 3)" --> "(T ? F : 5)" --> "F"

 
Constraints:

5 <= expression.length <= 104
expression consists of digits, 'T', 'F', '?', and ':'.
It is guaranteed that expression is a valid ternary expression and that each number is a one-digit number.



```python
class Solution:
    def parseTernary(self, expression: str) -> str:
        def evaluate(index):
            # Base case: if the current character is a digit or 'T'/'F', return it
            if index == len(expression) - 1 or expression[index + 1] == ':':
                return expression[index], index + 2
            
            # Recursive case: process the ternary expression
            if expression[index] == 'T':
                # If the condition is true, evaluate the true branch
                result, new_index = evaluate(index + 2)
            else:
                # If the condition is false, skip the true branch and evaluate the false branch
                # Find the matching ':' for the current '?'
                balance = 1
                new_index = index + 2
                while balance > 0:
                    if expression[new_index] == '?':
                        balance += 1
                    elif expression[new_index] == ':':
                        balance -= 1
                    new_index += 1
                result, new_index = evaluate(new_index)
            
            return result, new_index
        
        result, _ = evaluate(0)
        return result
```

This solution uses a recursive helper function `evaluate` to parse and evaluate the ternary expression. The function keeps track of the current index in the expression and processes it according to the rules of ternary expressions. It handles the right-to-left grouping of ternary expressions by using a balance counter to find the matching `:` for each `?`.

Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].
 
Example 1:

Input: n = 13, k = 2
Output: 10
Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.

Example 2:

Input: n = 1, k = 1
Output: 1

 
Constraints:

1 <= k <= n <= 109



```python
class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        current = 1
        k -= 1  # Adjust k to be zero-indexed

        while k > 0:
            count = self.getCntNodes(current, n)
            if count <= k:
                current += 1
                k -= count
            else:
                current *= 10
                k -= 1
        return current

    def getCntNodes(self, current: int, n: int) -> int:
        nxt = current + 1
        totalNodes = 0
        while current <= n:
            totalNodes += min(n - current + 1, nxt - current)
            current *= 10
            nxt *= 10
        return totalNodes
```

This solution efficiently finds the k-th lexicographically smallest integer in the range [1, n] by leveraging a counting mechanism to navigate through the tree of numbers in lexicographical order. The `getCntNodes` function calculates the number of nodes in the subtree rooted at `current` without having to explicitly list them, making it suitable for large values of n up to 10^9.

You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.
Given the integer n, return the number of complete rows of the staircase you will build.
 
Example 1:


Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.

Example 2:


Input: n = 8
Output: 3
Explanation: Because the 4th row is incomplete, we return 3.

 
Constraints:

1 <= n <= 231 - 1



```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        # Using the formula derived from the sum of the first k natural numbers: k(k + 1)/2 <= n
        # Rearranging gives us a quadratic equation: k^2 + k - 2n <= 0
        # Solving for k using the quadratic formula: k = (-b + sqrt(b^2 - 4ac)) / 2a
        # Here, a = 1, b = 1, c = -2n
        import math
        k = (-1 + math.sqrt(1 + 8 * n)) / 2
        return int(k)
```

This solution uses the mathematical approach to solve the problem efficiently. The quadratic formula is derived from the sum of the first k natural numbers, which represents the total number of coins needed to form k complete rows. The solution is then computed using this formula, and the integer part of the result is returned as the number of complete rows.

Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears at most twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant auxiliary space, excluding the space needed to store the output
 
Example 1:
Input: nums = [4,3,2,7,8,2,3,1]
Output: [2,3]
Example 2:
Input: nums = [1,1,2]
Output: [1]
Example 3:
Input: nums = [1]
Output: []

 
Constraints:

n == nums.length
1 <= n <= 105
1 <= nums[i] <= n
Each element in nums appears once or twice.



```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            while nums[i] != nums[nums[i] - 1]:
                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
        return [v for i, v in enumerate(nums) if v != i + 1]
```

Given an array of characters chars, compress it using the following algorithm:
Begin with an empty string s. For each group of consecutive repeating characters in chars:

If the group's length is 1, append the character to s.
Otherwise, append the character followed by the group's length.

The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.
After you are done modifying the input array, return the new length of the array.
You must write an algorithm that uses only constant extra space.
 
Example 1:

Input: chars = ["a","a","b","b","c","c","c"]
Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".

Example 2:

Input: chars = ["a"]
Output: Return 1, and the first character of the input array should be: ["a"]
Explanation: The only group is "a", which remains uncompressed since it's a single character.

Example 3:

Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".
 
Constraints:

1 <= chars.length <= 2000
chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.



```python
from typing import List

class Solution:
    def compress(self, chars: List[str]) -> int:
        if not chars:
            return 0
        
        write_index = 0
        read_index = 0
        
        while read_index < len(chars):
            char = chars[read_index]
            count = 0
            
            # Count the number of occurrences of the current character
            while read_index < len(chars) and chars[read_index] == char:
                read_index += 1
                count += 1
            
            # Write the character to the write_index
            chars[write_index] = char
            write_index += 1
            
            # If the count is greater than 1, write the count as well
            if count > 1:
                for digit in str(count):
                    chars[write_index] = digit
                    write_index += 1
        
        return write_index
```

This solution compresses the input array `chars` in place, using a two-pointer technique. The `read_index` is used to traverse the input array, while the `write_index` is used to write the compressed characters back into the array. The solution handles groups of characters and writes the count of each group only if it is greater than 1. The function returns the new length of the compressed array.

You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.
Check if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.

For example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].
While for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.

Return true if nums is the only shortest supersequence for sequences, or false otherwise.
A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.
 
Example 1:

Input: nums = [1,2,3], sequences = [[1,2],[1,3]]
Output: false
Explanation: There are two possible supersequences: [1,2,3] and [1,3,2].
The sequence [1,2] is a subsequence of both: [1,2,3] and [1,3,2].
The sequence [1,3] is a subsequence of both: [1,2,3] and [1,3,2].
Since nums is not the only shortest supersequence, we return false.

Example 2:

Input: nums = [1,2,3], sequences = [[1,2]]
Output: false
Explanation: The shortest possible supersequence is [1,2].
The sequence [1,2] is a subsequence of it: [1,2].
Since nums is not the shortest supersequence, we return false.

Example 3:

Input: nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
Output: true
Explanation: The shortest possible supersequence is [1,2,3].
The sequence [1,2] is a subsequence of it: [1,2,3].
The sequence [1,3] is a subsequence of it: [1,2,3].
The sequence [2,3] is a subsequence of it: [1,2,3].
Since nums is the only shortest supersequence, we return true.

 
Constraints:

n == nums.length
1 <= n <= 104
nums is a permutation of all the integers in the range [1, n].
1 <= sequences.length <= 104
1 <= sequences[i].length <= 104
1 <= sum(sequences[i].length) <= 105
1 <= sequences[i][j] <= n
All the arrays of sequences are unique.
sequences[i] is a subsequence of nums.



```python
from collections import deque
from itertools import pairwise
from typing import List

class Solution:
    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -> bool:
        n = len(nums)
        g = [[] for _ in range(n)]
        indeg = [0] * n
        for seq in sequences:
            for a, b in pairwise(seq):
                a, b = a - 1, b - 1
                g[a].append(b)
                indeg[b] += 1
        q = deque(i for i, x in enumerate(indeg) if x == 0)
        while len(q) == 1:
            i = q.popleft()
            for j in g[i]:
                indeg[j] -= 1
                if indeg[j] == 0:
                    q.append(j)
        return len(q) == 0
```

This solution constructs a directed graph from the given sequences and uses topological sorting to determine if `nums` is the only shortest supersequence. The graph is represented by adjacency lists `g`, and the in-degrees of nodes are stored in `indeg`. The algorithm checks if there is a unique topological order that matches `nums`. If at any point there are multiple nodes with zero in-degree, it means there is more than one way to reconstruct the sequence, and the function returns `False`. If the entire sequence can be reconstructed uniquely, it returns `True`.

You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
 
Example 1:


Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]

Example 2:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]

Example 3:

Input: l1 = [0], l2 = [0]
Output: [0]

 
Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.

 
Follow up: Could you solve it without reversing the input lists?


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        # Helper function to get the length of a linked list
        def get_length(node):
            length = 0
            while node:
                length += 1
                node = node.next
            return length
        
        # Helper function to add nodes with the same length
        def add_nodes(node1, node2):
            if not node1 and not node2:
                return None, 0
            next_node, carry = add_nodes(node1.next, node2.next)
            total = node1.val + node2.val + carry
            current = ListNode(total % 10)
            current.next = next_node
            return current, total // 10
        
        # Get lengths of both lists
        len1, len2 = get_length(l1), get_length(l2)
        
        # Align the lists by padding the shorter list with zeros
        head1, head2 = l1, l2
        if len1 < len2:
            for _ in range(len2 - len1):
                head1 = ListNode(0, head1)
        else:
            for _ in range(len1 - len2):
                head2 = ListNode(0, head2)
        
        # Add the two lists
        result, carry = add_nodes(head1, head2)
        
        # If there's a carry left, add a new node at the beginning
        if carry:
            result = ListNode(carry, result)
        
        return result
```

This solution addresses the problem by first calculating the lengths of the two linked lists. It then aligns the lists by padding the shorter one with leading zeros. After aligning, it recursively adds corresponding nodes and handles the carry. Finally, if there is a carry left after processing all nodes, it adds a new node at the beginning of the result list. This approach ensures that the input lists are not reversed.

Given an integer array nums, return the number of all the arithmetic subsequences of nums.
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.

A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].

The test cases are generated so that the answer fits in 32-bit integer.
 
Example 1:

Input: nums = [2,4,6,8,10]
Output: 7
Explanation: All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]

Example 2:

Input: nums = [7,7,7,7,7]
Output: 16
Explanation: Any subsequence of this array is arithmetic.

 
Constraints:

1  <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1



```python
from typing import List
from collections import defaultdict

class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        dp = [defaultdict(int) for _ in range(n)]
        
        for i in range(n):
            for j in range(i):
                diff = nums[i] - nums[j]
                if diff < -2**31 or diff > 2**31 - 1:
                    continue
                dp[i][diff] += dp[j][diff] + 1
                count += dp[j][diff]
        
        return count
```

This solution uses dynamic programming with a hash map to keep track of the number of arithmetic subsequences ending at each index with a specific difference. The `dp[i][diff]` stores the number of arithmetic subsequences that end at index `i` with a common difference `diff`. The solution iterates over all pairs of indices `(i, j)` where `i > j` and updates the count of arithmetic subsequences. The total count of such subsequences is returned as the result.

You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).
Return the number of boomerangs.
 
Example 1:

Input: points = [[0,0],[1,0],[2,0]]
Output: 2
Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].

Example 2:

Input: points = [[1,1],[2,2],[3,3]]
Output: 2

Example 3:

Input: points = [[1,1]]
Output: 0

 
Constraints:

n == points.length
1 <= n <= 500
points[i].length == 2
-104 <= xi, yi <= 104
All the points are unique.



```python
from typing import List
from collections import defaultdict

class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        def distance(p1, p2):
            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2
        
        count = 0
        for i in points:
            dist_map = defaultdict(int)
            for j in points:
                dist_map[distance(i, j)] += 1
            for dist in dist_map:
                count += dist_map[dist] * (dist_map[dist] - 1)
        
        return count
```

This solution calculates the number of boomerangs by iterating through each point and counting the distances to all other points. It uses a dictionary to keep track of the number of points at each distance from the current point. For each distance, it calculates the number of boomerangs by considering all pairs of points that are at that distance from the current point. The formula `dist_map[dist] * (dist_map[dist] - 1)` counts the permutations of two points from the group of points at the same distance, which corresponds to the number of boomerangs with the current point as the middle point.

Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
 
Example 1:
Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:
Input: nums = [1,1]
Output: [2]

 
Constraints:

n == nums.length
1 <= n <= 105
1 <= nums[i] <= n

 
Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.


```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        s = set(nums)
        return [x for x in range(1, len(nums) + 1) if x not in s]

```

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.
Basically, the deletion can be divided into two stages:

Search for a node to remove.
If the node is found, delete the node.

 
Example 1:


Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.


Example 2:

Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.

Example 3:

Input: root = [], key = 0
Output: []

 
Constraints:

The number of nodes in the tree is in the range [0, 104].
-105 <= Node.val <= 105
Each node has a unique value.
root is a valid binary search tree.
-105 <= key <= 105

 
Follow up: Could you solve it with time complexity O(height of tree)?


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if root is None:
            return None
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
            return root
        if root.val < key:
            root.right = self.deleteNode(root.right, key)
            return root
        if root.left is None:
            return root.right
        if root.right is None:
            return root.left
        node = root.right
        while node.left:
            node = node.left
        node.left = root.left
        root = root.right
        return root
```

This code defines a method `deleteNode` within the `Solution` class to delete a node with a given key from a Binary Search Tree (BST). The method handles three main cases when the node to be deleted is found:
1. If the node has no left child, it returns the right subtree.
2. If the node has no right child, it returns the left subtree.
3. If the node has both children, it finds the leftmost node in the right subtree, attaches the left subtree to this node, and returns the right subtree as the new root. 

The method ensures that the BST properties are maintained after the deletion. The time complexity of this solution is O(height of the tree), which is efficient for balanced trees.

Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.
Return the sorted string. If there are multiple answers, return any of them.
 
Example 1:

Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.

Example 2:

Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.

Example 3:

Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.

 
Constraints:

1 <= s.length <= 5 * 105
s consists of uppercase and lowercase English letters and digits.



```python
class Solution:
    def frequencySort(self, s: str) -> str:
        from collections import Counter
        
        # Count the frequency of each character in the string
        freq = Counter(s)
        
        # Sort the characters based on their frequency in descending order
        # If frequencies are the same, the order of characters does not matter
        sorted_chars = sorted(freq.keys(), key=lambda x: freq[x], reverse=True)
        
        # Build the result string by repeating each character by its frequency
        result = ''.join(char * freq[char] for char in sorted_chars)
        
        return result
```

This solution uses the `Counter` class from the `collections` module to count the frequency of each character in the string. It then sorts the characters by their frequency in descending order and constructs the result string by repeating each character according to its frequency.

There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.
Given the array points, return the minimum number of arrows that must be shot to burst all balloons.
 
Example 1:

Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].

Example 2:

Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.

Example 3:

Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].

 
Constraints:

1 <= points.length <= 105
points[i].length == 2
-231 <= xstart < xend <= 231 - 1



```python
from typing import List

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        # Sort the balloons by their end coordinates
        points.sort(key=lambda x: x[1])
        
        # Initialize the number of arrows and the position of the last arrow shot
        arrows = 0
        last_arrow_position = -float('inf')
        
        for start, end in points:
            # If the current balloon starts after the last arrow shot, we need a new arrow
            if start > last_arrow_position:
                arrows += 1
                last_arrow_position = end
        
        return arrows
```

### Explanation:
1. **Sorting**: The key idea is to sort the balloons by their end coordinates. This way, we can always try to burst as many balloons as possible with one arrow by shooting at the end of the first balloon in the sorted list.
2. **Initialization**: We initialize `arrows` to 0 and `last_arrow_position` to negative infinity to represent that no arrow has been shot yet.
3. **Iterating through Balloons**: For each balloon, if its start coordinate is greater than `last_arrow_position`, it means we need a new arrow to burst this balloon (and potentially more). We increment the arrow count and update `last_arrow_position` to the end coordinate of the current balloon.
4. **Return Result**: Finally, we return the total number of arrows needed.

Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.
In one move, you can increment n - 1 elements of the array by 1.
 
Example 1:

Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

Example 2:

Input: nums = [1,1,1]
Output: 0

 
Constraints:

n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109
The answer is guaranteed to fit in a 32-bit integer.



To solve the problem of finding the minimum number of moves required to make all elements in an array equal, we can use the following approach:

1. **Understanding the Problem**: Incrementing `n-1` elements by 1 is equivalent to decrementing 1 element by 1. This means that to make all elements equal, we need to reduce all elements to the minimum element in the array.

2. **Mathematical Insight**: Suppose the minimum element in the array is `min_val`. To make all elements equal to `min_val`, each element `num` in the array needs to be reduced by `num - min_val`. The total number of moves required is the sum of all such reductions.

3. **Implementation**: 
   - Find the minimum value in the array.
   - Compute the sum of the differences between each element and the minimum value.

Here is the implementation of the solution:

```python
from typing import List

class Solution:
    def minMoves(self, nums: List[int]) -> int:
        min_val = min(nums)
        return sum(num - min_val for num in nums)
```

This solution works as follows:
- It first finds the minimum value in the array using the `min()` function.
- It then calculates the total number of moves by summing up the differences between each element and the minimum value.

This approach is efficient with a time complexity of \(O(n)\), where \(n\) is the length of the array, and it fits within the constraints provided.

Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

 
Example 1:

Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Output: 2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0

Example 2:

Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
Output: 1

 
Constraints:

n == nums1.length
n == nums2.length
n == nums3.length
n == nums4.length
1 <= n <= 200
-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228



```python
from typing import List
from collections import defaultdict

class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        # Create a dictionary to store the sum of pairs from nums1 and nums2
        sum_ab = defaultdict(int)
        for a in nums1:
            for b in nums2:
                sum_ab[a + b] += 1
        
        # Count the number of tuples that sum to zero
        count = 0
        for c in nums3:
            for d in nums4:
                if -(c + d) in sum_ab:
                    count += sum_ab[-(c + d)]
        
        return count
```

This solution uses a hash map to store the sums of all pairs from `nums1` and `nums2`. It then iterates over all pairs from `nums3` and `nums4`, checking if the negative of their sum exists in the hash map. If it does, it adds the count of that sum from the hash map to the result. This approach reduces the time complexity to O(n^2) compared to the naive O(n^4) solution.

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
 
Example 1:

Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.

Example 2:

Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.

 
Constraints:

1 <= g.length <= 3 * 104
0 <= s.length <= 3 * 104
1 <= g[i], s[j] <= 231 - 1

 
Note: This question is the same as  2410: Maximum Matching of Players With Trainers.


```python
from typing import List

class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        # Sort the greed factors and cookie sizes
        g.sort()
        s.sort()
        
        child_i = cookie_j = 0
        
        # Try to satisfy each child with the smallest available cookie
        while child_i < len(g) and cookie_j < len(s):
            if g[child_i] <= s[cookie_j]:
                # If the cookie can satisfy the child, move to the next child
                child_i += 1
            # Move to the next cookie in any case
            cookie_j += 1
        
        # The number of content children is equal to the number of greed factors we've satisfied
        return child_i
```

This solution sorts the greed factors and cookie sizes, then uses a greedy approach to match the smallest available cookie to each child, maximizing the number of content children.

Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false.
 
Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.

Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].

Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].

 
Constraints:

n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109



```python
from typing import List

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        if len(nums) < 3:
            return False
        
        # This will keep track of the potential '3' in the 132 pattern
        third = float('-inf')
        # This stack will be used to keep elements that could be '3' candidates
        stack = []
        
        # Traverse the array from the end to the start
        for num in reversed(nums):
            # Check if we can find a valid '1'
            if num < third:
                return True
            
            # Maintain the stack to find a valid '3'
            while stack and stack[-1] < num:
                third = stack.pop()
            
            # Push the current number as a potential '3'
            stack.append(num)
        
        return False
```

This solution uses a stack to keep track of potential '3' values in the 132 pattern. By iterating from the end of the array, we can efficiently determine if a valid '1' exists for any given '3'. The time complexity of this solution is O(n), making it suitable for the upper constraint of n = 2 * 10^5.

You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:

If nums[i] is positive, move nums[i] steps forward, and
If nums[i] is negative, move nums[i] steps backward.

Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.
A cycle in the array consists of a sequence of indices seq of length k where:

Following the movement rules above results in the repeating index sequence seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
Every nums[seq[j]] is either all positive or all negative.
k > 1

Return true if there is a cycle in nums, or false otherwise.
 
Example 1:


Input: nums = [2,-1,1,2,2]
Output: true
Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
We can see the cycle 0 --> 2 --> 3 --> 0 --> ..., and all of its nodes are white (jumping in the same direction).

Example 2:


Input: nums = [-1,-2,-3,-4,-5,6]
Output: false
Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
The only cycle is of size 1, so we return false.

Example 3:


Input: nums = [1,-1,5,1,4]
Output: true
Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
We can see the cycle 0 --> 1 --> 0 --> ..., and while it is of size > 1, it has a node jumping forward and a node jumping backward, so it is not a cycle.
We can see the cycle 3 --> 4 --> 3 --> ..., and all of its nodes are white (jumping in the same direction).

 
Constraints:

1 <= nums.length <= 5000
-1000 <= nums[i] <= 1000
nums[i] != 0

 
Follow up: Could you solve it in O(n) time complexity and O(1) extra space complexity?


To solve this problem, we need to detect cycles in a circular array where the movement is determined by the values in the array. The cycle must satisfy the following conditions:
1. It must consist of more than one element.
2. All elements in the cycle must move in the same direction (either all forward or all backward).

Given the constraints, we need an O(n) time complexity and O(1) extra space complexity solution. This suggests that we should modify the input array in place to keep track of visited elements.

Here's the step-by-step approach:
1. Iterate through each element in the array.
2. Use the current index as the starting point and try to find a cycle.
3. Mark visited elements by changing their values to 0 (or any other placeholder that is not in the range of the input values).
4. If you encounter a 0 or a node moving in the opposite direction, stop the search for the current cycle.
5. If you encounter the starting index again, a cycle is found.

Let's implement this approach in the provided starter code.

```python
from typing import List

class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        n = len(nums)
        
        def move(i):
            return (i + nums[i]) % n
        
        for i in range(n):
            if nums[i] == 0:
                continue
            
            slow, fast = i, i
            direction = nums[i] > 0
            
            while True:
                next_slow = move(slow)
                if nums[next_slow] == 0 or (nums[next_slow] > 0) != direction:
                    break
                slow = next_slow
                
                next_fast = move(fast)
                if nums[next_fast] == 0 or (nums[next_fast] > 0) != direction:
                    break
                fast = move(next_fast)
                if nums[fast] == 0 or (nums[fast] > 0) != direction:
                    break
                if slow == fast:
                    if slow == move(slow):
                        break
                    return True
            
            slow = i
            while nums[slow] != 0 and (nums[slow] > 0) == direction:
                next_slow = move(slow)
                nums[slow] = 0
                slow = next_slow
        
        return False
```

This solution ensures that we only traverse each element a limited number of times, resulting in O(n) time complexity. The space complexity is O(1) because we modify the input array in place without using any additional data structures.

There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.
You can feed the pigs according to these steps:

Choose some live pigs to feed.
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.
Wait for minutesToDie minutes. You may not feed any other pigs during this time.
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
Repeat this process until you run out of time.

Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.
 
Example 1:

Input: buckets = 4, minutesToDie = 15, minutesToTest = 15
Output: 2
Explanation: We can determine the poisonous bucket as follows:
At time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.
At time 15, there are 4 possible outcomes:
- If only the first pig dies, then bucket 1 must be poisonous.
- If only the second pig dies, then bucket 3 must be poisonous.
- If both pigs die, then bucket 2 must be poisonous.
- If neither pig dies, then bucket 4 must be poisonous.

Example 2:

Input: buckets = 4, minutesToDie = 15, minutesToTest = 30
Output: 2
Explanation: We can determine the poisonous bucket as follows:
At time 0, feed the first pig bucket 1, and feed the second pig bucket 2.
At time 15, there are 2 possible outcomes:
- If either pig dies, then the poisonous bucket is the one it was fed.
- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.
At time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.

 
Constraints:

1 <= buckets <= 1000
1 <= minutesToDie <= minutesToTest <= 100



To solve this problem, we need to determine the minimum number of pigs required to identify the poisonous bucket within the given time constraints. The key insight here is to understand how each pig can be used to gather information.

Each pig can be in one of several states after each test cycle: alive or dead. If we have `minutesToTest / minutesToDie` test cycles, each pig can be in one of `minutesToTest / minutesToDie + 1` states (alive after each cycle or dead in one of the cycles).

Given `p` pigs, each pig can be in one of `s` states (where `s` is the number of test cycles plus one), the total number of different states (combinations of states across all pigs) is `s^p`. To uniquely identify one poisonous bucket out of `b` buckets, we need at least `s^p >= b`.

Thus, we need to find the smallest `p` such that `(minutesToTest / minutesToDie + 1)^p >= buckets`.

Let's implement this logic in the provided starter code.
```python
class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the number of states each pig can be in
        states_per_pig = minutesToTest // minutesToDie + 1
        
        # Find the minimum number of pigs needed
        pigs = 0
        while states_per_pig ** pigs < buckets:
            pigs += 1
        
        return pigs
```
This code calculates the minimum number of pigs required by iteratively increasing the number of pigs until the total number of possible states is at least equal to the number of buckets. The number of states each pig can be in is determined by the number of test cycles plus one.

Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.
 
Example 1:

Input: s = "abab"
Output: true
Explanation: It is the substring "ab" twice.

Example 2:

Input: s = "aba"
Output: false

Example 3:

Input: s = "abcabcabcabc"
Output: true
Explanation: It is the substring "abc" four times or the substring "abcabc" twice.

 
Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.



```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        # Create a new string by concatenating the original string with itself
        # and removing the first and last character of the new string.
        # This helps in checking if the original string is a repeated pattern.
        new_string = s + s
        # Check if the original string is in the new string, excluding the first and last character.
        return s in new_string[1:-1]
```

This solution works by leveraging the property that if a string `s` can be constructed by repeating a substring, then `s` will appear in the concatenation of `s` with itself, excluding the first and last characters. This is because the repeated pattern will overlap in the middle of the concatenated string.

The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, return the Hamming distance between them.
 
Example 1:

Input: x = 1, y = 4
Output: 2
Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
The above arrows point to positions where the corresponding bits are different.

Example 2:

Input: x = 3, y = 1
Output: 1

 
Constraints:

0 <= x, y <= 231 - 1

 
Note: This question is the same as  2220: Minimum Bit Flips to Convert Number.


```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        # XOR the two numbers to find differing bits
        xor_result = x ^ y
        # Count the number of 1s in the binary representation of the XOR result
        return bin(xor_result).count('1')
```

Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.
In one move, you can increment or decrement an element of the array by 1.
Test cases are designed so that the answer will fit in a 32-bit integer.
 
Example 1:

Input: nums = [1,2,3]
Output: 2
Explanation:
Only two moves are needed (remember each move increments or decrements one element):
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]

Example 2:

Input: nums = [1,10,2,9]
Output: 16

 
Constraints:

n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109



To solve the problem of finding the minimum number of moves required to make all elements of an array equal, we can leverage the properties of the median. The median minimizes the sum of absolute deviations from all other points in the array. Therefore, the optimal target value to which all elements should be moved is the median of the array.

Here is the Python code to solve the problem:

```python
from typing import List

class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        # Find the median
        median = sorted(nums)[len(nums) // 2]
        
        # Calculate the total number of moves required to make all elements equal to the median
        moves = sum(abs(num - median) for num in nums)
        
        return moves
```

### Explanation:
1. **Finding the Median**: 
   - We sort the array and find the median. For an array of odd length, the median is the middle element. For an array of even length, either of the two middle elements can be chosen because the sum of absolute deviations will be the same. Here, we choose the lower middle element for simplicity.

2. **Calculating Moves**:
   - We calculate the total number of moves required to make all elements equal to the median. This is done by summing up the absolute differences between each element and the median.

This approach ensures that the solution is optimal and efficient, with a time complexity of \(O(n \log n)\) due to the sorting step, which is suitable given the constraints.

You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.
 
Example 1:


Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.

Example 2:

Input: grid = [[1]]
Output: 4

Example 3:

Input: grid = [[1,0]]
Output: 4

 
Constraints:

row == grid.length
col == grid[i].length
1 <= row, col <= 100
grid[i][j] is 0 or 1.
There is exactly one island in grid.



```python
from typing import List

class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        rows, cols = len(grid), len(grid[0])
        perimeter = 0
        
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    # Start with 4 sides
                    perimeter += 4
                    
                    # Check the top neighbor
                    if i > 0 and grid[i-1][j] == 1:
                        perimeter -= 2
                    
                    # Check the left neighbor
                    if j > 0 and grid[i][j-1] == 1:
                        perimeter -= 2
        
        return perimeter
```

This solution iterates through each cell in the grid. When it encounters a land cell (`grid[i][j] == 1`), it initially assumes that this cell contributes 4 to the perimeter. It then checks the top and left neighbors to see if they are also land cells. If they are, it subtracts 2 from the perimeter for each shared side. This approach ensures that only the external sides of the island are counted towards the perimeter.

In the "100 game" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.
What if we change the game so that players cannot re-use integers?
For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.
Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.
 
Example 1:

Input: maxChoosableInteger = 10, desiredTotal = 11
Output: false
Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.

Example 2:

Input: maxChoosableInteger = 10, desiredTotal = 0
Output: true

Example 3:

Input: maxChoosableInteger = 10, desiredTotal = 1
Output: true

 
Constraints:

1 <= maxChoosableInteger <= 20
0 <= desiredTotal <= 300



To solve this problem, we can use a recursive approach with memoization to determine if the first player can force a win. The key idea is to explore all possible moves for the first player and check if there is any move that guarantees a win, assuming both players play optimally.

Here's the step-by-step solution:

1. **Base Case**: If the `desiredTotal` is less than or equal to 0, the first player wins immediately.
2. **Total Sum Check**: If the sum of all numbers from 1 to `maxChoosableInteger` is less than the `desiredTotal`, the first player cannot win because the total sum of all possible moves is insufficient to reach the `desiredTotal`.
3. **Memoization**: Use a dictionary to store the results of subproblems to avoid redundant calculations.
4. **Recursive Function**: Define a recursive function that checks all possible moves for the current player. For each move, check if the opponent cannot win in the subsequent state.
5. **Bitmasking**: Use a bitmask to represent the state of the available numbers. Each bit in the bitmask corresponds to a number from 1 to `maxChoosableInteger`.

Here's the implementation:

```python
class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        from functools import lru_cache
        
        # Base case: if desiredTotal is 0, the first player wins
        if desiredTotal <= 0:
            return True
        
        # Calculate the total sum of numbers from 1 to maxChoosableInteger
        total_sum = maxChoosableInteger * (maxChoosableInteger + 1) // 2
        
        # If the total sum is less than desiredTotal, the first player cannot win
        if total_sum < desiredTotal:
            return False
        
        # Use a bitmask to represent the state of the available numbers
        @lru_cache(None)
        def can_win(state, current_total):
            # Try each number from 1 to maxChoosableInteger
            for num in range(1, maxChoosableInteger + 1):
                # Create a bitmask for the current number
                mask = 1 << (num - 1)
                
                # Check if the number is available (not used yet)
                if state & mask == 0:
                    # If choosing this number makes the current_total >= desiredTotal
                    if current_total + num >= desiredTotal:
                        return True
                    
                    # Otherwise, check if the opponent cannot win in the next state
                    if not can_win(state | mask, current_total + num):
                        return True
            
            # If no move can force a win, return False
            return False
        
        # Start the game with an empty state (all numbers available) and current_total = 0
        return can_win(0, 0)
```

### Explanation:
- **Bitmasking**: The state is represented by an integer where each bit indicates whether a number has been used. For example, if `maxChoosableInteger` is 5, the state `0b10100` means numbers 1 and 3 have been used.
- **Recursive Function**: The `can_win` function checks if the current player can force a win given the current state and total. It tries each available number and checks if the opponent cannot win in the next state.
- **Memoization**: The `lru_cache` decorator is used to memoize the results of subproblems, which significantly improves the performance by avoiding redundant calculations.

This solution efficiently determines if the first player can force a win by exploring all possible moves and using memoization to store intermediate results.

You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi.
Return the minimum number of transactions required to settle the debt.
 
Example 1:

Input: transactions = [[0,1,10],[2,0,5]]
Output: 2
Explanation:
Person #0 gave person #1 $10.
Person #2 gave person #0 $5.
Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.

Example 2:

Input: transactions = [[0,1,10],[1,0,1],[1,2,5],[2,0,5]]
Output: 1
Explanation:
Person #0 gave person #1 $10.
Person #1 gave person #0 $1.
Person #1 gave person #2 $5.
Person #2 gave person #0 $5.
Therefore, person #1 only need to give person #0 $4, and all debt is settled.

 
Constraints:

1 <= transactions.length <= 8
transactions[i].length == 3
0 <= fromi, toi < 12
fromi != toi
1 <= amounti <= 100



```python
from typing import List
from collections import defaultdict

class Solution:
    def minTransfers(self, transactions: List[List[int]]) -> int:
        # Calculate the net balance for each person
        balance = defaultdict(int)
        for frm, to, amount in transactions:
            balance[frm] -= amount
            balance[to] += amount
        
        # Filter out people with zero balance
        net_balance = [v for v in balance.values() if v != 0]
        
        # Helper function to find the minimum number of transactions
        def settle(start, net_balance):
            # Skip settled accounts
            while start < len(net_balance) and net_balance[start] == 0:
                start += 1
            
            # If all accounts are settled, return 0
            if start == len(net_balance):
                return 0
            
            min_transactions = float('inf')
            for i in range(start + 1, len(net_balance)):
                # If there is a potential settlement (one positive, one negative)
                if net_balance[start] * net_balance[i] < 0:
                    # Perform the transaction
                    net_balance[i] += net_balance[start]
                    # Recurse for the next person
                    min_transactions = min(min_transactions, 1 + settle(start + 1, net_balance))
                    # Backtrack
                    net_balance[i] -= net_balance[start]
            
            return min_transactions
        
        return settle(0, net_balance)
```

This solution calculates the net balance for each person and then uses a recursive helper function to find the minimum number of transactions required to settle the debts. The function skips over people with zero balance and attempts to settle debts by finding pairs of positive and negative balances. It uses backtracking to explore different ways of settling the debts and keeps track of the minimum number of transactions needed.

We define str = [s, n] as the string str which consists of the string s concatenated n times.

For example, str == ["abc", 3] =="abcabcabc".

We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.

For example, s1 = "abc" can be obtained from s2 = "abdbec" based on our definition by removing the bolded underlined characters.

You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].
Return the maximum integer m such that str = [str2, m] can be obtained from str1.
 
Example 1:
Input: s1 = "acb", n1 = 4, s2 = "ab", n2 = 2
Output: 2
Example 2:
Input: s1 = "acb", n1 = 1, s2 = "acb", n2 = 1
Output: 1

 
Constraints:

1 <= s1.length, s2.length <= 100
s1 and s2 consist of lowercase English letters.
1 <= n1, n2 <= 106



```python
class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        if not s1 or not s2 or n1 == 0 or n2 == 0:
            return 0

        # To store the number of times s2 is matched and the corresponding position in s2
        index_map = {}
        count1, count2, index = 0, 0, 0

        # Run until we either run out of s1 or find a cycle
        while count1 < n1:
            # Iterate over s1
            for char in s1:
                if char == s2[index]:
                    index += 1
                    # If we have matched the whole s2, reset index and increase count2
                    if index == len(s2):
                        index = 0
                        count2 += 1
            # Increase the count of how many times we have concatenated s1
            count1 += 1

            # Check if we have seen this index before to detect a cycle
            if index in index_map:
                # We have found a cycle
                prev_count1, prev_count2 = index_map[index]
                pattern_count1 = count1 - prev_count1
                pattern_count2 = count2 - prev_count2

                # Calculate the number of complete cycles that can fit
                complete_cycles = (n1 - prev_count1) // pattern_count1
                count2 = prev_count2 + complete_cycles * pattern_count2
                count1 = prev_count1 + complete_cycles * pattern_count1

                # Break the loop if no more complete cycles can fit
                if count1 >= n1:
                    break
            else:
                # Store the current index and the counts in the map
                index_map[index] = (count1, count2)

        # Calculate how many times str2 can be formed from str1
        return count2 // n2
```

This solution uses a cycle detection approach to efficiently determine how many times `s2` can be obtained from `s1` when both are concatenated `n1` and `n2` times, respectively. The key idea is to find a cycle in the sequence of indices in `s2` as we iterate over concatenated `s1` strings. Once a cycle is detected, the number of times `s2` can be formed is calculated based on the length of the cycle.

We define the string base to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so base will look like this:

"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

Given a string s, return the number of unique non-empty substrings of s are present in base.
 
Example 1:

Input: s = "a"
Output: 1
Explanation: Only the substring "a" of s is in base.

Example 2:

Input: s = "cac"
Output: 2
Explanation: There are two substrings ("a", "c") of s in base.

Example 3:

Input: s = "zab"
Output: 6
Explanation: There are six substrings ("z", "a", "b", "za", "ab", and "zab") of s in base.

 
Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.



```python
class Solution:
    def findSubstringInWraproundString(self, s: str) -> int:
        # Dictionary to store the maximum length of substring ending with each character
        max_len_ending_with = {chr(ord('a') + i): 0 for i in range(26)}
        
        # Function to check if two characters are consecutive in the wraparound string
        def is_consecutive(c1, c2):
            return (ord(c2) - ord(c1)) % 26 == 1
        
        # Initialize the length of the current valid substring
        current_length = 0
        
        # Iterate over the string
        for i in range(len(s)):
            if i > 0 and is_consecutive(s[i - 1], s[i]):
                current_length += 1
            else:
                current_length = 1
            
            # Update the maximum length of substring ending with s[i]
            max_len_ending_with[s[i]] = max(max_len_ending_with[s[i]], current_length)
        
        # The total number of unique substrings is the sum of the maximum lengths
        return sum(max_len_ending_with.values())
```

This solution efficiently calculates the number of unique non-empty substrings of `s` that are present in the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz". It uses a dictionary to keep track of the maximum length of substrings ending with each character and updates this dictionary as it iterates through the input string `s`. The function `is_consecutive` checks if two characters are consecutive in the wraparound string, which helps in determining the length of valid substrings.

Given a string queryIP, return "IPv4" if IP is a valid IPv4 address, "IPv6" if IP is a valid IPv6 address or "Neither" if IP is not a correct IP of any type.
A valid IPv4 address is an IP in the form "x1.x2.x3.x4" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, "192.168.1.1" and "192.168.1.0" are valid IPv4 addresses while "192.168.01.1", "192.168.1.00", and "192.168@1.1" are invalid IPv4 addresses.
A valid IPv6 address is an IP in the form "x1:x2:x3:x4:x5:x6:x7:x8" where:

1 <= xi.length <= 4
xi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').
Leading zeros are allowed in xi.

For example, "2001:0db8:85a3:0000:0000:8a2e:0370:7334" and "2001:db8:85a3:0:0:8A2E:0370:7334" are valid IPv6 addresses, while "2001:0db8:85a3::8A2E:037j:7334" and "02001:0db8:85a3:0000:0000:8a2e:0370:7334" are invalid IPv6 addresses.
 
Example 1:

Input: queryIP = "172.16.254.1"
Output: "IPv4"
Explanation: This is a valid IPv4 address, return "IPv4".

Example 2:

Input: queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
Output: "IPv6"
Explanation: This is a valid IPv6 address, return "IPv6".

Example 3:

Input: queryIP = "256.256.256.256"
Output: "Neither"
Explanation: This is neither a IPv4 address nor a IPv6 address.

 
Constraints:

queryIP consists only of English letters, digits and the characters '.' and ':'.



```python
class Solution:
    def validIPAddress(self, queryIP: str) -> str:
        def is_valid_ipv4(ip):
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                if not part.isdigit():
                    return False
                if not 0 <= int(part) <= 255:
                    return False
                if part != str(int(part)):  # Check for leading zeros
                    return False
            return True

        def is_valid_ipv6(ip):
            parts = ip.split(':')
            if len(parts) != 8:
                return False
            for part in parts:
                if not (1 <= len(part) <= 4):
                    return False
                if not all(c in '0123456789abcdefABCDEF' for c in part):
                    return False
            return True

        if '.' in queryIP:
            return "IPv4" if is_valid_ipv4(queryIP) else "Neither"
        elif ':' in queryIP:
            return "IPv6" if is_valid_ipv6(queryIP) else "Neither"
        else:
            return "Neither"
```

You are given an array of points on the X-Y plane points where points[i] = [xi, yi]. The points form a polygon when joined sequentially.
Return true if this polygon is convex and false otherwise.
You may assume the polygon formed by given points is always a simple polygon. In other words, we ensure that exactly two edges intersect at each vertex and that edges otherwise don't intersect each other.
 
Example 1:


Input: points = [[0,0],[0,5],[5,5],[5,0]]
Output: true

Example 2:


Input: points = [[0,0],[0,10],[10,10],[10,0],[5,5]]
Output: false

 
Constraints:

3 <= points.length <= 104
points[i].length == 2
-104 <= xi, yi <= 104
All the given points are unique.



To determine if a polygon is convex given its vertices, we can use the concept of the cross product. The cross product of vectors can help us determine the orientation of the turn formed by three consecutive points. If all turns are in the same direction (either all clockwise or all counterclockwise), the polygon is convex. If there is a mix of directions, the polygon is concave.

Here's the solution using the cross product method:

```python
from typing import List

class Solution:
    def isConvex(self, points: List[List[int]]) -> bool:
        def cross_product(o, a, b):
            # Calculate the cross product of vectors OA and OB
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])
        
        n = len(points)
        if n < 3:
            return False  # A polygon must have at least 3 points
        
        # Determine the initial orientation
        prev_cross_product = 0
        
        for i in range(n):
            o = points[i]
            a = points[(i + 1) % n]
            b = points[(i + 2) % n]
            
            current_cross_product = cross_product(o, a, b)
            
            if current_cross_product != 0:
                if prev_cross_product * current_cross_product < 0:
                    return False
                prev_cross_product = current_cross_product
        
        return True
```

### Explanation:
1. **Cross Product Calculation**: The function `cross_product(o, a, b)` calculates the cross product of vectors OA and OB. The sign of the cross product indicates the direction of the turn:
   - Positive: Counterclockwise turn.
   - Negative: Clockwise turn.
   - Zero: Collinear points.

2. **Iterate Through Points**: We iterate through each point in the polygon and calculate the cross product for every triplet of consecutive points `(o, a, b)`.

3. **Check Consistency of Turns**: We maintain a `prev_cross_product` to store the sign of the first non-zero cross product we encounter. If we find a cross product with a different sign from `prev_cross_product`, the polygon is not convex, and we return `False`.

4. **Return Result**: If all cross products are consistent in sign, the polygon is convex, and we return `True`.

This approach ensures that we correctly determine the convexity of the polygon by checking the consistency of the turns formed by its vertices.

Given a string s, encode the string such that its encoded length is the shortest.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. k should be a positive integer.
If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them.
 
Example 1:

Input: s = "aaa"
Output: "aaa"
Explanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.

Example 2:

Input: s = "aaaaa"
Output: "5[a]"
Explanation: "5[a]" is shorter than "aaaaa" by 1 character.

Example 3:

Input: s = "aaaaaaaaaa"
Output: "10[a]"
Explanation: "a9[a]" or "9[a]a" are also valid solutions, both of them have the same length = 5, which is the same as "10[a]".

 
Constraints:

1 <= s.length <= 150
s consists of only lowercase English letters.



```python
class Solution:
    def encode(self, s: str) -> str:
        def find_repetition(sub):
            n = len(sub)
            for i in range(1, n // 2 + 1):
                if n % i == 0 and sub[:i] * (n // i) == sub:
                    return i
            return n

        def dp(i, j):
            if i == j:
                return s[i]
            if (i, j) in memo:
                return memo[(i, j)]
            substring = s[i:j+1]
            n = len(substring)
            rep_len = find_repetition(substring)
            if rep_len < n:
                encoded = f"{n // rep_len}[{dp(i, i + rep_len - 1)}]"
            else:
                encoded = substring
            
            for k in range(i, j):
                left = dp(i, k)
                right = dp(k + 1, j)
                combined = left + right
                if len(combined) < len(encoded):
                    encoded = combined
            
            memo[(i, j)] = encoded
            return encoded
        
        memo = {}
        return dp(0, len(s) - 1)
```

This solution uses dynamic programming to find the shortest encoded string. The `find_repetition` function checks if a substring can be represented as a repetition of a smaller substring. The `dp` function recursively computes the shortest encoded string for each substring of `s` and uses memoization to avoid redundant calculations.

Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.
A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.
 
Example 1:

Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats"; 
"dogcatsdog" can be concatenated by "dog", "cats" and "dog"; 
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
Example 2:

Input: words = ["cat","dog","catdog"]
Output: ["catdog"]

 
Constraints:

1 <= words.length <= 104
1 <= words[i].length <= 30
words[i] consists of only lowercase English letters.
All the strings of words are unique.
1 <= sum(words[i].length) <= 105



```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False

    def insert(self, w):
        node = self
        for c in w:
            idx = ord(c) - ord('a')
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.is_end = True

class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        def dfs(w, start=0):
            if start == len(w):
                return True
            node = trie
            for i in range(start, len(w)):
                idx = ord(w[i]) - ord('a')
                if node.children[idx] is None:
                    return False
                node = node.children[idx]
                if node.is_end and dfs(w, i + 1):
                    return True
            return False

        trie = Trie()
        ans = []
        words.sort(key=lambda x: len(x))
        for w in words:
            if w:  # Ensure the word is not empty
                if dfs(w):
                    ans.append(w)
                else:
                    trie.insert(w)
        return ans
```

This solution uses a Trie data structure to efficiently store and search for words. The `dfs` function checks if a word can be formed by concatenating other words in the list. The list of words is sorted by length to ensure that when checking a word, all possible shorter words have already been inserted into the Trie.

You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.
Return true if you can make this square and false otherwise.
 
Example 1:


Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.

Example 2:

Input: matchsticks = [3,3,3,3,4]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.

 
Constraints:

1 <= matchsticks.length <= 15
1 <= matchsticks[i] <= 108



```python
from typing import List

class Solution:
    def makesquare(self, matchsticks: List[int]) -> bool:
        n = len(matchsticks)
        if n < 4:
            return False
        
        perimeter = sum(matchsticks)
        if perimeter % 4 != 0:
            return False
        
        side_length = perimeter // 4
        matchsticks.sort(reverse=True)  # Sort in descending order to optimize backtracking
        
        # Try to partition the matchsticks into 4 subsets, each with sum equal to side_length
        def dfs(index, current_sides):
            if index == n:
                return all(side == side_length for side in current_sides)
            
            for i in range(4):
                if current_sides[i] + matchsticks[index] <= side_length:
                    current_sides[i] += matchsticks[index]
                    if dfs(index + 1, current_sides):
                        return True
                    current_sides[i] -= matchsticks[index]
                
                # If the current side is 0, no need to try other sides
                if current_sides[i] == 0:
                    break
            
            return False
        
        return dfs(0, [0] * 4)
```

This solution uses a backtracking approach to try and partition the matchsticks into four subsets, each with a sum equal to one-fourth of the total perimeter. The matchsticks are sorted in descending order to help optimize the backtracking process by trying the largest matchsticks first.

You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.
 
Example 1:

Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.

Example 2:

Input: strs = ["10","0","1"], m = 1, n = 1
Output: 2
Explanation: The largest subset is {"0", "1"}, so the answer is 2.

 
Constraints:

1 <= strs.length <= 600
1 <= strs[i].length <= 100
strs[i] consists only of digits '0' and '1'.
1 <= m, n <= 100



```python
from typing import List

class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        # Create a 3D DP array with dimensions (len(strs) + 1) x (m + 1) x (n + 1)
        dp = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(len(strs) + 1)]
        
        # Iterate over each string in strs
        for i in range(1, len(strs) + 1):
            # Count the number of 0's and 1's in the current string
            zeros = strs[i - 1].count('0')
            ones = strs[i - 1].count('1')
            
            # Update the DP array
            for j in range(m + 1):
                for k in range(n + 1):
                    # If the current string can be included in the subset
                    if j >= zeros and k >= ones:
                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)
                    else:
                        dp[i][j][k] = dp[i - 1][j][k]
        
        # The answer is the maximum size of the subset with at most m 0's and n 1's
        return dp[len(strs)][m][n]
```

This solution uses dynamic programming to solve the problem. We define a 3D DP array `dp` where `dp[i][j][k]` represents the maximum size of the subset of the first `i` strings that contains at most `j` 0's and `k` 1's. We iterate over each string and update the DP array accordingly. The final answer is found in `dp[len(strs)][m][n]`.

Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.
Every house can be warmed, as long as the house is within the heater's warm radius range. 
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.
Notice that all the heaters follow your radius standard, and the warm radius will the same.
 
Example 1:

Input: houses = [1,2,3], heaters = [2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.

Example 2:

Input: houses = [1,2,3,4], heaters = [1,4]
Output: 1
Explanation: The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.

Example 3:

Input: houses = [1,5], heaters = [2]
Output: 3

 
Constraints:

1 <= houses.length, heaters.length <= 3 * 104
1 <= houses[i], heaters[i] <= 109



```python
from typing import List
import bisect

class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        heaters.sort()
        max_radius = 0
        
        for house in houses:
            # Find the index of the first heater that is not less than the house position
            idx = bisect.bisect_left(heaters, house)
            
            # Distance to the nearest heater on the right
            if idx < len(heaters):
                right_heater_distance = heaters[idx] - house
            else:
                right_heater_distance = float('inf')
            
            # Distance to the nearest heater on the left
            if idx > 0:
                left_heater_distance = house - heaters[idx - 1]
            else:
                left_heater_distance = float('inf')
            
            # The radius needed for this house is the minimum of the two distances
            radius_needed = min(left_heater_distance, right_heater_distance)
            
            # Update the maximum radius found so far
            max_radius = max(max_radius, radius_needed)
        
        return max_radius
```

This solution sorts the heaters first, which allows us to use binary search (via `bisect_left`) to efficiently find the nearest heaters to each house. We then calculate the minimum radius required to warm each house and keep track of the maximum radius needed overall. This approach ensures that we find the smallest possible radius that can warm all houses.

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.

Given an integer num, return its complement.
 
Example 1:

Input: num = 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.

Example 2:

Input: num = 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.

 
Constraints:

1 <= num < 231

 
Note: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/


```python
class Solution:
    def findComplement(self, num: int) -> int:
        # Convert the number to its binary representation without the '0b' prefix
        binary_representation = bin(num)[2:]
        
        # Create a mask with the same length as the binary representation, filled with 1s
        mask = int('1' * len(binary_representation), 2)
        
        # XOR the number with the mask to get the complement
        complement = num ^ mask
        
        return complement
```

This solution works by first converting the given integer to its binary representation and removing the '0b' prefix. It then creates a mask of the same length filled with 1s. By performing an XOR operation between the original number and this mask, we flip all the bits, resulting in the complement of the number.

The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.
 
Example 1:

Input: nums = [4,14,2]
Output: 6
Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case).
The answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.

Example 2:

Input: nums = [4,14,4]
Output: 4

 
Constraints:

1 <= nums.length <= 104
0 <= nums[i] <= 109
The answer for the given input will fit in a 32-bit integer.



```python
from typing import List

class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        total_distance = 0
        n = len(nums)
        
        # Iterate over each bit position (0 to 30, since 2^30 > 10^9)
        for i in range(32):
            count_ones = 0
            # Count the number of 1s at the ith bit position
            for num in nums:
                count_ones += (num >> i) & 1
            # The number of 0s at the ith bit position
            count_zeros = n - count_ones
            # The total Hamming distance for the ith bit position
            total_distance += count_ones * count_zeros
        
        return total_distance
```

This solution calculates the Hamming distance for each bit position separately. For each bit position, it counts the number of 1s and 0s across all numbers. The contribution to the total Hamming distance from that bit position is the product of the number of 1s and the number of 0s, as each 1 can pair with each 0 to form a differing bit in a Hamming distance. This approach is efficient with a time complexity of O(n * 32), which simplifies to O(n) since the number of bits is constant.

Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.
 
Example 1:

Input: n = 2
Output: 987
Explanation: 99 x 91 = 9009, 9009 % 1337 = 987

Example 2:

Input: n = 1
Output: 9

 
Constraints:

1 <= n <= 8



```python
class Solution:
    def largestPalindrome(self, n: int) -> int:
        if n == 1:
            return 9
        
        # Calculate the upper and lower bounds for n-digit numbers
        upper_bound = 10**n - 1
        lower_bound = 10**(n-1)
        
        # Start from the largest possible number and go downwards
        for num1 in range(upper_bound, lower_bound - 1, -1):
            # Form the potential palindrome
            palindrome = int(str(num1) + str(num1)[::-1])
            
            # Check if the palindrome can be formed by the product of two n-digit numbers
            for num2 in range(upper_bound, lower_bound - 1, -1):
                if palindrome // num2 > upper_bound:
                    break  # Since num2 is decreasing, no need to check further
                if palindrome % num2 == 0:
                    return palindrome % 1337
        
        return 0  # This line should never be reached given the problem constraints
```

This solution iterates from the largest possible n-digit number downwards to generate potential palindromes. It checks if each palindrome can be expressed as a product of two n-digit numbers and returns the largest such palindrome modulo 1337. The constraints ensure that the solution will always find a valid palindrome.

The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.

For examples, if arr = [2,3,4], the median is 3.
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.

You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.
Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.
 
Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]
Explanation: 
Window position                Median
---------------                -----
[1  3  -1] -3  5  3  6  7        1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7        3
 1  3  -1  -3 [5  3  6] 7        5
 1  3  -1  -3  5 [3  6  7]       6

Example 2:

Input: nums = [1,2,3,4,2,3,1,4,2], k = 3
Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]

 
Constraints:

1 <= k <= nums.length <= 105
-231 <= nums[i] <= 231 - 1



To solve the problem of finding the median of each sliding window of size `k` in the array `nums`, we can use a data structure that allows efficient insertion, deletion, and access to the median. The `SortedList` from the `sortedcontainers` module is well-suited for this task because it maintains the elements in sorted order and provides efficient operations for inserting and removing elements.

Here's the complete solution:

```python
from sortedcontainers import SortedList
from typing import List

class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        window = SortedList(nums[:k])
        medians = []
        
        for i in range(k - 1, len(nums)):
            # Add the median of the current window to the result
            if k % 2 == 1:
                medians.append(window[k // 2])
            else:
                medians.append((window[k // 2] + window[k // 2 - 1]) / 2.0)
            
            # Slide the window: remove the element that is sliding out of the window
            if i + 1 < len(nums):
                window.remove(nums[i - k + 1])
                window.add(nums[i + 1])
        
        return medians
```

### Explanation:
1. **Initialization**:
   - We initialize a `SortedList` with the first `k` elements of `nums`. This list will help us keep the elements of the current window in sorted order.
   - We also initialize an empty list `medians` to store the median of each window.

2. **First Window Median Calculation**:
   - For the first window (from index 0 to k-1), we calculate the median and add it to the `medians` list.

3. **Sliding the Window**:
   - For each subsequent position of the window (from index `k-1` to `len(nums)-1`):
     - We calculate the median of the current window and add it to the `medians` list.
     - We remove the element that is sliding out of the window from the `SortedList`.
     - We add the new element that is sliding into the window to the `SortedList`.

4. **Return the Result**:
   - After processing all windows, we return the `medians` list.

The `SortedList` ensures that all operations (insertion, deletion, and median access) are efficient, making this approach suitable for the problem constraints.

A magical string s consists of only '1' and '2' and obeys the following rules:

The string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.

The first few elements of s is s = "1221121221221121122……". If we group the consecutive 1's and 2's in s, it will be "1 22 11 2 1 22 1 22 11 2 11 22 ......" and the occurrences of 1's or 2's in each group are "1 2 2 1 1 2 1 2 2 1 2 2 ......". You can see that the occurrence sequence is s itself.
Given an integer n, return the number of 1's in the first n number in the magical string s.
 
Example 1:

Input: n = 6
Output: 3
Explanation: The first 6 elements of magical string s is "122112" and it contains three 1's, so return 3.

Example 2:

Input: n = 1
Output: 1

 
Constraints:

1 <= n <= 105



```python
class Solution:
    def magicalString(self, n: int) -> int:
        if n == 0:
            return 0
        if n <= 3:
            return 1
        
        # Initialize the magical string with the first few elements
        s = [1, 2, 2]
        i = 2  # The position in s that indicates the length of the next group
        
        while len(s) < n:
            next_num = 3 - s[-1]  # Determine the next number to add (1 or 2)
            next_count = s[i]  # Determine how many times the next number should be added
            
            # Extend the magical string by adding the next number the required number of times
            s.extend([next_num] * next_count)
            
            i += 1  # Move to the next position in s
        
        # Return the count of 1's in the first n elements of the magical string
        return s[:n].count(1)
```

This solution initializes the magical string with the first few elements and then iteratively builds the string by following the rules provided. It keeps track of the position in the string that indicates the length of the next group and alternates between adding '1's and '2's. Finally, it counts the number of '1's in the first `n` elements of the magical string.

